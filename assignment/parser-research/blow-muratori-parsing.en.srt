1
00:00:01,640 --> 00:00:06,000
this is a follow-up

2
00:00:03,520 --> 00:00:07,600
discussion I I don't remember the exact

3
00:00:06,000 --> 00:00:10,240
date you can find out from the video on

4
00:00:07,600 --> 00:00:13,360
YouTube probably but a few years ago at

5
00:00:10,240 --> 00:00:17,320
this point um I had a conversation with

6
00:00:13,360 --> 00:00:19,520
Casey and it was just sort of

7
00:00:17,320 --> 00:00:21,320
um you know it was this topic that had

8
00:00:19,520 --> 00:00:24,680
been bubbling around in the background

9
00:00:21,320 --> 00:00:26,359
for a while like parsing programming

10
00:00:24,680 --> 00:00:29,279
languages had bothered you like the way

11
00:00:26,359 --> 00:00:31,960
it's discussed or whatever we go into

12
00:00:29,279 --> 00:00:33,800
much more detail the talk um and I had

13
00:00:31,960 --> 00:00:35,239
done it a bunch and then especially for

14
00:00:33,800 --> 00:00:36,879
this programming language I'm working on

15
00:00:35,239 --> 00:00:39,000
now I had to do a much more thorough and

16
00:00:36,879 --> 00:00:40,520
serious job than ever because there's

17
00:00:39,000 --> 00:00:42,200
just way more features in the language

18
00:00:40,520 --> 00:00:45,039
and there's more weird cases that come

19
00:00:42,200 --> 00:00:48,960
up and so you know the main gist of that

20
00:00:45,039 --> 00:00:52,039
talk back then was like look this thing

21
00:00:48,960 --> 00:00:54,480
that they call recursive descent parsing

22
00:00:52,039 --> 00:00:57,640
which is a very technical term that what

23
00:00:54,480 --> 00:00:59,399
it actually means is just write code the

24
00:00:57,640 --> 00:01:00,920
way you normally would for any other

25
00:00:59,399 --> 00:01:03,440
program

26
00:01:00,920 --> 00:01:05,560
right um and don't do any of the crazy

27
00:01:03,440 --> 00:01:07,320
[ __ ] that they teach you in college um

28
00:01:05,560 --> 00:01:09,600
is the right way to write a parser like

29
00:01:07,320 --> 00:01:10,920
unambiguously and it's much simpler and

30
00:01:09,600 --> 00:01:12,960
you get better error messages and all

31
00:01:10,920 --> 00:01:15,080
that anyone who's interested in that can

32
00:01:12,960 --> 00:01:16,960
go watch that video now one of the

33
00:01:15,080 --> 00:01:18,119
topics that came up you know toward the

34
00:01:16,960 --> 00:01:21,520
middle or toward the end was the

35
00:01:18,119 --> 00:01:22,720
operator precedence topic right and you

36
00:01:21,520 --> 00:01:24,200
were like what do you do for operator

37
00:01:22,720 --> 00:01:27,000
precedence and what I said at the time

38
00:01:24,200 --> 00:01:31,119
was uh well you know I do what I think

39
00:01:27,000 --> 00:01:33,560
is probably the second best thing thing

40
00:01:31,119 --> 00:01:35,680
um which is I do this tree

41
00:01:33,560 --> 00:01:38,600
rewriting which is just you know to

42
00:01:35,680 --> 00:01:40,240
summarize it very briefly we'll go into

43
00:01:38,600 --> 00:01:43,479
what this precedence problem is in a

44
00:01:40,240 --> 00:01:45,880
second too if you don't understand it

45
00:01:43,479 --> 00:01:47,640
um it was just like look anytime you

46
00:01:45,880 --> 00:01:50,119
make a

47
00:01:47,640 --> 00:01:52,079
node uh if there's a precedence problem

48
00:01:50,119 --> 00:01:53,960
you can detect it by only looking at one

49
00:01:52,079 --> 00:01:55,840
layer of the thing because by induction

50
00:01:53,960 --> 00:01:57,880
everything else is correct so if you

51
00:01:55,840 --> 00:02:01,000
just rewrite your tree with some random

52
00:01:57,880 --> 00:02:02,520
function um then you're fine

53
00:02:01,000 --> 00:02:05,960
and and you don't have to think about

54
00:02:02,520 --> 00:02:07,520
any computer sciencey thing right and

55
00:02:05,960 --> 00:02:12,879
that was a totally reasonable way to do

56
00:02:07,520 --> 00:02:14,400
it um it certainly worked for nine or

57
00:02:12,879 --> 00:02:15,959
something like that years depending on

58
00:02:14,400 --> 00:02:17,840
how you count I mean the compiler was a

59
00:02:15,959 --> 00:02:18,640
side project at first but you know a

60
00:02:17,840 --> 00:02:21,280
long

61
00:02:18,640 --> 00:02:23,160
time um you know beta shipped to

62
00:02:21,280 --> 00:02:25,879
hundreds of happy beta users using it

63
00:02:23,160 --> 00:02:28,000
but then you know Christmas time and New

64
00:02:25,879 --> 00:02:31,560
Year's is often a

65
00:02:28,000 --> 00:02:34,959
very productive programming time for me

66
00:02:31,560 --> 00:02:36,400
because or game design time honestly but

67
00:02:34,959 --> 00:02:39,480
programming is easier when you're

68
00:02:36,400 --> 00:02:42,080
overworked um

69
00:02:39,480 --> 00:02:44,680
so uh you know I did a bunch of stuff

70
00:02:42,080 --> 00:02:47,560
but then sort of at the end of my New

71
00:02:44,680 --> 00:02:50,120
Year's time I was like

72
00:02:47,560 --> 00:02:52,120
hey let me you know I think something

73
00:02:50,120 --> 00:02:53,879
initiated this like I wanted to change

74
00:02:52,120 --> 00:02:55,720
some feature in the thing and I was like

75
00:02:53,879 --> 00:02:58,239
oh I have to go deal with this parser

76
00:02:55,720 --> 00:03:00,959
thing and it felt a little bit annoying

77
00:02:58,239 --> 00:03:03,920
so I said hey let me just go back and

78
00:03:00,959 --> 00:03:06,640
see what I can do about the precedent

79
00:03:03,920 --> 00:03:08,200
situation can I do it what I said was

80
00:03:06,640 --> 00:03:11,040
the first best way and can I do it as

81
00:03:08,200 --> 00:03:12,400
cleanly as possible and can I really

82
00:03:11,040 --> 00:03:14,640
understand it clearly because part of

83
00:03:12,400 --> 00:03:16,640
the problem is part of the reason I

84
00:03:14,640 --> 00:03:18,879
didn't do it that way in the first place

85
00:03:16,640 --> 00:03:21,080
way back when I started the compiler was

86
00:03:18,879 --> 00:03:22,599
I would go read some of these references

87
00:03:21,080 --> 00:03:26,200
and they're like really hard to

88
00:03:22,599 --> 00:03:27,680
understand and you know I don't exactly

89
00:03:26,200 --> 00:03:28,920
see how this relates to what I'm really

90
00:03:27,680 --> 00:03:30,040
trying to do and all this and we'll

91
00:03:28,920 --> 00:03:32,640
we'll go through some of those

92
00:03:30,040 --> 00:03:34,360
references but the point being um last

93
00:03:32,640 --> 00:03:36,400
week I think it was Saturday one week

94
00:03:34,360 --> 00:03:40,760
ago today

95
00:03:36,400 --> 00:03:44,840
uh I just rewrote the way precedence

96
00:03:40,760 --> 00:03:48,760
works in the parser um and got rid of

97
00:03:44,840 --> 00:03:51,080
all the tree rewriting and it uh it

98
00:03:48,760 --> 00:03:52,720
works great and I did that for you know

99
00:03:51,080 --> 00:03:55,360
the programming language is not a toy

100
00:03:52,720 --> 00:03:57,200
language it's a C++ competitor language

101
00:03:55,360 --> 00:03:59,720
with a pretty complex grammar and so I

102
00:03:57,200 --> 00:04:02,280
just want to not even talk through the

103
00:03:59,720 --> 00:04:04,159
method so much cuz the method is I mean

104
00:04:02,280 --> 00:04:06,120
it's so simple it's unbelievable that

105
00:04:04,159 --> 00:04:07,879
it's even been a problem for decades

106
00:04:06,120 --> 00:04:11,680
right that's really the point that I

107
00:04:07,879 --> 00:04:14,799
want to get to is it's so simple it's

108
00:04:11,680 --> 00:04:16,320
crazy and if anybody had ever just sat

109
00:04:14,799 --> 00:04:18,199
down and said look here's the thing and

110
00:04:16,320 --> 00:04:19,919
in fact there are a couple references

111
00:04:18,199 --> 00:04:20,840
that kind of do that and I'll I'll go to

112
00:04:19,919 --> 00:04:23,240
those

113
00:04:20,840 --> 00:04:25,800
but the problem is they're hard to find

114
00:04:23,240 --> 00:04:27,479
on the modern internet like yeah I would

115
00:04:25,800 --> 00:04:29,280
say that like there's there's been a

116
00:04:27,479 --> 00:04:31,560
couple things that people have pointed

117
00:04:29,280 --> 00:04:33,720
me to I think actually after the

118
00:04:31,560 --> 00:04:35,720
discussion that we had where like it's

119
00:04:33,720 --> 00:04:37,960
actually really simple like here's

120
00:04:35,720 --> 00:04:40,000
here's two examples that like I wrote up

121
00:04:37,960 --> 00:04:43,600
for you it's like five lines of code or

122
00:04:40,000 --> 00:04:46,160
whatever right and I'm like oh uh and

123
00:04:43,600 --> 00:04:47,520
and you would never know that if like

124
00:04:46,160 --> 00:04:49,560
primarily what someone handed you was

125
00:04:47,520 --> 00:04:51,880
the Dragon book right you would you

126
00:04:49,560 --> 00:04:53,320
would have no idea that anyone had ever

127
00:04:51,880 --> 00:04:55,000
figured that out because you would have

128
00:04:53,320 --> 00:04:57,600
assumed well surely they would rewrite

129
00:04:55,000 --> 00:05:00,000
this part of the book if you could do it

130
00:04:57,600 --> 00:05:01,440
but they don't and so it's very leading

131
00:05:00,000 --> 00:05:03,759
to people who are getting into this

132
00:05:01,440 --> 00:05:06,400
because the things that they will find

133
00:05:03,759 --> 00:05:08,440
uh end up being like uh really

134
00:05:06,400 --> 00:05:10,479
obfuscating for some reason yeah since

135
00:05:08,440 --> 00:05:12,639
you're on this we'll go back in a second

136
00:05:10,479 --> 00:05:16,440
and explain what this is for people who

137
00:05:12,639 --> 00:05:19,400
are lost right but you know so the

138
00:05:16,440 --> 00:05:22,080
Dragon book was 1986 I went back and

139
00:05:19,400 --> 00:05:23,639
looked right and that's sort of based on

140
00:05:22,080 --> 00:05:27,240
this green dragon book which was an

141
00:05:23,639 --> 00:05:29,720
earlier thing from 1977 right um a green

142
00:05:27,240 --> 00:05:31,199
dragon book Yeah we actually had a few

143
00:05:29,720 --> 00:05:33,160
copies of it at Berkeley too it was what

144
00:05:31,199 --> 00:05:35,160
you would buy at the used University

145
00:05:33,160 --> 00:05:37,400
Bookstore okay if you couldn't get the

146
00:05:35,160 --> 00:05:37,400
other

147
00:05:37,880 --> 00:05:44,400
one um so this the the sort of the paper

148
00:05:41,880 --> 00:05:46,120
that everyone cites that lays out how to

149
00:05:44,400 --> 00:05:47,800
do this is this topown operator

150
00:05:46,120 --> 00:05:50,360
precedence paper from

151
00:05:47,800 --> 00:05:54,800
1973 which predates the Dragon book by

152
00:05:50,360 --> 00:05:56,360
13 years okay that's that's amazing and

153
00:05:54,800 --> 00:05:58,520
even the green dragon book by a few

154
00:05:56,360 --> 00:06:00,680
years um but actually that's actually

155
00:05:58,520 --> 00:06:03,639
the same thing as is something that dyra

156
00:06:00,680 --> 00:06:06,800
did in a paper called an alol 60

157
00:06:03,639 --> 00:06:09,039
translator for the X1 right which how

158
00:06:06,800 --> 00:06:11,759
would you ever think about reading that

159
00:06:09,039 --> 00:06:13,479
paper from the title right um but it's

160
00:06:11,759 --> 00:06:15,720
also it's OB fiscated because it's this

161
00:06:13,479 --> 00:06:18,599
thing called shunting yard algorithm

162
00:06:15,720 --> 00:06:21,479
which is about stack manipulation to to

163
00:06:18,599 --> 00:06:23,199
put things in this fourth like thing

164
00:06:21,479 --> 00:06:25,120
right which doesn't really look like

165
00:06:23,199 --> 00:06:26,840
very much like what you want to do if

166
00:06:25,120 --> 00:06:28,840
you're parsing a programming language

167
00:06:26,840 --> 00:06:30,360
however it's the same it's like

168
00:06:28,840 --> 00:06:33,520
understanding what order the operations

169
00:06:30,360 --> 00:06:35,039
need to occur in and then making the

170
00:06:33,520 --> 00:06:39,520
correct output right and the making the

171
00:06:35,039 --> 00:06:41,560
correct output step is different but the

172
00:06:39,520 --> 00:06:43,000
understanding it is is the same um I

173
00:06:41,560 --> 00:06:44,360
didn't really try to read that paper

174
00:06:43,000 --> 00:06:49,280
though too because the more you go back

175
00:06:44,360 --> 00:06:52,400
in time the harder computer science you

176
00:06:49,280 --> 00:06:53,520
know Publications are to read um because

177
00:06:52,400 --> 00:06:55,199
everything was different and you don't

178
00:06:53,520 --> 00:06:56,479
have context and a lot of terms mean

179
00:06:55,199 --> 00:06:59,440
different things now than they meant

180
00:06:56,479 --> 00:07:02,360
then and stuff um but also honestly what

181
00:06:59,440 --> 00:07:05,360
happened with this was um I also just

182
00:07:02,360 --> 00:07:06,720
have very little patience now for trying

183
00:07:05,360 --> 00:07:08,919
to read things so if I start trying to

184
00:07:06,720 --> 00:07:10,319
read a few references and I just there's

185
00:07:08,919 --> 00:07:12,080
this thing that happens on the internet

186
00:07:10,319 --> 00:07:14,000
where there's a miasma of stuff and you

187
00:07:12,080 --> 00:07:15,520
start to get lost and you're like okay

188
00:07:14,000 --> 00:07:17,680
this person is saying it's easy but

189
00:07:15,520 --> 00:07:21,639
maybe they're a bozo maybe they're not a

190
00:07:17,680 --> 00:07:23,639
bozo right I don't I don't know and the

191
00:07:21,639 --> 00:07:25,240
way that I the main way that I know how

192
00:07:23,639 --> 00:07:28,240
to know if someone's a bozo is to just

193
00:07:25,240 --> 00:07:31,599
go figure it out and then I have a basis

194
00:07:28,240 --> 00:07:33,160
on which to judge right um yes yes I've

195
00:07:31,599 --> 00:07:35,080
noticed that I tried to send send you

196
00:07:33,160 --> 00:07:36,120
the lp fifo paper and you were like I

197
00:07:35,080 --> 00:07:37,840
don't know they don't explain the

198
00:07:36,120 --> 00:07:40,759
algorithm or something and you didn't

199
00:07:37,840 --> 00:07:43,080
read it and I'm like no it's a good

200
00:07:40,759 --> 00:07:45,440
paper I didn't like that paper okay it's

201
00:07:43,080 --> 00:07:48,199
a good paper anyway so so to provide a

202
00:07:45,440 --> 00:07:49,720
little context for people uh who aren't

203
00:07:48,199 --> 00:07:51,960
into parsers about what exactly the

204
00:07:49,720 --> 00:07:53,280
problem is again we we covered this also

205
00:07:51,960 --> 00:07:55,680
I think in the previous video so I'm

206
00:07:53,280 --> 00:07:59,120
going to go through it really fast

207
00:07:55,680 --> 00:08:01,639
but one of the things about compilers

208
00:07:59,120 --> 00:08:03,879
and and parsing the input text that I'm

209
00:08:01,639 --> 00:08:05,440
never probably going to argue with is

210
00:08:03,879 --> 00:08:07,360
this token abstraction and we're going

211
00:08:05,440 --> 00:08:09,319
to assume it here so you get raw text in

212
00:08:07,360 --> 00:08:11,240
a file coming in and you have some part

213
00:08:09,319 --> 00:08:13,400
of your program that breaks that into

214
00:08:11,240 --> 00:08:15,479
slightly higher level things that are

215
00:08:13,400 --> 00:08:17,639
easier to think about and manipulate so

216
00:08:15,479 --> 00:08:19,440
like is something the name of a variable

217
00:08:17,639 --> 00:08:22,080
or is something a number or is it like a

218
00:08:19,440 --> 00:08:23,800
string literal or whatever that happens

219
00:08:22,080 --> 00:08:25,800
before what we're talking about so you

220
00:08:23,800 --> 00:08:27,680
have something that reads characters one

221
00:08:25,800 --> 00:08:29,840
at a time and breaks it into a stream of

222
00:08:27,680 --> 00:08:32,440
those now that's not actually strictly

223
00:08:29,840 --> 00:08:36,640
necessary to do um I've never done it

224
00:08:32,440 --> 00:08:37,839
any other way but I'm just not not going

225
00:08:36,640 --> 00:08:39,120
to argue with it here I have no

226
00:08:37,839 --> 00:08:40,959
experience doing something else than

227
00:08:39,120 --> 00:08:42,880
that probably people in the early days

228
00:08:40,959 --> 00:08:46,519
of computers did do something else than

229
00:08:42,880 --> 00:08:49,240
that um so then what a parser looks like

230
00:08:46,519 --> 00:08:51,640
so here's just a simple function for

231
00:08:49,240 --> 00:08:52,720
like P parsing a binary Operator by the

232
00:08:51,640 --> 00:08:55,200
way there's a lot of little code

233
00:08:52,720 --> 00:08:58,440
Snippets in here I just picked like this

234
00:08:55,200 --> 00:09:00,200
is a pseudo code that is kind of like C

235
00:08:58,440 --> 00:09:02,680
but with less pun punctuation that's all

236
00:09:00,200 --> 00:09:04,160
I'm doing so um nothing special so

237
00:09:02,680 --> 00:09:06,279
there's a function like if you want a

238
00:09:04,160 --> 00:09:08,560
parse a binary operator without

239
00:09:06,279 --> 00:09:11,000
recursion or anything just like a plus b

240
00:09:08,560 --> 00:09:12,600
something simple like that you call like

241
00:09:11,000 --> 00:09:14,079
parse Leaf which gives you this thing

242
00:09:12,600 --> 00:09:15,800
that's like maybe it's a number maybe

243
00:09:14,079 --> 00:09:17,880
it's an identifier and so you could get

244
00:09:15,800 --> 00:09:21,040
anything you could get a plus b you

245
00:09:17,880 --> 00:09:22,959
could get 3 plus b right you could get

246
00:09:21,040 --> 00:09:26,200
seven uh

247
00:09:22,959 --> 00:09:27,600
times hello which in a reasonable

248
00:09:26,200 --> 00:09:30,000
programming language is going to be an

249
00:09:27,600 --> 00:09:33,279
error but in some is not

250
00:09:30,000 --> 00:09:35,959
right um you're right

251
00:09:33,279 --> 00:09:38,920
so uh you

252
00:09:35,959 --> 00:09:41,079
know so so there's this fundamental uh

253
00:09:38,920 --> 00:09:42,640
layering of functions where you say I

254
00:09:41,079 --> 00:09:45,600
want a leaf and then I'm going to look

255
00:09:42,640 --> 00:09:47,959
at what the operator is so here for

256
00:09:45,600 --> 00:09:50,440
parse Leaf I would parse this three and

257
00:09:47,959 --> 00:09:51,920
then the input is like plus b and I say

258
00:09:50,440 --> 00:09:54,440
what's the operator and it's like oh

259
00:09:51,920 --> 00:09:56,560
it's plus so we eat the plus and then we

260
00:09:54,440 --> 00:09:59,240
parse the next Leaf which is B and then

261
00:09:56,560 --> 00:10:01,760
we make a binary actually so here my

262
00:09:59,240 --> 00:10:03,480
binary is a plus b so you know then we

263
00:10:01,760 --> 00:10:05,680
make a little binary tree and what this

264
00:10:03,480 --> 00:10:08,880
is is a representation of it's like a

265
00:10:05,680 --> 00:10:11,519
node with a left pointer and a right

266
00:10:08,880 --> 00:10:13,760
pointer that could point at maybe other

267
00:10:11,519 --> 00:10:15,600
binary operators even though this code

268
00:10:13,760 --> 00:10:17,839
can't generate that here it's just

269
00:10:15,600 --> 00:10:20,760
pointing at two leaves right A plus b

270
00:10:17,839 --> 00:10:22,320
right um now of course if you want a

271
00:10:20,760 --> 00:10:24,800
parse more than a plus b the typical

272
00:10:22,320 --> 00:10:26,959
thing you do in a parser is you make

273
00:10:24,800 --> 00:10:29,959
this effectively recursive whether the

274
00:10:26,959 --> 00:10:31,880
code's actually recursive or not right

275
00:10:29,959 --> 00:10:34,680
um it needs to be able to you need to be

276
00:10:31,880 --> 00:10:38,399
able to refer to other binary nodes and

277
00:10:34,680 --> 00:10:38,399
stuff right

278
00:10:41,320 --> 00:10:46,920
um I'm not sure why I did this extra

279
00:10:43,920 --> 00:10:48,760
step here um this is just a version of

280
00:10:46,920 --> 00:10:51,240
parse expression that could return

281
00:10:48,760 --> 00:10:52,839
either a leaf or a binary operator based

282
00:10:51,240 --> 00:10:55,160
on what the next token is right this is

283
00:10:52,839 --> 00:10:58,160
a very typical thing to do so again if

284
00:10:55,160 --> 00:10:59,560
you say parse Leaf you get a maybe just

285
00:10:58,160 --> 00:11:01,160
because you were trying to show like

286
00:10:59,560 --> 00:11:02,519
okay so if we want to do more than one

287
00:11:01,160 --> 00:11:04,600
expression this is how we do it like

288
00:11:02,519 --> 00:11:06,920
more than one that's what I'm trying to

289
00:11:04,600 --> 00:11:08,680
get to down here I wrote this like 5

290
00:11:06,920 --> 00:11:10,320
days ago so whatever I don't totally

291
00:11:08,680 --> 00:11:13,160
remember but so if you have a longer

292
00:11:10,320 --> 00:11:15,040
thing like a plus b plus C plus d right

293
00:11:13,160 --> 00:11:17,440
then this can be recursive and here it

294
00:11:15,040 --> 00:11:19,200
it actually is recursive in fact like it

295
00:11:17,440 --> 00:11:20,760
calls itself but if you don't like

296
00:11:19,200 --> 00:11:24,240
recursion you can always convert a

297
00:11:20,760 --> 00:11:26,000
recursive function to a loop um it just

298
00:11:24,240 --> 00:11:29,480
might get really messy depending on

299
00:11:26,000 --> 00:11:31,200
what's going on um anyway so if it's

300
00:11:29,480 --> 00:11:33,839
recursive you could say let's parse a

301
00:11:31,200 --> 00:11:36,000
leaf which here will be a right you can

302
00:11:33,839 --> 00:11:37,600
get the next token that'll be plus and

303
00:11:36,000 --> 00:11:39,480
then if that's a binary operator which

304
00:11:37,600 --> 00:11:42,200
in this case it is we call parse

305
00:11:39,480 --> 00:11:44,480
expression again which will take this as

306
00:11:42,200 --> 00:11:47,279
input right and then that'll call parse

307
00:11:44,480 --> 00:11:48,720
expression again take that as input uh

308
00:11:47,279 --> 00:11:50,639
and that'll call parse expression again

309
00:11:48,720 --> 00:11:53,519
which will take just d as input which

310
00:11:50,639 --> 00:11:55,560
will return You A D um and then you make

311
00:11:53,519 --> 00:11:58,040
binary operators going on the way up I

312
00:11:55,560 --> 00:12:00,079
actually skipped that step here so the

313
00:11:58,040 --> 00:12:03,040
the final tree you get out of this is

314
00:12:00,079 --> 00:12:07,320
this thing right

315
00:12:03,040 --> 00:12:09,839
um a a on the left a root node right a

316
00:12:07,320 --> 00:12:12,360
on the left and then B on the left of

317
00:12:09,839 --> 00:12:14,000
the child and then the CD binary tree

318
00:12:12,360 --> 00:12:16,240
and so all the leaves are in there you

319
00:12:14,000 --> 00:12:19,360
can use your favorite computer science

320
00:12:16,240 --> 00:12:20,680
way of navigating this tree however you

321
00:12:19,360 --> 00:12:23,120
want

322
00:12:20,680 --> 00:12:26,279
now it's worth pointing

323
00:12:23,120 --> 00:12:28,519
out why why is this a tree like what

324
00:12:26,279 --> 00:12:32,320
what does the tree do well okay before

325
00:12:28,519 --> 00:12:33,639
we say that let's just go uh you know

326
00:12:32,320 --> 00:12:35,199
the point that I was making about

327
00:12:33,639 --> 00:12:37,199
talking through the recursion here is

328
00:12:35,199 --> 00:12:40,040
just that the first thing actually

329
00:12:37,199 --> 00:12:42,079
constructed is sort of this D leaf and

330
00:12:40,040 --> 00:12:43,480
then you come back up the recursion and

331
00:12:42,079 --> 00:12:45,680
now that you know what was on the right

332
00:12:43,480 --> 00:12:48,199
hand side now you have a CD right now

333
00:12:45,680 --> 00:12:49,760
you have a BCD now you have an

334
00:12:48,199 --> 00:12:53,560
ABCD

335
00:12:49,760 --> 00:12:56,320
okay this is the tree structure that is

336
00:12:53,560 --> 00:12:58,519
naturally created by doing this simple

337
00:12:56,320 --> 00:12:59,600
dumb thing right it's this right Leaning

338
00:12:58,519 --> 00:13:00,920
Tree

339
00:12:59,600 --> 00:13:03,720
if you have a longer and longer

340
00:13:00,920 --> 00:13:06,399
expression it'll just keep going you

341
00:13:03,720 --> 00:13:09,279
like extend this ladder to the

342
00:13:06,399 --> 00:13:12,639
right okay this may be out of scope for

343
00:13:09,279 --> 00:13:16,120
this discussion but I might also ask the

344
00:13:12,639 --> 00:13:19,320
question at this point for

345
00:13:16,120 --> 00:13:21,839
clarity if one were naively to look at

346
00:13:19,320 --> 00:13:24,959
that explanation and hasn't worked on

347
00:13:21,839 --> 00:13:28,839
parsers before yeah one might have the

348
00:13:24,959 --> 00:13:30,800
question why recurse down to D and then

349
00:13:28,839 --> 00:13:33,720
work back up the program stack to

350
00:13:30,800 --> 00:13:36,959
construct plus C plus b plus a why not

351
00:13:33,720 --> 00:13:39,079
just put a in when you encounter it then

352
00:13:36,959 --> 00:13:43,199
create the plus node and then create the

353
00:13:39,079 --> 00:13:47,199
B and so on like like what is the value

354
00:13:43,199 --> 00:13:50,440
of using recursion at all yes well um

355
00:13:47,199 --> 00:13:52,440
the answer in this exact case for as far

356
00:13:50,440 --> 00:13:54,560
as we've gone is that it's an arbitrary

357
00:13:52,440 --> 00:13:56,680
choice you can do it the way that you

358
00:13:54,560 --> 00:13:59,360
said and in fact we will do it that way

359
00:13:56,680 --> 00:14:01,399
in a little bit okay never mind sorry

360
00:13:59,360 --> 00:14:04,440
no no no it's totally it makes sense

361
00:14:01,399 --> 00:14:06,040
because it's it's so you know basically

362
00:14:04,440 --> 00:14:07,839
if you went to school at Berkeley like I

363
00:14:06,040 --> 00:14:09,720
did they love recursion and they drill

364
00:14:07,839 --> 00:14:12,279
it into you and so it's the it's the way

365
00:14:09,720 --> 00:14:15,079
that you would do things right okay yep

366
00:14:12,279 --> 00:14:18,000
um okay actually maybe that other

367
00:14:15,079 --> 00:14:19,680
version is recursive too but you could

368
00:14:18,000 --> 00:14:24,959
convert it to a loop it's again it's not

369
00:14:19,680 --> 00:14:28,800
a big deal um okay now just to give some

370
00:14:24,959 --> 00:14:32,320
context about what this tree is right uh

371
00:14:28,800 --> 00:14:35,279
what it just represents is operations

372
00:14:32,320 --> 00:14:38,240
that you do in what order right so the

373
00:14:35,279 --> 00:14:40,279
plus you know represents I'm going to

374
00:14:38,240 --> 00:14:41,600
add two things and what's on the left is

375
00:14:40,279 --> 00:14:43,079
the left thing that I add and what's on

376
00:14:41,600 --> 00:14:45,320
the right is the right thing that I add

377
00:14:43,079 --> 00:14:47,600
right and if if what's on the right is

378
00:14:45,320 --> 00:14:49,360
more complex than just a leaf then it

379
00:14:47,600 --> 00:14:51,759
sort of means you don't know the answer

380
00:14:49,360 --> 00:14:54,560
yet you have to go do that stuff and

381
00:14:51,759 --> 00:14:57,000
then you can do the plus right so in

382
00:14:54,560 --> 00:14:58,839
this case it's like a plus what I don't

383
00:14:57,000 --> 00:15:01,079
know it's whatever this is okay okay

384
00:14:58,839 --> 00:15:03,120
well that's B plus what I don't know

385
00:15:01,079 --> 00:15:05,839
that's C plus d oh I know what c plus d

386
00:15:03,120 --> 00:15:07,880
are so I can add this right and then I

387
00:15:05,839 --> 00:15:09,360
can that gives me what to add to B and

388
00:15:07,880 --> 00:15:12,240
that gives me what to add to a so what

389
00:15:09,360 --> 00:15:14,920
the tree is effectively doing I probably

390
00:15:12,240 --> 00:15:17,560
say this later too but what this tree is

391
00:15:14,920 --> 00:15:21,759
effectively doing is it's parenthesizes

392
00:15:17,560 --> 00:15:23,279
your expression like this okay right and

393
00:15:21,759 --> 00:15:25,320
the way to remember that that's really

394
00:15:23,279 --> 00:15:27,720
easy is if you see parentheses in the

395
00:15:25,320 --> 00:15:30,079
equation it's the same as like circling

396
00:15:27,720 --> 00:15:33,839
a sub tree like if you can Circle a sub

397
00:15:30,079 --> 00:15:36,279
tree without cutting any uh cutting

398
00:15:33,839 --> 00:15:38,319
sideways then that's the parentheses in

399
00:15:36,279 --> 00:15:39,920
the equation yeah yeah it's the same

400
00:15:38,319 --> 00:15:42,480
thing

401
00:15:39,920 --> 00:15:45,440
okay now here's the whole point of what

402
00:15:42,480 --> 00:15:47,480
we're talking about which is you want to

403
00:15:45,440 --> 00:15:50,440
be able to not have to type this all the

404
00:15:47,480 --> 00:15:51,880
time right and it's natural and

405
00:15:50,440 --> 00:15:57,000
everybody's used to being able to say

406
00:15:51,880 --> 00:15:59,279
something like a plus b * C plus d but B

407
00:15:57,000 --> 00:16:01,360
* C is supposed to happen first that's

408
00:15:59,279 --> 00:16:04,199
just something we decided as human

409
00:16:01,360 --> 00:16:05,759
beings that we want to do um and of

410
00:16:04,199 --> 00:16:07,680
course plus and times are not the only

411
00:16:05,759 --> 00:16:09,360
example of this it comes up in a number

412
00:16:07,680 --> 00:16:12,279
of cases but this is the simplest one

413
00:16:09,360 --> 00:16:14,319
probably that people understand um that

414
00:16:12,279 --> 00:16:16,399
said this one seems more

415
00:16:14,319 --> 00:16:18,959
arbitrary because like it is a human

416
00:16:16,399 --> 00:16:21,160
choice but there's other

417
00:16:18,959 --> 00:16:22,560
ones I don't know I guess if you were

418
00:16:21,160 --> 00:16:24,480
willing to put parenthesis around

419
00:16:22,560 --> 00:16:27,519
literally everything this wouldn't be a

420
00:16:24,480 --> 00:16:30,720
problem but it just comes up a lot right

421
00:16:27,519 --> 00:16:33,600
so if we run the same code on a plus b *

422
00:16:30,720 --> 00:16:35,440
C plus d right well this code didn't

423
00:16:33,600 --> 00:16:36,800
care any about any detail of the

424
00:16:35,440 --> 00:16:39,560
operator right so we're going to get the

425
00:16:36,800 --> 00:16:41,920
same output which is this this same tree

426
00:16:39,560 --> 00:16:43,079
except instead of this plus up here

427
00:16:41,920 --> 00:16:47,040
we're going to get a

428
00:16:43,079 --> 00:16:49,600
times and by this parenthesis making

429
00:16:47,040 --> 00:16:51,519
that I just did that gives us this right

430
00:16:49,600 --> 00:16:53,839
I left out sort of the outer parenthesis

431
00:16:51,519 --> 00:16:56,759
but yeah which is not what we would

432
00:16:53,839 --> 00:16:58,040
consider the right answer right um this

433
00:16:56,759 --> 00:17:00,120
is what we would consider the right

434
00:16:58,040 --> 00:17:02,800
answer is parentheses in the

435
00:17:00,120 --> 00:17:04,760
middle okay and then here's where I was

436
00:17:02,800 --> 00:17:08,520
going to rant about the Dragon book and

437
00:17:04,760 --> 00:17:11,520
stuff but uh we already started that um

438
00:17:08,520 --> 00:17:11,520
so I will

439
00:17:12,679 --> 00:17:18,760
say I mean I went to I went to college

440
00:17:15,120 --> 00:17:20,520
starting in like you know 1989 when like

441
00:17:18,760 --> 00:17:21,919
all the web stuff hadn't happened yet

442
00:17:20,520 --> 00:17:23,640
but a lot of this other stuff was

443
00:17:21,919 --> 00:17:24,959
considered old and established and just

444
00:17:23,640 --> 00:17:27,640
the more I look at

445
00:17:24,959 --> 00:17:29,559
it the more I feel like a lot of

446
00:17:27,640 --> 00:17:31,640
computer science was just corrupt lazy

447
00:17:29,559 --> 00:17:34,640
people who didn't really solve problems

448
00:17:31,640 --> 00:17:36,320
I mean I hate to say it I hate to say it

449
00:17:34,640 --> 00:17:38,760
but and this is just one instance of it

450
00:17:36,320 --> 00:17:40,880
and not so these people weren't corrupt

451
00:17:38,760 --> 00:17:42,559
lazy people and even maybe the Dragon

452
00:17:40,880 --> 00:17:44,280
book people are not corrupt lazy people

453
00:17:42,559 --> 00:17:46,280
they wrote a big book full of a it's a

454
00:17:44,280 --> 00:17:48,440
really complicated book full of stuff

455
00:17:46,280 --> 00:17:50,240
right but there was this horrible

456
00:17:48,440 --> 00:17:53,360
malfunction that Casey already referred

457
00:17:50,240 --> 00:17:56,880
to where this book got used as the

458
00:17:53,360 --> 00:17:59,039
standard for how to teach compilers in

459
00:17:56,880 --> 00:18:00,720
basically every certain certainly good

460
00:17:59,039 --> 00:18:02,039
school computer science class and

461
00:18:00,720 --> 00:18:05,080
probably everything else because what

462
00:18:02,039 --> 00:18:08,159
else would you use and the problem

463
00:18:05,080 --> 00:18:10,240
is it makes out parsing like it's really

464
00:18:08,159 --> 00:18:13,600
really really hard and like an entire

465
00:18:10,240 --> 00:18:15,760
science of its own and doesn't say much

466
00:18:13,600 --> 00:18:18,520
about the rest of compilation which is

467
00:18:15,760 --> 00:18:20,240
actually the hard part oh it's it's it's

468
00:18:18,520 --> 00:18:21,960
horrible for that like it's like if you

469
00:18:20,240 --> 00:18:23,679
read that book you would assume that

470
00:18:21,960 --> 00:18:27,159
most of writing a compiler is trying to

471
00:18:23,679 --> 00:18:30,000
get a parser working yeah and then you

472
00:18:27,159 --> 00:18:31,799
like generate some very simple code from

473
00:18:30,000 --> 00:18:33,679
the pars Tre afterwards now just so

474
00:18:31,799 --> 00:18:35,679
people don't know just so people don't

475
00:18:33,679 --> 00:18:38,640
say you don't know what you're talking

476
00:18:35,679 --> 00:18:40,159
about like oh you went to you went to

477
00:18:38,640 --> 00:18:43,000
school in the Stone Age it's different

478
00:18:40,159 --> 00:18:45,240
now so I have a current copy like this

479
00:18:43,000 --> 00:18:47,720
is what you would buy off Amazon

480
00:18:45,240 --> 00:18:50,000
now um oh wow can I see that can you

481
00:18:47,720 --> 00:18:52,640
hold up that cover oh yeah it's awesome

482
00:18:50,000 --> 00:18:55,679
it's it's got a computer generated cover

483
00:18:52,640 --> 00:18:57,840
the old green dragon book has a horrible

484
00:18:55,679 --> 00:19:01,440
you know hand Illustrated cover that's

485
00:18:57,840 --> 00:19:05,159
just not involving computers in any way

486
00:19:01,440 --> 00:19:07,120
and so they replaced it with like

487
00:19:05,159 --> 00:19:11,320
whatever you could do in

488
00:19:07,120 --> 00:19:14,919
1997 on a silicon Graphics wow no before

489
00:19:11,320 --> 00:19:18,320
that 19 yeah I don't know anyway this it

490
00:19:14,919 --> 00:19:20,360
has some additional chapters in the end

491
00:19:18,320 --> 00:19:22,679
um where they talk a little bit about

492
00:19:20,360 --> 00:19:27,159
data flow analysis and

493
00:19:22,679 --> 00:19:28,919
like bite code and stuff but it's a

494
00:19:27,159 --> 00:19:31,640
small part of the book

495
00:19:28,919 --> 00:19:34,240
and the problem with all that stuff is

496
00:19:31,640 --> 00:19:35,919
just they like touch on the topics and

497
00:19:34,240 --> 00:19:38,559
each of these topics like really could

498
00:19:35,919 --> 00:19:40,960
have a whole book and of course I don't

499
00:19:38,559 --> 00:19:43,120
know but the point being like I think

500
00:19:40,960 --> 00:19:44,559
the laziness is institutional it's not I

501
00:19:43,120 --> 00:19:46,480
don't wish to pick on the Dragon book

502
00:19:44,559 --> 00:19:50,159
too hard because the fact

503
00:19:46,480 --> 00:19:53,480
is the institution of Computer Science

504
00:19:50,159 --> 00:19:54,919
Education could have well they did

505
00:19:53,480 --> 00:19:56,440
accept the Dragon book as the thing that

506
00:19:54,919 --> 00:19:58,840
they're going to teach and that's that's

507
00:19:56,440 --> 00:20:01,880
what it is they could have

508
00:19:58,840 --> 00:20:03,679
not done that right and and gone out and

509
00:20:01,880 --> 00:20:05,880
dug up like a reading list of these old

510
00:20:03,679 --> 00:20:08,840
papers at least or somebody else could

511
00:20:05,880 --> 00:20:10,720
have made like a a different book and

512
00:20:08,840 --> 00:20:11,960
well or you could say this was the main

513
00:20:10,720 --> 00:20:16,480
thing that I was going to add about the

514
00:20:11,960 --> 00:20:19,640
Dragon book as well is the Dragon book

515
00:20:16,480 --> 00:20:20,919
also when you are handed it at least I'm

516
00:20:19,640 --> 00:20:23,159
thinking of more the I think it was a

517
00:20:20,919 --> 00:20:24,679
red dragon book that was the the the one

518
00:20:23,159 --> 00:20:26,559
that I saw second edition yeah this is

519
00:20:24,679 --> 00:20:29,039
this is the more modern computer Dragon

520
00:20:26,559 --> 00:20:30,799
book I haven't seen that one but when

521
00:20:29,039 --> 00:20:32,760
someone hands you the Red Dragon book

522
00:20:30,799 --> 00:20:35,919
they were like this is the book to read

523
00:20:32,760 --> 00:20:38,360
about compilers at implying that somehow

524
00:20:35,919 --> 00:20:39,760
it's a good book to read about compiling

525
00:20:38,360 --> 00:20:41,960
that is my makeup if someone handed it

526
00:20:39,760 --> 00:20:43,440
to me and went this book actually sucks

527
00:20:41,960 --> 00:20:45,600
but I don't have anything else to hand

528
00:20:43,440 --> 00:20:47,320
you that's fine I've had to do that to

529
00:20:45,600 --> 00:20:48,919
people uh before where it's like I don't

530
00:20:47,320 --> 00:20:51,520
know of a good reference you can try

531
00:20:48,919 --> 00:20:54,000
this but it's lousy the the dragon books

532
00:20:51,520 --> 00:20:57,840
problem was people claimed it was good

533
00:20:54,000 --> 00:20:58,919
yes mainly yes and it's not yeah anyway

534
00:20:57,840 --> 00:21:01,000
so

535
00:20:58,919 --> 00:21:02,480
uh if you look on the internet today

536
00:21:01,000 --> 00:21:04,159
there's as you know a lot of trash

537
00:21:02,480 --> 00:21:08,159
information and that's the main problem

538
00:21:04,159 --> 00:21:08,159
there are some references that are okay

539
00:21:08,480 --> 00:21:13,880
um uh you know like like I said I think

540
00:21:12,159 --> 00:21:16,159
a few minutes ago when I went back and

541
00:21:13,880 --> 00:21:17,520
read this old paper which is sort of

542
00:21:16,159 --> 00:21:21,320
what what we're going to talk about what

543
00:21:17,520 --> 00:21:22,600
it's based on um I think although I

544
00:21:21,320 --> 00:21:24,000
don't know because honestly my eyes

545
00:21:22,600 --> 00:21:26,840
glazed over and I didn't finish the

546
00:21:24,000 --> 00:21:28,559
paper right but this is sort it's it's

547
00:21:26,840 --> 00:21:31,039
unreadable dude

548
00:21:28,559 --> 00:21:34,200
um but so here's some Modern references

549
00:21:31,039 --> 00:21:35,640
that are more readable uh so although

550
00:21:34,200 --> 00:21:38,600
okay they do a couple different things

551
00:21:35,640 --> 00:21:40,919
and we'll get into it so this one uh is

552
00:21:38,600 --> 00:21:42,880
what I looked at last week I didn't even

553
00:21:40,919 --> 00:21:45,760
really read this one all the way I just

554
00:21:42,880 --> 00:21:47,120
sort of skimmed it uh it's called

555
00:21:45,760 --> 00:21:51,919
parsing Expressions by precedence

556
00:21:47,120 --> 00:21:53,520
climbing here's the URL um will you know

557
00:21:51,919 --> 00:21:56,880
what I'll paste this into chat for

558
00:21:53,520 --> 00:21:58,480
anyone who wants um let me if I paste

559
00:21:56,880 --> 00:22:01,960
this whole thing into chat that will

560
00:21:58,480 --> 00:22:06,640
that work people can pick you're asking

561
00:22:01,960 --> 00:22:06,640
a lot of twitch there I am let's

562
00:22:06,799 --> 00:22:12,440
see no it didn't uh it didn't paste the

563
00:22:09,640 --> 00:22:16,240
whole thing so here's part

564
00:22:12,440 --> 00:22:18,840
one and then because it's more than like

565
00:22:16,240 --> 00:22:20,320
you know a Twitter number of characters

566
00:22:18,840 --> 00:22:22,480
and that was their competition or

567
00:22:20,320 --> 00:22:24,640
whatever while you're doing stream stuff

568
00:22:22,480 --> 00:22:26,799
do you want to move your camera up a bit

569
00:22:24,640 --> 00:22:28,640
you're you're off the bottom fairly

570
00:22:26,799 --> 00:22:31,720
frequently I think when

571
00:22:28,640 --> 00:22:33,760
typing well no you know I just don't

572
00:22:31,720 --> 00:22:36,480
want to I don't care fair

573
00:22:33,760 --> 00:22:39,080
enough um okay

574
00:22:36,480 --> 00:22:41,360
so so this one is the one that I read in

575
00:22:39,080 --> 00:22:43,520
order to to figure out but I sort of

576
00:22:41,360 --> 00:22:46,720
skimmed it it's like here's some code in

577
00:22:43,520 --> 00:22:48,799
Python and the python code instead of

578
00:22:46,720 --> 00:22:50,559
like an enum and C to decide what you're

579
00:22:48,799 --> 00:22:52,840
doing it like uses strings and like

580
00:22:50,559 --> 00:22:55,760
switches off the string it's like okay

581
00:22:52,840 --> 00:22:59,320
okay we're not really reading this right

582
00:22:55,760 --> 00:23:00,720
um but it is the basic idea uh now a lot

583
00:22:59,320 --> 00:23:03,279
of people like this book crafting

584
00:23:00,720 --> 00:23:05,000
interpreters which is also on the

585
00:23:03,279 --> 00:23:06,919
internet and and when I posted about

586
00:23:05,000 --> 00:23:08,440
this talk people were like oh I know

587
00:23:06,919 --> 00:23:10,400
it's easy because I just read crafting

588
00:23:08,440 --> 00:23:14,120
interpreters and it does recursive

589
00:23:10,400 --> 00:23:16,480
descent parsing right okay here's the

590
00:23:14,120 --> 00:23:19,480
thing what they do in this book is

591
00:23:16,480 --> 00:23:21,240
recursive descent that will handle

592
00:23:19,480 --> 00:23:24,520
precedence

593
00:23:21,240 --> 00:23:26,520
however it's pretty slow and really ugly

594
00:23:24,520 --> 00:23:28,200
and I do not recommend doing it that way

595
00:23:26,520 --> 00:23:32,520
we can talk at the end about what this

596
00:23:28,200 --> 00:23:35,000
is cu it's kind of interesting in this

597
00:23:32,520 --> 00:23:37,200
like in terms of like how possibly

598
00:23:35,000 --> 00:23:39,159
stupid can you make it this is maybe

599
00:23:37,200 --> 00:23:41,760
even one step more stupid than what I'm

600
00:23:39,159 --> 00:23:44,240
going to do um I don't recommend doing

601
00:23:41,760 --> 00:23:45,520
it this way but it is like the polar

602
00:23:44,240 --> 00:23:47,279
opposite of the Dragon book but that's

603
00:23:45,520 --> 00:23:49,960
not I'm not bagging on the author of

604
00:23:47,279 --> 00:23:52,200
this book either because he wrote A Blog

605
00:23:49,960 --> 00:23:53,480
posting like 10 years before this book

606
00:23:52,200 --> 00:23:56,400
came out where he talks about the

607
00:23:53,480 --> 00:23:58,480
Precedence thing that we're going to

608
00:23:56,400 --> 00:24:00,039
do I don't know why why he didn't do

609
00:23:58,480 --> 00:24:03,400
that in the book though like maybe he

610
00:24:00,039 --> 00:24:04,880
thought it was not as simple I don't

611
00:24:03,400 --> 00:24:06,080
know but the the thing he does in the

612
00:24:04,880 --> 00:24:07,600
book is like it's a little bit

613
00:24:06,080 --> 00:24:10,240
unconscionable I don't know maybe that's

614
00:24:07,600 --> 00:24:12,720
too strong of a word um unconscionable

615
00:24:10,240 --> 00:24:14,320
not not quite it's just you know in that

616
00:24:12,720 --> 00:24:17,440
way when you write

617
00:24:14,320 --> 00:24:18,840
software not you when people out there

618
00:24:17,440 --> 00:24:21,159
in the world just write software and

619
00:24:18,840 --> 00:24:23,360
it's doing a lot of work for something

620
00:24:21,159 --> 00:24:24,919
that should be simple right yeah yeah

621
00:24:23,360 --> 00:24:26,799
and we'll talk about what that problem

622
00:24:24,919 --> 00:24:30,320
is yeah

623
00:24:26,799 --> 00:24:32,120
um uh the most approachable explanation

624
00:24:30,320 --> 00:24:33,880
of this is actually this paper called

625
00:24:32,120 --> 00:24:36,200
writing an interpreter in

626
00:24:33,880 --> 00:24:37,679
go which if you're writing a compiler

627
00:24:36,200 --> 00:24:39,200
not an interpreter and you're don't

628
00:24:37,679 --> 00:24:42,120
program and go you probably wouldn't

629
00:24:39,200 --> 00:24:43,600
read that um I guess I forgot to paste

630
00:24:42,120 --> 00:24:44,600
the link in here but you can find this

631
00:24:43,600 --> 00:24:47,360
by

632
00:24:44,600 --> 00:24:51,399
searching uh anyway this is the most

633
00:24:47,360 --> 00:24:53,679
approachable explanation that I found um

634
00:24:51,399 --> 00:24:57,080
okay actually and just to quantify what

635
00:24:53,679 --> 00:24:58,760
I did Saturday right so it took about it

636
00:24:57,080 --> 00:25:01,000
took probably about six or seven hours

637
00:24:58,760 --> 00:25:03,960
to do this conversion I would pause you

638
00:25:01,000 --> 00:25:06,000
for one second here in my role as inter

639
00:25:03,960 --> 00:25:09,120
no please interrupt as much as you want

640
00:25:06,000 --> 00:25:14,000
and just say I think it might help now

641
00:25:09,120 --> 00:25:16,279
at this point to explain what you were

642
00:25:14,000 --> 00:25:17,840
doing because I think most people don't

643
00:25:16,279 --> 00:25:19,880
probably know exactly what you were

644
00:25:17,840 --> 00:25:21,399
doing and they couldn't go watch maybe

645
00:25:19,880 --> 00:25:22,720
the previous video but it wasn't all

646
00:25:21,399 --> 00:25:24,520
about that it was about other stuff as

647
00:25:22,720 --> 00:25:27,000
well so just like when you say tree

648
00:25:24,520 --> 00:25:30,039
rewrite you want give a quick example

649
00:25:27,000 --> 00:25:33,360
people know what did Quicky example so

650
00:25:30,039 --> 00:25:38,880
what we were saying before is if you

651
00:25:33,360 --> 00:25:41,039
put a + b * C plus d into this code that

652
00:25:38,880 --> 00:25:43,480
we showed already you get this thing

653
00:25:41,039 --> 00:25:44,919
which is the wrong answer right and like

654
00:25:43,480 --> 00:25:46,399
we said it sort of gets built from the

655
00:25:44,919 --> 00:25:50,279
bottom up because it's the result of a

656
00:25:46,399 --> 00:25:51,520
recursive function right um so what what

657
00:25:50,279 --> 00:25:54,080
the code would

658
00:25:51,520 --> 00:25:56,480
do after you've built C plus d that

659
00:25:54,080 --> 00:25:58,039
part's fine and and we'll actually we

660
00:25:56,480 --> 00:25:59,279
actually call this checking function

661
00:25:58,039 --> 00:26:01,279
that I'm going to mention in a minute

662
00:25:59,279 --> 00:26:04,559
about should we change the tree and it

663
00:26:01,279 --> 00:26:07,600
looks at plus CD and it's like no that's

664
00:26:04,559 --> 00:26:10,880
fine there's nothing that's vanilla plus

665
00:26:07,600 --> 00:26:14,000
right so then we get back and before let

666
00:26:10,880 --> 00:26:14,000
me just copy pasta

667
00:26:15,960 --> 00:26:24,039
this what just happened okay max power

668
00:26:20,080 --> 00:26:26,039
yeah exactly um so then you fall back

669
00:26:24,039 --> 00:26:27,880
one level in recursion and you had a

670
00:26:26,039 --> 00:26:29,240
times B and you were just waiting for

671
00:26:27,880 --> 00:26:34,320
this and now you got this right and

672
00:26:29,240 --> 00:26:36,279
you're like okay B * C plus d uh let's

673
00:26:34,320 --> 00:26:38,080
pass it to the tree rewrite code and the

674
00:26:36,279 --> 00:26:41,159
tree rewrite code would

675
00:26:38,080 --> 00:26:43,159
say hey wait I'm at a node that's a

676
00:26:41,159 --> 00:26:45,399
times and the thing on the right is a

677
00:26:43,159 --> 00:26:46,600
binary and there's no parenthesis

678
00:26:45,399 --> 00:26:49,240
because when you parenthesize something

679
00:26:46,600 --> 00:26:52,039
I would put a flag on the node right and

680
00:26:49,240 --> 00:26:55,159
it would say there's no parenthesis um

681
00:26:52,039 --> 00:26:55,919
so I'm G to do a rewrite operation where

682
00:26:55,159 --> 00:26:59,520
I

683
00:26:55,919 --> 00:27:02,240
grab I grab um you sort of like Swizzle

684
00:26:59,520 --> 00:27:05,960
the tree around right like let me you

685
00:27:02,240 --> 00:27:09,200
basically want to turn this into um we

686
00:27:05,960 --> 00:27:11,960
can just again right the right answer is

687
00:27:09,200 --> 00:27:14,080
so this is

688
00:27:11,960 --> 00:27:17,919
uh uh I'm going to put the outer

689
00:27:14,080 --> 00:27:22,120
parentheses this is B * C plus d right

690
00:27:17,919 --> 00:27:26,320
and you want to turn that into uh B time

691
00:27:22,120 --> 00:27:28,240
C plus d right and so this is a right

692
00:27:26,320 --> 00:27:29,600
Leaning Tree but again what I said about

693
00:27:28,240 --> 00:27:31,120
the parentheses is you have to be able

694
00:27:29,600 --> 00:27:33,960
to Circle it right so this is like a

695
00:27:31,120 --> 00:27:36,760
left Leaning Tree actually um and

696
00:27:33,960 --> 00:27:39,840
actually that fact will come up later so

697
00:27:36,760 --> 00:27:42,360
what it does is it rewrites into um the

698
00:27:39,840 --> 00:27:42,360
following

699
00:27:45,519 --> 00:27:49,799
thing sorry I should have deleted that

700
00:27:47,840 --> 00:27:52,600
first it probably looked confusing for a

701
00:27:49,799 --> 00:27:55,320
minute right and how do you do this um

702
00:27:52,600 --> 00:27:58,000
you can do this just by you keep the

703
00:27:55,320 --> 00:27:59,240
binary node with the left here I mean

704
00:27:58,000 --> 00:28:02,240
because it was the right that we

705
00:27:59,240 --> 00:28:05,640
detected you know um you keep the node

706
00:28:02,240 --> 00:28:07,440
with the left here and then you steal

707
00:28:05,640 --> 00:28:09,480
the thing on the left of here and then

708
00:28:07,440 --> 00:28:12,000
you move this one up and you child it

709
00:28:09,480 --> 00:28:13,600
and it's a very you know y i i don't

710
00:28:12,000 --> 00:28:16,720
want to try to draw those intermediate

711
00:28:13,600 --> 00:28:18,399
operations in right but you just

712
00:28:16,720 --> 00:28:19,799
basically you are you don't have to make

713
00:28:18,399 --> 00:28:21,519
anything new because you have all the

714
00:28:19,799 --> 00:28:22,960
right pointers in the right places you

715
00:28:21,519 --> 00:28:25,080
just have to change who's pointing to

716
00:28:22,960 --> 00:28:29,320
what right yep and that's what I did and

717
00:28:25,080 --> 00:28:31,279
so to quantify this um the parser

718
00:28:29,320 --> 00:28:32,840
without ignoring the tree change

719
00:28:31,279 --> 00:28:36,120
operation for a minute the parser was

720
00:28:32,840 --> 00:28:37,840
around 6,000 lines last week um 6300 or

721
00:28:36,120 --> 00:28:40,279
something which some people would say oh

722
00:28:37,840 --> 00:28:42,279
my God that's really big but like it's a

723
00:28:40,279 --> 00:28:43,919
C++ competitor programming language with

724
00:28:42,279 --> 00:28:46,240
like a lot of nodes there's like a lot

725
00:28:43,919 --> 00:28:49,120
of syntax and so that's just what that

726
00:28:46,240 --> 00:28:52,399
means um the lexical analyzer was around

727
00:28:49,120 --> 00:28:55,159
2,000 lines um the tree rewriting code

728
00:28:52,399 --> 00:28:57,559
was 350 lines so it's like not even

729
00:28:55,159 --> 00:28:59,080
really that much code um but the the

730
00:28:57,559 --> 00:29:01,519
thing that there's two things about

731
00:28:59,080 --> 00:29:03,519
doing things this way right I'm going to

732
00:29:01,519 --> 00:29:06,640
interrupt you one more time I apologize

733
00:29:03,519 --> 00:29:08,360
yes uh just to finish up that part you

734
00:29:06,640 --> 00:29:10,679
said you put a flag on things when

735
00:29:08,360 --> 00:29:12,840
there's parentheses so I assume that

736
00:29:10,679 --> 00:29:16,039
means something like well when you parse

737
00:29:12,840 --> 00:29:18,200
a parent a open pen yeah you then call

738
00:29:16,039 --> 00:29:20,480
like parse expression recursively or

739
00:29:18,200 --> 00:29:22,720
something and when it finds the closed

740
00:29:20,480 --> 00:29:24,640
pen then you take whatever you got back

741
00:29:22,720 --> 00:29:26,840
from that and set the parenthetical fra

742
00:29:24,640 --> 00:29:28,440
flag which then prevents any of these

743
00:29:26,840 --> 00:29:30,440
things from yeah yeah it's actually a

744
00:29:28,440 --> 00:29:31,799
little simpler than that um it's

745
00:29:30,440 --> 00:29:33,159
basically what you said with one small

746
00:29:31,799 --> 00:29:36,000
change that might be important for

747
00:29:33,159 --> 00:29:38,000
people to understand um yeah when you

748
00:29:36,000 --> 00:29:41,159
see an open pen you call parse

749
00:29:38,000 --> 00:29:43,159
expression right um but parse expression

750
00:29:41,159 --> 00:29:45,279
doesn't do the closed pen you do because

751
00:29:43,159 --> 00:29:47,559
it'll stop whenever it sees something

752
00:29:45,279 --> 00:29:49,799
that doesn't start an expression anymore

753
00:29:47,559 --> 00:29:51,440
right which a Clos PR does so parse

754
00:29:49,799 --> 00:29:54,519
expression doesn't know what the Clos PR

755
00:29:51,440 --> 00:29:56,760
means but you know that you expect that

756
00:29:54,519 --> 00:29:59,240
after parsing a full expression and if

757
00:29:56,760 --> 00:30:01,200
you don't you can say a syntax error and

758
00:29:59,240 --> 00:30:02,679
it's actually so one of the things about

759
00:30:01,200 --> 00:30:05,480
these so-called recursive descent

760
00:30:02,679 --> 00:30:07,360
parsers that's a really strong suit is

761
00:30:05,480 --> 00:30:11,880
there much much better for error

762
00:30:07,360 --> 00:30:14,360
reporting than uh you know all these

763
00:30:11,880 --> 00:30:16,080
other systems of generating parsers and

764
00:30:14,360 --> 00:30:17,840
here's the thing is error reporting is

765
00:30:16,080 --> 00:30:20,799
the user interface of your programming

766
00:30:17,840 --> 00:30:22,880
language like it's critically important

767
00:30:20,799 --> 00:30:25,640
right

768
00:30:22,880 --> 00:30:27,720
um yeah so so you don't you don't want

769
00:30:25,640 --> 00:30:29,600
to phone it in you want to be good error

770
00:30:27,720 --> 00:30:31,880
messages anyway so that's what I was

771
00:30:29,600 --> 00:30:33,600
doing is I was rewriting this to this

772
00:30:31,880 --> 00:30:35,799
now of course because this is the right

773
00:30:33,600 --> 00:30:37,919
answer the goal is like how do you

774
00:30:35,799 --> 00:30:39,960
create this as opposed to having to

775
00:30:37,919 --> 00:30:41,320
rewrite it as a way to to say what we're

776
00:30:39,960 --> 00:30:44,000
gonna do no you said you wanted to say

777
00:30:41,320 --> 00:30:48,000
two things uh when I interrupted you and

778
00:30:44,000 --> 00:30:52,440
I apologize uh oh uh well so there were

779
00:30:48,000 --> 00:30:54,679
like I said I I just like excuse me for

780
00:30:52,440 --> 00:30:54,679
some

781
00:30:56,240 --> 00:31:01,960
reason the uh the Dragon book Illuminati

782
00:30:59,679 --> 00:31:06,000
are trying to prevent me from speaking

783
00:31:01,960 --> 00:31:07,799
oh yes with the voodoo doll

784
00:31:06,000 --> 00:31:10,480
um

785
00:31:07,799 --> 00:31:13,639
so the reason I did this was I just like

786
00:31:10,480 --> 00:31:15,360
the idea of cleaning up the parser right

787
00:31:13,639 --> 00:31:16,760
and finally understanding this thing

788
00:31:15,360 --> 00:31:20,279
that I had kind of swept under the rug

789
00:31:16,760 --> 00:31:22,600
and ignoring and ignored

790
00:31:20,279 --> 00:31:25,880
um there's something good about this

791
00:31:22,600 --> 00:31:29,000
tree rewriting aspect which is it often

792
00:31:25,880 --> 00:31:31,320
makes code easier to right

793
00:31:29,000 --> 00:31:35,240
because you can just write code that

794
00:31:31,320 --> 00:31:37,639
parses some complicated construct and

795
00:31:35,240 --> 00:31:39,799
you know if it I want to call that from

796
00:31:37,639 --> 00:31:42,320
here oh but in some case when there's an

797
00:31:39,799 --> 00:31:43,399
operator to the left maybe that operator

798
00:31:42,320 --> 00:31:44,840
has to know about this thing and

799
00:31:43,399 --> 00:31:46,919
whatever and it's like n just we'll fix

800
00:31:44,840 --> 00:31:48,960
it in post right it's like fine yeah

801
00:31:46,919 --> 00:31:50,399
yeah yeah and so an example of I mean

802
00:31:48,960 --> 00:31:52,360
this is a very simple example but

803
00:31:50,399 --> 00:31:54,639
there's in in programming languages

804
00:31:52,360 --> 00:31:55,960
there are a lot of like you know binary

805
00:31:54,639 --> 00:31:57,679
operators are very simple there are a

806
00:31:55,960 --> 00:32:01,000
lot of more complex concept construct so

807
00:31:57,679 --> 00:32:04,120
like you see if you see the keyword for

808
00:32:01,000 --> 00:32:06,200
which comes in in one token right it's

809
00:32:04,120 --> 00:32:09,039
very unambiguous what has to happen

810
00:32:06,200 --> 00:32:10,279
after that um in C++ it's a little more

811
00:32:09,039 --> 00:32:12,519
ambiguous because they have ways of

812
00:32:10,279 --> 00:32:14,120
overloading it but in C it's like

813
00:32:12,519 --> 00:32:16,519
actually I don't even know later latest

814
00:32:14,120 --> 00:32:19,000
C probably has some weird stuff but in

815
00:32:16,519 --> 00:32:20,880
classic C you see the word for and it's

816
00:32:19,000 --> 00:32:22,880
like okay there's going to be an open

817
00:32:20,880 --> 00:32:24,880
parentheses there's going to be three

818
00:32:22,880 --> 00:32:25,919
statements with semicolons in between

819
00:32:24,880 --> 00:32:28,360
and there's going to be a closed

820
00:32:25,919 --> 00:32:30,399
parentheses as then a block which might

821
00:32:28,360 --> 00:32:31,799
be a statement or it might you know you

822
00:32:30,399 --> 00:32:33,039
just call your parse block function

823
00:32:31,799 --> 00:32:35,200
which knows to look for either a

824
00:32:33,039 --> 00:32:37,080
statement or some braces and stuff right

825
00:32:35,200 --> 00:32:38,760
and that's you can write that in one

826
00:32:37,080 --> 00:32:40,200
function and it's very clear like this

827
00:32:38,760 --> 00:32:42,279
and then this and then this and that and

828
00:32:40,200 --> 00:32:45,440
that and that and

829
00:32:42,279 --> 00:32:45,440
um you

830
00:32:45,679 --> 00:32:50,240
know sometimes when grammars get

831
00:32:47,960 --> 00:32:52,000
complicated it's like oh well I want to

832
00:32:50,240 --> 00:32:54,360
parse this thing in the middle of my

833
00:32:52,000 --> 00:32:56,720
complicated construct but maybe it needs

834
00:32:54,360 --> 00:32:58,240
to associate differently or whatever

835
00:32:56,720 --> 00:33:00,880
yeah I don't want to go too much into

836
00:32:58,240 --> 00:33:02,720
that because if you ever if you ever

837
00:33:00,880 --> 00:33:04,159
decide to do a parser that way you will

838
00:33:02,720 --> 00:33:05,840
discover this so there's a convenient

839
00:33:04,159 --> 00:33:08,399
thing about it is it lets you paste over

840
00:33:05,840 --> 00:33:10,320
things another way to say that is like

841
00:33:08,399 --> 00:33:12,039
when you decide to parse things in the

842
00:33:10,320 --> 00:33:13,519
middle of like just a hard-coded

843
00:33:12,039 --> 00:33:16,760
function like

844
00:33:13,519 --> 00:33:18,279
that like the the way the specific sub

845
00:33:16,760 --> 00:33:20,880
functions that you call determine

846
00:33:18,279 --> 00:33:23,120
precedence in a way right and if you

847
00:33:20,880 --> 00:33:24,760
don't want to have some system for

848
00:33:23,120 --> 00:33:26,679
negotiating precedence you could just

849
00:33:24,760 --> 00:33:28,159
fix it later and it just it makes it

850
00:33:26,679 --> 00:33:30,159
easy but it's one of those things where

851
00:33:28,159 --> 00:33:31,760
it makes it easy in the beginning but

852
00:33:30,159 --> 00:33:33,919
then like later after you've done it a

853
00:33:31,760 --> 00:33:35,240
bunch there's like a lot of code and

854
00:33:33,919 --> 00:33:38,399
it's not it's not a ton of code like I

855
00:33:35,240 --> 00:33:40,080
said it was 350 lines but it's like oh

856
00:33:38,399 --> 00:33:42,639
man I really have to

857
00:33:40,080 --> 00:33:46,840
like if I have a bug I'm like not sure

858
00:33:42,639 --> 00:33:49,080
if it's over here over there and

859
00:33:46,840 --> 00:33:50,840
like it was more complex than I would

860
00:33:49,080 --> 00:33:53,200
like right especially you can't you

861
00:33:50,840 --> 00:33:54,880
can't step through the recursive descent

862
00:33:53,200 --> 00:33:57,120
parser anymore and know if it's

863
00:33:54,880 --> 00:33:58,840
operating correctly because it could be

864
00:33:57,120 --> 00:34:00,200
be that it's operating incorrectly or it

865
00:33:58,840 --> 00:34:01,760
could be that it's operating correctly

866
00:34:00,200 --> 00:34:04,559
and the tree rewriter is operating

867
00:34:01,760 --> 00:34:07,159
incorrectly so now you have to debug

868
00:34:04,559 --> 00:34:08,639
both at the same time effectively which

869
00:34:07,159 --> 00:34:10,560
just makes your job a little bit harder

870
00:34:08,639 --> 00:34:11,839
not fantastic a little bit harder little

871
00:34:10,560 --> 00:34:13,679
it's actually not that bad because they

872
00:34:11,839 --> 00:34:15,280
are interleaved like the tree rewriting

873
00:34:13,679 --> 00:34:16,560
doesn't operate at the root of the tree

874
00:34:15,280 --> 00:34:17,919
it's like every time we're going to pass

875
00:34:16,560 --> 00:34:19,599
you something back we call the thing

876
00:34:17,919 --> 00:34:21,079
right but right if it was fully deferred

877
00:34:19,599 --> 00:34:22,760
then it would be a real nightmare I I

878
00:34:21,079 --> 00:34:24,119
would more classify it as just like it's

879
00:34:22,760 --> 00:34:25,320
harder to think about and that's one of

880
00:34:24,119 --> 00:34:27,599
the reasons why I want to talk about

881
00:34:25,320 --> 00:34:30,040
this today again the goal of this is

882
00:34:27,599 --> 00:34:33,480
expressing how absolutely simple this

883
00:34:30,040 --> 00:34:35,480
solution is and we're in this world

884
00:34:33,480 --> 00:34:38,079
where we're like complexity bound right

885
00:34:35,480 --> 00:34:39,760
like we're just software is limited by

886
00:34:38,079 --> 00:34:40,839
how hard things are to understand and

887
00:34:39,760 --> 00:34:42,560
that's why I think this is such a

888
00:34:40,839 --> 00:34:45,159
critical issue like anytime you can

889
00:34:42,560 --> 00:34:47,440
identify something like this like we

890
00:34:45,159 --> 00:34:50,000
need to Nuke all the over complicated

891
00:34:47,440 --> 00:34:51,960
stuff from orbit it is the only way to

892
00:34:50,000 --> 00:34:52,720
be sure that like software will be good

893
00:34:51,960 --> 00:34:57,720
in the

894
00:34:52,720 --> 00:35:00,359
future um so yeah anyway

895
00:34:57,720 --> 00:35:03,680
um okay here's where we bust out the

896
00:35:00,359 --> 00:35:06,800
spicy meme right oh so I made a spicy

897
00:35:03,680 --> 00:35:09,400
meme just for this talk what what so

898
00:35:06,800 --> 00:35:13,480
what I said was this thing that we made

899
00:35:09,400 --> 00:35:15,359
is wrong okay because oh not in this

900
00:35:13,480 --> 00:35:17,119
case not in the plus case actually

901
00:35:15,359 --> 00:35:19,359
here's a another thing we'll say for

902
00:35:17,119 --> 00:35:21,119
later is like if you're just plus a

903
00:35:19,359 --> 00:35:23,680
bunch of integers you actually kind of

904
00:35:21,119 --> 00:35:25,839
don't care about precedence here right

905
00:35:23,680 --> 00:35:27,560
right if you're doing pedantic floating

906
00:35:25,839 --> 00:35:29,560
point maybe you

907
00:35:27,560 --> 00:35:31,240
I don't know but you know so there's

908
00:35:29,560 --> 00:35:34,640
some things where you don't totally care

909
00:35:31,240 --> 00:35:37,200
and we'll come up to that later again

910
00:35:34,640 --> 00:35:39,920
um anyway the point was if you do a plus

911
00:35:37,200 --> 00:35:42,920
b time C plus d you get this structure

912
00:35:39,920 --> 00:35:44,359
and it's wrong okay but here's here's

913
00:35:42,920 --> 00:35:48,880
the spicy

914
00:35:44,359 --> 00:35:51,400
meme um I'm so ready for this yes uh the

915
00:35:48,880 --> 00:35:55,160
spicy meme is that it's actually right

916
00:35:51,400 --> 00:35:57,640
sometimes right um there are some cases

917
00:35:55,160 --> 00:36:00,319
for which okay is that I mean

918
00:35:57,640 --> 00:36:02,240
is that's going to Twitter I hope uh

919
00:36:00,319 --> 00:36:04,480
sure yeah nobody will know what it's

920
00:36:02,240 --> 00:36:08,440
about but

921
00:36:04,480 --> 00:36:13,200
um uh I mean that has to go up right

922
00:36:08,440 --> 00:36:15,599
now um so so it's actually right

923
00:36:13,200 --> 00:36:18,720
sometimes and this is the key insight to

924
00:36:15,599 --> 00:36:20,800
these papers and stuff which is here

925
00:36:18,720 --> 00:36:22,760
let's say you have an expression such as

926
00:36:20,800 --> 00:36:23,920
a is greater than like there's an if

927
00:36:22,760 --> 00:36:25,079
statement around this right you're going

928
00:36:23,920 --> 00:36:29,359
to

929
00:36:25,079 --> 00:36:31,480
say just to if if this do something

930
00:36:29,359 --> 00:36:34,280
right that's a real thing that happens

931
00:36:31,480 --> 00:36:36,920
MH if it happens to be arranged in this

932
00:36:34,280 --> 00:36:39,920
way the Precedence of greater than now

933
00:36:36,920 --> 00:36:41,960
if you're just thinking about math

934
00:36:39,920 --> 00:36:43,920
operators it might be weird to think

935
00:36:41,960 --> 00:36:45,359
about greater than is like the same

936
00:36:43,920 --> 00:36:46,680
thing as plus but in terms of a

937
00:36:45,359 --> 00:36:49,079
programming language it basically is

938
00:36:46,680 --> 00:36:51,960
it's an operator that takes two sides it

939
00:36:49,079 --> 00:36:55,680
returns a value that's a Boolean right

940
00:36:51,960 --> 00:36:57,680
and so um but the Precedence in C like

941
00:36:55,680 --> 00:37:00,640
languages for example of greater than is

942
00:36:57,680 --> 00:37:04,040
very low it's lowerer than plus and plus

943
00:37:00,640 --> 00:37:08,760
is lower than times okay and if you

944
00:37:04,040 --> 00:37:10,560
parenthesize this you get this right and

945
00:37:08,760 --> 00:37:12,200
the tree version of this of course is

946
00:37:10,560 --> 00:37:15,040
this which is exactly what that code

947
00:37:12,200 --> 00:37:18,880
outputed right right so

948
00:37:15,040 --> 00:37:21,240
like this is this is right sometimes and

949
00:37:18,880 --> 00:37:23,400
so maybe you can use that right that's

950
00:37:21,240 --> 00:37:25,160
well the the dumb guy on the bell curve

951
00:37:23,400 --> 00:37:27,760
is like well I guess that's what we can

952
00:37:25,160 --> 00:37:29,920
do right and then the smart guy is like

953
00:37:27,760 --> 00:37:31,960
no like this means something it's like

954
00:37:29,920 --> 00:37:35,240
the the mashed potatoes right the mashed

955
00:37:31,960 --> 00:37:37,079
pot this means something yes okay well

956
00:37:35,240 --> 00:37:38,760
okay if if this is the right thing for

957
00:37:37,079 --> 00:37:40,240
this what if the Precedence goes the

958
00:37:38,760 --> 00:37:42,560
opposite way obviously you could write

959
00:37:40,240 --> 00:37:46,000
this thing right and it's parenthesize

960
00:37:42,560 --> 00:37:47,480
that way and that's a left Leaning Tree

961
00:37:46,000 --> 00:37:48,720
um you know we we just spoke a little

962
00:37:47,480 --> 00:37:50,280
bit ago that you could turn the right

963
00:37:48,720 --> 00:37:51,920
Leaning Tree into a left Leaning Tree by

964
00:37:50,280 --> 00:37:53,960
rewrites but if you wanted to just

965
00:37:51,920 --> 00:37:56,400
generate it how would you do that and

966
00:37:53,960 --> 00:38:00,079
the answer is basically what Casey was

967
00:37:56,400 --> 00:38:04,839
asking asking about before

968
00:38:00,079 --> 00:38:08,839
um uh I'm trying to remember what I did

969
00:38:04,839 --> 00:38:11,319
here um okay so here we have a version

970
00:38:08,839 --> 00:38:14,560
of parsing a binary tree where you pass

971
00:38:11,319 --> 00:38:17,079
in the left side as a parameter and then

972
00:38:14,560 --> 00:38:19,640
you just keep calling this to get the

973
00:38:17,079 --> 00:38:21,560
times B plus C less than D whatever

974
00:38:19,640 --> 00:38:23,240
right so you pass in the left you say

975
00:38:21,560 --> 00:38:25,319
get the next token if it's a binary

976
00:38:23,240 --> 00:38:27,160
operator make a binary node otherwise

977
00:38:25,319 --> 00:38:28,560
just return the left side and this

978
00:38:27,160 --> 00:38:31,119
doesn't have to be a function this could

979
00:38:28,560 --> 00:38:33,319
be inside a loop but for clarity I just

980
00:38:31,119 --> 00:38:35,480
broke it into a piece right and just to

981
00:38:33,319 --> 00:38:38,960
be clear I I I can just restate that

982
00:38:35,480 --> 00:38:40,599
again make sure everyone gets it so

983
00:38:38,960 --> 00:38:42,240
basically what John is saying here is

984
00:38:40,599 --> 00:38:44,599
when we write the recursive descent

985
00:38:42,240 --> 00:38:46,400
parser the first time it was an

986
00:38:44,599 --> 00:38:48,040
arbitrary choice for us to decide to

987
00:38:46,400 --> 00:38:51,000
build a right Leaning Tree meaning we

988
00:38:48,040 --> 00:38:54,200
always were putting the next token

989
00:38:51,000 --> 00:38:56,160
underneath our own binary operator but

990
00:38:54,200 --> 00:38:58,400
we are not forced to do that we could

991
00:38:56,160 --> 00:39:01,760
have just done it the other way where we

992
00:38:58,400 --> 00:39:04,040
always put the thing on the left uh side

993
00:39:01,760 --> 00:39:07,000
of the tree and by to do that we have to

994
00:39:04,040 --> 00:39:10,119
pass down uh that to the to the

995
00:39:07,000 --> 00:39:11,720
recursive call yeah and so I think you

996
00:39:10,119 --> 00:39:14,319
know it it's sort

997
00:39:11,720 --> 00:39:17,000
of which way you find easier to think

998
00:39:14,319 --> 00:39:18,920
about um depends on just how you tend to

999
00:39:17,000 --> 00:39:20,560
think about and solve problems you know

1000
00:39:18,920 --> 00:39:21,920
if you went to recursive school like I

1001
00:39:20,560 --> 00:39:25,000
did you probably build the right Leaning

1002
00:39:21,920 --> 00:39:26,520
Tree by default but iterative algorithms

1003
00:39:25,000 --> 00:39:28,440
tend to be more efficient than recursive

1004
00:39:26,520 --> 00:39:32,359
algorithms right I don't care what all

1005
00:39:28,440 --> 00:39:34,760
the tail recursion stands say um

1006
00:39:32,359 --> 00:39:36,240
yes so you know if you're trying to

1007
00:39:34,760 --> 00:39:39,880
build performance software you want to

1008
00:39:36,240 --> 00:39:42,359
think about loops and that kind of thing

1009
00:39:39,880 --> 00:39:44,520
right um because you know Loops can be

1010
00:39:42,359 --> 00:39:47,440
expanded into like Loops operating on a

1011
00:39:44,520 --> 00:39:49,000
wide number of things and whatever um

1012
00:39:47,440 --> 00:39:51,240
okay

1013
00:39:49,000 --> 00:39:55,000
so so if you have this thing that takes

1014
00:39:51,240 --> 00:39:56,640
a left hand side then you can just every

1015
00:39:55,000 --> 00:39:58,640
time you make a new sub tree you just

1016
00:39:56,640 --> 00:40:01,240
can just pass that in as the left hand

1017
00:39:58,640 --> 00:40:03,079
side and build more tree right which is

1018
00:40:01,240 --> 00:40:05,079
what this thing is doing this thing

1019
00:40:03,079 --> 00:40:07,240
another way instead of par single binary

1020
00:40:05,079 --> 00:40:10,119
you could call this like add the right

1021
00:40:07,240 --> 00:40:12,560
hand side onto a tree or whatever right

1022
00:40:10,119 --> 00:40:14,240
right and so this part this version of

1023
00:40:12,560 --> 00:40:15,599
parse expression starts by parsing a

1024
00:40:14,240 --> 00:40:17,280
leaf and this is the thing that's weird

1025
00:40:15,599 --> 00:40:18,480
for me to think about because in the

1026
00:40:17,280 --> 00:40:21,520
recursive

1027
00:40:18,480 --> 00:40:22,720
version the recursive function itself is

1028
00:40:21,520 --> 00:40:27,040
like I'm going to

1029
00:40:22,720 --> 00:40:28,680
parse um a left and then plus and then

1030
00:40:27,040 --> 00:40:31,280
the Right comes later and in this

1031
00:40:28,680 --> 00:40:34,000
version you give the left and the left

1032
00:40:31,280 --> 00:40:36,000
comes already and that was weird for me

1033
00:40:34,000 --> 00:40:37,720
to think about but the recursive version

1034
00:40:36,000 --> 00:40:40,880
is hard to think about too because you

1035
00:40:37,720 --> 00:40:42,599
have to be like oh this comes way later

1036
00:40:40,880 --> 00:40:45,160
after things happen so I don't know

1037
00:40:42,599 --> 00:40:46,960
right but anyway so here's here's how

1038
00:40:45,160 --> 00:40:49,079
this works is you you get the first Leaf

1039
00:40:46,960 --> 00:40:52,560
which in this case is a then you do this

1040
00:40:49,079 --> 00:40:55,319
Loop where you parse binary that'll eat

1041
00:40:52,560 --> 00:40:58,119
a plus b right and

1042
00:40:55,319 --> 00:40:59,720
then if it Returns the same thing we

1043
00:40:58,119 --> 00:41:01,440
gave it this might be a stupid way to do

1044
00:40:59,720 --> 00:41:03,680
the stopping condition but it's just the

1045
00:41:01,440 --> 00:41:05,480
way I did it right if because if this

1046
00:41:03,680 --> 00:41:07,640
doesn't see an operator it just returns

1047
00:41:05,480 --> 00:41:09,880
back the parameter right so like if we

1048
00:41:07,640 --> 00:41:11,520
just got that then just return that's

1049
00:41:09,880 --> 00:41:14,640
the answer we ran out of input or

1050
00:41:11,520 --> 00:41:16,680
whatever right otherwise just say the

1051
00:41:14,640 --> 00:41:18,520
left is the new binary node and then

1052
00:41:16,680 --> 00:41:21,160
just keep looping right and I believe

1053
00:41:18,520 --> 00:41:23,480
that's what you were suggesting before

1054
00:41:21,160 --> 00:41:25,160
yes I was I was kind of asking like yeah

1055
00:41:23,480 --> 00:41:27,119
or or I wasn't even suggesting you would

1056
00:41:25,160 --> 00:41:28,839
even necessarily use

1057
00:41:27,119 --> 00:41:31,440
uh recursion I was just saying like I

1058
00:41:28,839 --> 00:41:33,359
just grab a token I put it down I grab

1059
00:41:31,440 --> 00:41:35,160
another one I go okay it's a plus I link

1060
00:41:33,359 --> 00:41:36,880
it to left side I grab the next one it's

1061
00:41:35,160 --> 00:41:38,400
you know yeah that's exactly what this

1062
00:41:36,880 --> 00:41:41,240
is like if you don't make this a

1063
00:41:38,400 --> 00:41:43,040
separate function right yep if you just

1064
00:41:41,240 --> 00:41:45,040
like if you just like put it I'm not

1065
00:41:43,040 --> 00:41:46,960
even going to indent but yeah you know

1066
00:41:45,040 --> 00:41:48,319
yep yeah exactly so it's exactly that's

1067
00:41:46,960 --> 00:41:49,680
exactly what I was asking and so I guess

1068
00:41:48,319 --> 00:41:51,359
you're saying well we could totally do

1069
00:41:49,680 --> 00:41:54,960
that you could and that just gives you

1070
00:41:51,359 --> 00:41:58,640
this tree this way right yep which is a

1071
00:41:54,960 --> 00:42:00,599
first and then then a plus b comes next

1072
00:41:58,640 --> 00:42:03,480
and then we just keep attaching you know

1073
00:42:00,599 --> 00:42:05,800
little fronds that reach up as we keep

1074
00:42:03,480 --> 00:42:06,880
going right and of course again this is

1075
00:42:05,800 --> 00:42:10,560
right

1076
00:42:06,880 --> 00:42:11,640
sometimes this is right when precedence

1077
00:42:10,560 --> 00:42:15,480
is going

1078
00:42:11,640 --> 00:42:17,280
down okay and the key Insight is that

1079
00:42:15,480 --> 00:42:18,720
that's all you need to solve any problem

1080
00:42:17,280 --> 00:42:20,520
is you know what's right when precedence

1081
00:42:18,720 --> 00:42:22,440
is going up you know what's right when

1082
00:42:20,520 --> 00:42:24,520
precedence is going down now I don't

1083
00:42:22,440 --> 00:42:26,680
think these papers ever express this

1084
00:42:24,520 --> 00:42:29,400
this way but that's

1085
00:42:26,680 --> 00:42:31,319
maybe my contribution is just to like

1086
00:42:29,400 --> 00:42:34,559
think about it in a slightly wacky way

1087
00:42:31,319 --> 00:42:36,920
like this all right yep um okay so these

1088
00:42:34,559 --> 00:42:38,680
two things are all you need right so if

1089
00:42:36,920 --> 00:42:40,359
you do the recursive thing that's right

1090
00:42:38,680 --> 00:42:42,920
when precedence is increasing the loop

1091
00:42:40,359 --> 00:42:45,599
is right when precedence is decreasing

1092
00:42:42,920 --> 00:42:47,040
but you don't really you know it's not

1093
00:42:45,599 --> 00:42:48,760
that hard to put them together you might

1094
00:42:47,040 --> 00:42:50,800
think about like some highle thing that

1095
00:42:48,760 --> 00:42:53,880
shifts back and forth but no it's

1096
00:42:50,800 --> 00:42:56,640
actually very fluid so here is um code

1097
00:42:53,880 --> 00:43:00,000
that combines both of these things um

1098
00:42:56,640 --> 00:43:01,319
this is a recursive thing and again I

1099
00:43:00,000 --> 00:43:04,440
keep saying recursive but you could turn

1100
00:43:01,319 --> 00:43:07,599
it into a loop recursion just is a way

1101
00:43:04,440 --> 00:43:10,240
of using the programming languages stack

1102
00:43:07,599 --> 00:43:11,480
as a stack data structure right and so

1103
00:43:10,240 --> 00:43:14,079
if you want to make your own Loop

1104
00:43:11,480 --> 00:43:16,839
version of that you just make a stack of

1105
00:43:14,079 --> 00:43:18,160
your own um but I just for for

1106
00:43:16,839 --> 00:43:20,359
Simplicity and brevity I made it

1107
00:43:18,160 --> 00:43:23,240
recursive right

1108
00:43:20,359 --> 00:43:25,760
so um

1109
00:43:23,240 --> 00:43:27,599
here as long as we keep seeing operators

1110
00:43:25,760 --> 00:43:30,160
of increasing precedence we do the right

1111
00:43:27,599 --> 00:43:32,680
Leaning Tree and what that is is just as

1112
00:43:30,160 --> 00:43:34,040
a parameter now we're passing in the

1113
00:43:32,680 --> 00:43:36,079
left hand side which we did in the

1114
00:43:34,040 --> 00:43:38,319
previous version and that's that's part

1115
00:43:36,079 --> 00:43:40,400
of putting these together right and then

1116
00:43:38,319 --> 00:43:42,280
we passed down the Precedence which is

1117
00:43:40,400 --> 00:43:44,200
just how do how do you know it's

1118
00:43:42,280 --> 00:43:45,920
increasing well every time you get an

1119
00:43:44,200 --> 00:43:49,520
operator you look at the Precedence

1120
00:43:45,920 --> 00:43:51,920
right and the first call to this passes

1121
00:43:49,520 --> 00:43:54,200
like negative infinity or whatever

1122
00:43:51,920 --> 00:43:55,760
whatever your range of Precedence is

1123
00:43:54,200 --> 00:43:57,880
every time you get an operator you say

1124
00:43:55,760 --> 00:44:01,079
What's the the next precedence if it's

1125
00:43:57,880 --> 00:44:03,559
lower or equal um to what we have then

1126
00:44:01,079 --> 00:44:05,960
just pretend like we ran out of input

1127
00:44:03,559 --> 00:44:08,000
basically just return return that thing

1128
00:44:05,960 --> 00:44:10,040
right otherwise just do the thing we did

1129
00:44:08,000 --> 00:44:12,319
in the recursive version before where we

1130
00:44:10,040 --> 00:44:14,599
make the right Leaning Tree by parsing

1131
00:44:12,319 --> 00:44:17,280
another expression and keep going right

1132
00:44:14,599 --> 00:44:20,760
so as long as precedence goes up we make

1133
00:44:17,280 --> 00:44:23,760
a right leaning subtree right

1134
00:44:20,760 --> 00:44:27,599
now back here we have an outer loop like

1135
00:44:23,760 --> 00:44:30,000
the version that we just saw and

1136
00:44:27,599 --> 00:44:32,079
instead of in this version back here we

1137
00:44:30,000 --> 00:44:34,520
were parsing one binary node and that

1138
00:44:32,079 --> 00:44:37,160
gave us this instead of just parsing one

1139
00:44:34,520 --> 00:44:39,440
binary node we just say parse as many as

1140
00:44:37,160 --> 00:44:42,920
you want as long as it keeps going up

1141
00:44:39,440 --> 00:44:44,839
right and then come back around and

1142
00:44:42,920 --> 00:44:48,119
that's our new leftand

1143
00:44:44,839 --> 00:44:52,119
side and then just pass that in

1144
00:44:48,119 --> 00:44:56,280
again um and that's it this

1145
00:44:52,119 --> 00:44:58,240
is the entire code that handles oper at

1146
00:44:56,280 --> 00:45:00,640
precedence right and so you alluded to

1147
00:44:58,240 --> 00:45:03,520
like seeing small amounts of code before

1148
00:45:00,640 --> 00:45:07,319
that's what they look like yeah this is

1149
00:45:03,520 --> 00:45:10,400
like the first half of the Dragon book

1150
00:45:07,319 --> 00:45:13,520
yeah yeah like that's an exaggeration

1151
00:45:10,400 --> 00:45:17,000
but not really because

1152
00:45:13,520 --> 00:45:18,680
yeah like this is the only real problem

1153
00:45:17,000 --> 00:45:21,200
that you have when making a programming

1154
00:45:18,680 --> 00:45:22,800
language is to decide well when when

1155
00:45:21,200 --> 00:45:25,040
parsing a programming language yeah no

1156
00:45:22,800 --> 00:45:26,480
there's plenty of problems later but

1157
00:45:25,040 --> 00:45:28,559
when parsing stuff you just need to

1158
00:45:26,480 --> 00:45:30,240
decide you know what is what does the

1159
00:45:28,559 --> 00:45:32,720
input text actually mean there have to

1160
00:45:30,240 --> 00:45:34,480
be rules that determine what it means

1161
00:45:32,720 --> 00:45:35,720
and those rules need to be clear right

1162
00:45:34,480 --> 00:45:38,400
and there needs to be an implementation

1163
00:45:35,720 --> 00:45:40,440
of them and this this does that and so

1164
00:45:38,400 --> 00:45:42,359
we you know we did do a little bit of a

1165
00:45:40,440 --> 00:45:44,520
leap between this one and this one

1166
00:45:42,359 --> 00:45:46,240
because it's like we keep passing this

1167
00:45:44,520 --> 00:45:49,000
left tree through the loop and like what

1168
00:45:46,240 --> 00:45:50,960
does that mean right and by the way this

1169
00:45:49,000 --> 00:45:51,920
might at this point be substantially

1170
00:45:50,960 --> 00:45:53,319
different from what's in those

1171
00:45:51,920 --> 00:45:56,280
references because again I didn't really

1172
00:45:53,319 --> 00:45:57,839
read them I just figured it out but I

1173
00:45:56,280 --> 00:45:59,440
kind of feel like it has to be the same

1174
00:45:57,839 --> 00:46:01,800
thing

1175
00:45:59,440 --> 00:46:03,520
because it's roughly the what El you do

1176
00:46:01,800 --> 00:46:05,800
I remember there's a bunch of different

1177
00:46:03,520 --> 00:46:08,040
ways you can phrase this operation but

1178
00:46:05,800 --> 00:46:11,880
if that's what it is yeah yeah okay so

1179
00:46:08,040 --> 00:46:13,599
now um let's let's show an equation that

1180
00:46:11,880 --> 00:46:15,640
is not monotonically increasing or

1181
00:46:13,599 --> 00:46:19,520
decreasing right and and like how does

1182
00:46:15,640 --> 00:46:22,000
this work so here's one where we sort of

1183
00:46:19,520 --> 00:46:23,480
started doing our a greater than b right

1184
00:46:22,000 --> 00:46:26,359
this is the increasing but it's got a

1185
00:46:23,480 --> 00:46:28,960
plus e on the end right and so the right

1186
00:46:26,359 --> 00:46:31,160
answer for this is this you want to make

1187
00:46:28,960 --> 00:46:33,200
sure to do the times first which in this

1188
00:46:31,160 --> 00:46:35,359
case if we do the full parenthesis

1189
00:46:33,200 --> 00:46:37,599
version it looks like that and so if you

1190
00:46:35,359 --> 00:46:40,000
convert this to the tree just by that

1191
00:46:37,599 --> 00:46:42,599
rule of like can I Circle the sub tree

1192
00:46:40,000 --> 00:46:44,480
this is the right answer and that maybe

1193
00:46:42,599 --> 00:46:47,079
looks like a scary

1194
00:46:44,480 --> 00:46:49,079
tree but it's actually not scary because

1195
00:46:47,079 --> 00:46:51,960
it's it's two right leaning trees glued

1196
00:46:49,079 --> 00:46:54,480
together where this x here is just this

1197
00:46:51,960 --> 00:46:56,520
tree right and we already know how to

1198
00:46:54,480 --> 00:47:01,119
make these These are made by the stupid

1199
00:46:56,520 --> 00:47:05,839
Parson increasing precedence code right

1200
00:47:01,119 --> 00:47:10,920
so that's basically how this works is

1201
00:47:05,839 --> 00:47:10,920
um you know uh well I I Ste through

1202
00:47:11,280 --> 00:47:15,599
it let's uh let's see if I still

1203
00:47:13,880 --> 00:47:17,680
remember how to explain I basically went

1204
00:47:15,599 --> 00:47:19,200
through it literally every step and

1205
00:47:17,680 --> 00:47:20,960
maybe I should have actually put it in a

1206
00:47:19,200 --> 00:47:24,520
program and step through in the debugger

1207
00:47:20,960 --> 00:47:26,599
but I didn't so um let me let's go let's

1208
00:47:24,520 --> 00:47:30,400
go split screen

1209
00:47:26,599 --> 00:47:34,240
and uh we can keep the code up here okay

1210
00:47:30,400 --> 00:47:36,119
uh right and then over here so uh this

1211
00:47:34,240 --> 00:47:38,720
part when I say parse and then a number

1212
00:47:36,119 --> 00:47:40,559
here that's just a call to this parse

1213
00:47:38,720 --> 00:47:43,760
expression I

1214
00:47:40,559 --> 00:47:46,640
think um hold on or is it a call to the

1215
00:47:43,760 --> 00:47:48,680
probably the yeah I I named them both

1216
00:47:46,640 --> 00:47:51,800
starting with the word parse anyway so

1217
00:47:48,680 --> 00:47:53,280
we start out we parse a leaf right oh

1218
00:47:51,800 --> 00:47:55,960
yeah so we parse the leaf that's going

1219
00:47:53,280 --> 00:47:57,839
to be a we pass it into parse increas

1220
00:47:55,960 --> 00:47:59,920
precedence okay that's going to see the

1221
00:47:57,839 --> 00:48:01,240
greater than so I must mean this yeah

1222
00:47:59,920 --> 00:48:02,400
that's what I I was like it has to

1223
00:48:01,240 --> 00:48:05,119
because the other one doesn't build a

1224
00:48:02,400 --> 00:48:07,119
tree oh yeah this is recursive right so

1225
00:48:05,119 --> 00:48:08,720
so this this called a parse one parse

1226
00:48:07,119 --> 00:48:11,359
one just means calling this function

1227
00:48:08,720 --> 00:48:13,680
again recursively it could be an

1228
00:48:11,359 --> 00:48:15,319
iteration of a loop again don't don't

1229
00:48:13,680 --> 00:48:18,839
you know don't fixate on the recursion

1230
00:48:15,319 --> 00:48:20,720
part um parse one again makes a tree

1231
00:48:18,839 --> 00:48:23,319
like we were saying before we keep

1232
00:48:20,720 --> 00:48:25,240
making sub trees and waiting till later

1233
00:48:23,319 --> 00:48:27,640
right so we do that greater than we do

1234
00:48:25,240 --> 00:48:30,599
the Plus we do the times till now it

1235
00:48:27,640 --> 00:48:34,720
keeps going up so we're fine right when

1236
00:48:30,599 --> 00:48:37,880
we do D um hold on where's the let me

1237
00:48:34,720 --> 00:48:37,880
paste the original

1238
00:48:40,480 --> 00:48:45,200
equation um so we call parse three parse

1239
00:48:44,040 --> 00:48:49,160
3 sees

1240
00:48:45,200 --> 00:48:50,960
D um and then it sees a plus right but

1241
00:48:49,160 --> 00:48:53,119
the Precedence that we passed in was the

1242
00:48:50,960 --> 00:48:56,000
Precedence of times Which is higher so

1243
00:48:53,119 --> 00:48:59,079
you can't go down so we just returned D

1244
00:48:56,000 --> 00:49:01,920
instead of saying d uh plus anything

1245
00:48:59,079 --> 00:49:05,880
right so we the recursive version stops

1246
00:49:01,920 --> 00:49:08,720
here and gives you this tree

1247
00:49:05,880 --> 00:49:10,119
okay um and then this is just showing

1248
00:49:08,720 --> 00:49:13,200
how that tree gets built because we're

1249
00:49:10,119 --> 00:49:16,799
recursing back up right so we got the D

1250
00:49:13,200 --> 00:49:19,200
back we had c times something we had c

1251
00:49:16,799 --> 00:49:22,880
times parse three right the result of

1252
00:49:19,200 --> 00:49:25,799
parse 3 is D so we have C * d right and

1253
00:49:22,880 --> 00:49:27,200
then parse one was B plus the result of

1254
00:49:25,799 --> 00:49:30,119
parse

1255
00:49:27,200 --> 00:49:32,760
two uh yeah B plus the result of parse

1256
00:49:30,119 --> 00:49:36,160
two right and so on so we build this

1257
00:49:32,760 --> 00:49:41,400
tree now um this

1258
00:49:36,160 --> 00:49:43,440
subtree gets returned from here and then

1259
00:49:41,400 --> 00:49:45,000
the the node the node that we got back

1260
00:49:43,440 --> 00:49:47,400
is not equal to the left hand side that

1261
00:49:45,000 --> 00:49:50,240
we passed in so we continue that's our

1262
00:49:47,400 --> 00:49:53,240
new left hand side here this B

1263
00:49:50,240 --> 00:49:53,240
plus

1264
00:49:53,760 --> 00:49:58,680
wait that's right and and then you pass

1265
00:49:56,040 --> 00:49:59,640
it to like you parse the plus and call

1266
00:49:58,680 --> 00:50:01,760
parse

1267
00:49:59,640 --> 00:50:04,000
four

1268
00:50:01,760 --> 00:50:06,880
um you really there should be a parse

1269
00:50:04,000 --> 00:50:09,480
for above like in between these two sort

1270
00:50:06,880 --> 00:50:14,000
of

1271
00:50:09,480 --> 00:50:16,280
but I think okay hold on I I left out a

1272
00:50:14,000 --> 00:50:16,280
step

1273
00:50:17,280 --> 00:50:22,240
somewhere I left out a

1274
00:50:20,200 --> 00:50:24,280
step no you didn't because that's the

1275
00:50:22,240 --> 00:50:25,559
left you got back the left and then

1276
00:50:24,280 --> 00:50:27,839
you're going to call parse increasing

1277
00:50:25,559 --> 00:50:28,920
precedence passing that tree which is

1278
00:50:27,839 --> 00:50:31,760
going to

1279
00:50:28,920 --> 00:50:34,680
parse yes yes so you just left out a

1280
00:50:31,760 --> 00:50:39,000
label I left out yeah yeah yeah um The

1281
00:50:34,680 --> 00:50:40,799
Secret of why this works is um and and

1282
00:50:39,000 --> 00:50:42,200
this is an important change from the

1283
00:50:40,799 --> 00:50:43,920
earlier version you know in the early

1284
00:50:42,200 --> 00:50:45,960
versions of the parse binary tree it

1285
00:50:43,920 --> 00:50:47,839
would like call itself this is why

1286
00:50:45,960 --> 00:50:49,920
remember really early on I'm like I

1287
00:50:47,839 --> 00:50:51,960
don't remember why I put this one in

1288
00:50:49,920 --> 00:50:54,040
it's because of this because I wanted to

1289
00:50:51,960 --> 00:50:55,960
introduce a version where the the old

1290
00:50:54,040 --> 00:50:58,319
parse binary calls back to parse

1291
00:50:55,960 --> 00:51:01,240
expression instead of calling itself

1292
00:50:58,319 --> 00:51:04,200
because what actually makes this work is

1293
00:51:01,240 --> 00:51:07,599
every time you get back a new

1294
00:51:04,200 --> 00:51:09,359
subtree this Loop keeps trying from from

1295
00:51:07,599 --> 00:51:11,799
the Precedence that you use to start

1296
00:51:09,359 --> 00:51:15,200
parsing that sub tree right

1297
00:51:11,799 --> 00:51:17,480
right and uh and that's how you get this

1298
00:51:15,200 --> 00:51:19,799
right here this funny shape is you got

1299
00:51:17,480 --> 00:51:22,760
back this sub tree this greater then is

1300
00:51:19,799 --> 00:51:24,559
still waiting higher up it's like we we

1301
00:51:22,760 --> 00:51:25,960
parse that input but it's like on the

1302
00:51:24,559 --> 00:51:28,839
stack right

1303
00:51:25,960 --> 00:51:32,760
we haven't returned back to it yet so we

1304
00:51:28,839 --> 00:51:34,839
see this um and then what we came in

1305
00:51:32,760 --> 00:51:37,160
here with this Min

1306
00:51:34,839 --> 00:51:38,920
pre when we've got this is the

1307
00:51:37,160 --> 00:51:41,720
Precedence of the greater than right

1308
00:51:38,920 --> 00:51:43,000
because that's what our caller said you

1309
00:51:41,720 --> 00:51:46,559
know you have to

1310
00:51:43,000 --> 00:51:48,480
stop uh at any greater than or or

1311
00:51:46,559 --> 00:51:50,079
anything anything greater than the

1312
00:51:48,480 --> 00:51:54,760
greater than

1313
00:51:50,079 --> 00:51:56,240
that's right so um so here you know plus

1314
00:51:54,760 --> 00:51:58,119
again is higher precedence than greater

1315
00:51:56,240 --> 00:52:00,079
than so it's fine so we do our binary

1316
00:51:58,119 --> 00:52:01,640
tree then but you know instead of having

1317
00:52:00,079 --> 00:52:04,079
a leaf as the left hand side we have

1318
00:52:01,640 --> 00:52:07,599
this whole thing that we passed in and

1319
00:52:04,079 --> 00:52:09,680
that calls parse 4 which gets the E it's

1320
00:52:07,599 --> 00:52:12,280
there wasn't much left it was just the E

1321
00:52:09,680 --> 00:52:16,520
so then this returns that back and then

1322
00:52:12,280 --> 00:52:19,720
this Loop um loops around and uh there's

1323
00:52:16,520 --> 00:52:23,359
nothing new so we return this whole

1324
00:52:19,720 --> 00:52:25,119
thing here and then the collar attaches

1325
00:52:23,359 --> 00:52:28,680
that to the greater than right and so we

1326
00:52:25,119 --> 00:52:32,440
get this complex tree shape

1327
00:52:28,680 --> 00:52:34,200
um it's pretty simple like it's it's a

1328
00:52:32,440 --> 00:52:36,200
little bit complicated to think about in

1329
00:52:34,200 --> 00:52:38,000
the way that any tree operation is I

1330
00:52:36,200 --> 00:52:39,839
think in that like oh just step through

1331
00:52:38,000 --> 00:52:41,760
it and see and I don't expect this

1332
00:52:39,839 --> 00:52:43,079
explanation I expect a lot of people

1333
00:52:41,760 --> 00:52:45,920
would still be scratching their heads a

1334
00:52:43,079 --> 00:52:47,920
little bit um but if you just go through

1335
00:52:45,920 --> 00:52:50,559
a few cases it's like pretty obvious

1336
00:52:47,920 --> 00:52:54,119
what's going on right and this is this

1337
00:52:50,559 --> 00:52:55,760
is basically the whole problem right now

1338
00:52:54,119 --> 00:52:57,119
well why is it the whole problem what

1339
00:52:55,760 --> 00:52:59,400
about other stuff besides binary

1340
00:52:57,119 --> 00:53:00,520
operators right so like can see you have

1341
00:52:59,400 --> 00:53:03,720
like array

1342
00:53:00,520 --> 00:53:06,200
subscripts um this is actually easier

1343
00:53:03,720 --> 00:53:07,799
than a binary operator um it actually is

1344
00:53:06,200 --> 00:53:09,960
a an array subscript is a binary

1345
00:53:07,799 --> 00:53:14,200
operator because it's the thing you want

1346
00:53:09,960 --> 00:53:16,920
to subscript and then the the index

1347
00:53:14,200 --> 00:53:18,599
value um it's just got a little bit more

1348
00:53:16,920 --> 00:53:19,680
syntax and that actually makes it easier

1349
00:53:18,599 --> 00:53:20,920
because you don't have to worry about

1350
00:53:19,680 --> 00:53:22,920
what's on the right hand side of this

1351
00:53:20,920 --> 00:53:25,240
bracket it's like okay we just stop the

1352
00:53:22,920 --> 00:53:26,799
index here so the way that this work

1353
00:53:25,240 --> 00:53:29,240
Works in our code is we just treat the

1354
00:53:26,799 --> 00:53:31,280
left bracket as a binary operator in the

1355
00:53:29,240 --> 00:53:34,119
Precedence table just like anything else

1356
00:53:31,280 --> 00:53:36,119
right um we actually use the asky values

1357
00:53:34,119 --> 00:53:37,799
for most of these um there's a few you

1358
00:53:36,119 --> 00:53:39,680
know when when you have multi- character

1359
00:53:37,799 --> 00:53:41,760
operators there's no obvious asky value

1360
00:53:39,680 --> 00:53:44,799
so those don't but you know we just

1361
00:53:41,760 --> 00:53:48,200
literally have the asky value for this

1362
00:53:44,799 --> 00:53:51,079
um and that handles aray subscripts

1363
00:53:48,200 --> 00:53:53,440
um you know here's an example of a thing

1364
00:53:51,079 --> 00:53:55,160
another kind of thing that the tree

1365
00:53:53,440 --> 00:53:57,200
rewriter used to do that's handled natur

1366
00:53:55,160 --> 00:53:59,599
Naturally by this system is like if you

1367
00:53:57,200 --> 00:54:03,760
say s. a

1368
00:53:59,599 --> 00:54:05,359
subb right and you have some special

1369
00:54:03,760 --> 00:54:07,240
function that does even though array

1370
00:54:05,359 --> 00:54:09,440
subscript is pretty simple you might

1371
00:54:07,240 --> 00:54:12,440
have some modify like we have some weird

1372
00:54:09,440 --> 00:54:14,319
modifiers you might have or um but we

1373
00:54:12,440 --> 00:54:15,799
basically do a function that's like the

1374
00:54:14,319 --> 00:54:18,280
for Loop thing that I was talking about

1375
00:54:15,799 --> 00:54:20,839
where it's like oh if you see a bracket

1376
00:54:18,280 --> 00:54:22,359
just expect you know parse that parse an

1377
00:54:20,839 --> 00:54:24,640
expression and then expect a close

1378
00:54:22,359 --> 00:54:26,680
bracket it's very simple um but it's

1379
00:54:24,640 --> 00:54:30,480
like a a few lines of code that are

1380
00:54:26,680 --> 00:54:32,880
right there and um if you do that you

1381
00:54:30,480 --> 00:54:35,440
end up with

1382
00:54:32,880 --> 00:54:37,520
um

1383
00:54:35,440 --> 00:54:40,240
uh I don't have the wrong one but you

1384
00:54:37,520 --> 00:54:41,760
end up with s. a subb is sort of the

1385
00:54:40,240 --> 00:54:44,359
tree that you end up with again that's

1386
00:54:41,760 --> 00:54:46,720
why precedence matters here this is

1387
00:54:44,359 --> 00:54:48,799
meaningless if you don't know like what

1388
00:54:46,720 --> 00:54:50,319
this is like a struct and we're dotting

1389
00:54:48,799 --> 00:54:53,160
and there's an array element of the

1390
00:54:50,319 --> 00:54:54,599
struct and you can't evaluate this

1391
00:54:53,160 --> 00:54:56,599
without knowing the struct so it's a

1392
00:54:54,599 --> 00:54:59,680
terrible way way to have the tree right

1393
00:54:56,599 --> 00:55:02,480
you actually want this you want s. a

1394
00:54:59,680 --> 00:55:04,079
subscript B right and that's why you

1395
00:55:02,480 --> 00:55:06,839
need to fix the Precedence for this kind

1396
00:55:04,079 --> 00:55:10,599
of case you can do that either through

1397
00:55:06,839 --> 00:55:12,880
tree rewriting or through the thing that

1398
00:55:10,599 --> 00:55:14,559
I did here or I mean I guess we have to

1399
00:55:12,880 --> 00:55:16,960
talk about The Crafting interpreters one

1400
00:55:14,559 --> 00:55:19,520
at the end

1401
00:55:16,960 --> 00:55:22,039
um okay

1402
00:55:19,520 --> 00:55:25,520
so

1403
00:55:22,039 --> 00:55:27,400
um yeah I mean these are just this is

1404
00:55:25,520 --> 00:55:29,240
just to show that it matters what's the

1405
00:55:27,400 --> 00:55:31,760
thing on the left just like any math

1406
00:55:29,240 --> 00:55:34,440
operator right like a a a a struct

1407
00:55:31,760 --> 00:55:36,160
subscript operator has precedence just

1408
00:55:34,440 --> 00:55:38,160
like a math operator because you want

1409
00:55:36,160 --> 00:55:39,839
this text to turn into that but if you

1410
00:55:38,160 --> 00:55:41,359
just change this character to a plus you

1411
00:55:39,839 --> 00:55:43,200
want it to be different right no

1412
00:55:41,359 --> 00:55:44,319
surprise to anyone who's experienced but

1413
00:55:43,200 --> 00:55:47,319
just an

1414
00:55:44,319 --> 00:55:47,319
illustration

1415
00:55:48,520 --> 00:55:52,920
um yeah I mean this is just

1416
00:55:53,119 --> 00:56:00,280
uh in order to handle the close bracket

1417
00:55:57,079 --> 00:56:02,680
um this parse increasing precedence Loop

1418
00:56:00,280 --> 00:56:04,400
basically it's like look it do the same

1419
00:56:02,680 --> 00:56:06,640
thing make sure it's a higher precedence

1420
00:56:04,400 --> 00:56:08,240
than what we had and then like one way

1421
00:56:06,640 --> 00:56:10,760
you could do it which is what I actually

1422
00:56:08,240 --> 00:56:13,720
did is like look if that operator was

1423
00:56:10,760 --> 00:56:15,720
the left bracket just call this function

1424
00:56:13,720 --> 00:56:17,319
that also handles the right bracket

1425
00:56:15,720 --> 00:56:20,960
right again it's a small thing it could

1426
00:56:17,319 --> 00:56:23,039
be inline here but um you know otherwise

1427
00:56:20,960 --> 00:56:25,280
just maybe it's a binary operator so do

1428
00:56:23,039 --> 00:56:28,119
this right and you do that for

1429
00:56:25,280 --> 00:56:30,200
parentheses as well then or yeah yeah

1430
00:56:28,119 --> 00:56:32,839
yeah okay parentheses are very simple

1431
00:56:30,200 --> 00:56:35,440
parentheses just says call this parse

1432
00:56:32,839 --> 00:56:39,079
expression right

1433
00:56:35,440 --> 00:56:41,559
um with uh with again negative Infinity

1434
00:56:39,079 --> 00:56:43,280
for the Precedence because right because

1435
00:56:41,559 --> 00:56:45,280
you're restarting you're restarting yeah

1436
00:56:43,280 --> 00:56:47,559
it's like it's like it's in a black hole

1437
00:56:45,280 --> 00:56:49,799
in its own Universe right and then you

1438
00:56:47,559 --> 00:56:51,640
do that and then you come out right um

1439
00:56:49,799 --> 00:56:53,079
and then function calls are the same you

1440
00:56:51,640 --> 00:56:55,200
know they're syntactically they have a

1441
00:56:53,079 --> 00:56:56,440
little bit more to them but we talked

1442
00:56:55,200 --> 00:56:59,680
about the for loop it's the same thing

1443
00:56:56,440 --> 00:57:02,720
for a function call it's like oh I see

1444
00:56:59,680 --> 00:57:04,559
um I saw an expression right because it

1445
00:57:02,720 --> 00:57:07,480
could be an identifier but it could be

1446
00:57:04,559 --> 00:57:09,680
like d referencing an array of function

1447
00:57:07,480 --> 00:57:12,359
pointers or whatever right I saw an

1448
00:57:09,680 --> 00:57:15,160
expression and then an open pen so we're

1449
00:57:12,359 --> 00:57:17,839
going to start parsing a function and

1450
00:57:15,160 --> 00:57:19,839
then you know look for commas and and

1451
00:57:17,839 --> 00:57:23,160
look for expressions and then look for

1452
00:57:19,839 --> 00:57:25,039
the close so that's logically speaking

1453
00:57:23,160 --> 00:57:28,000
it's all handled the same way like

1454
00:57:25,039 --> 00:57:30,000
anytime you want to do a more a more um

1455
00:57:28,000 --> 00:57:31,440
let's say more rigid syntax than

1456
00:57:30,000 --> 00:57:33,480
something like binary operators or

1457
00:57:31,440 --> 00:57:35,760
something or a more elaborated syntax I

1458
00:57:33,480 --> 00:57:38,079
don't know but these all like the thing

1459
00:57:35,760 --> 00:57:41,280
about these programming languages

1460
00:57:38,079 --> 00:57:45,039
that I don't know if it's luck or

1461
00:57:41,280 --> 00:57:46,839
necessity or what but anytime we have

1462
00:57:45,039 --> 00:57:48,400
these more elaborate syntaxes there just

1463
00:57:46,839 --> 00:57:50,760
isn't really ambiguity that's not

1464
00:57:48,400 --> 00:57:52,559
handled by this like again you do the

1465
00:57:50,760 --> 00:57:54,520
function call and once you're in here

1466
00:57:52,559 --> 00:57:56,920
you're in parentheses and like you can't

1467
00:57:54,520 --> 00:57:57,960
believe lead into the outside world so

1468
00:57:56,920 --> 00:58:00,160
what are you going to do and wouldn't

1469
00:57:57,960 --> 00:58:03,200
the commas just be automatically handled

1470
00:58:00,160 --> 00:58:05,280
by operator precedence anyway depends on

1471
00:58:03,200 --> 00:58:08,400
if comma is an operator and C it is

1472
00:58:05,280 --> 00:58:10,280
right and so yes uh even if it wasn't

1473
00:58:08,400 --> 00:58:12,880
you could parse it as if it was using

1474
00:58:10,280 --> 00:58:15,520
this parser could you not yeah I mean

1475
00:58:12,880 --> 00:58:18,960
okay so there are a few different ways

1476
00:58:15,520 --> 00:58:21,400
you could do stuff like this um I'm

1477
00:58:18,960 --> 00:58:25,200
trying to remember if we do this for

1478
00:58:21,400 --> 00:58:27,160
commas I think we do like so so in in in

1479
00:58:25,200 --> 00:58:29,319
my language comma is not an operator

1480
00:58:27,160 --> 00:58:33,119
which leads me to to be motivated to

1481
00:58:29,319 --> 00:58:34,640
handle it differently um but in C you

1482
00:58:33,119 --> 00:58:39,480
have two choices about how you want to

1483
00:58:34,640 --> 00:58:41,240
parse this one is you could if comma was

1484
00:58:39,480 --> 00:58:43,760
very very low precedence which I believe

1485
00:58:41,240 --> 00:58:46,920
it is like if it was at the very bottom

1486
00:58:43,760 --> 00:58:49,760
of the Precedence table Yeah you could

1487
00:58:46,920 --> 00:58:51,400
like pass that in as the Min preck that

1488
00:58:49,760 --> 00:58:53,039
we were showing and then you'll you'll

1489
00:58:51,400 --> 00:58:55,640
stop at comma and then you parse the

1490
00:58:53,039 --> 00:58:58,200
comma right yeah um another thing you

1491
00:58:55,640 --> 00:58:59,680
could do which is something that I do

1492
00:58:58,200 --> 00:59:01,559
for other things I don't remember if I

1493
00:58:59,680 --> 00:59:03,760
do this for comma but in addition to

1494
00:59:01,559 --> 00:59:05,839
these two parameters I do have a third

1495
00:59:03,760 --> 00:59:07,680
parameter uh which is also in here which

1496
00:59:05,839 --> 00:59:09,400
is just like some control Flags about

1497
00:59:07,680 --> 00:59:11,559
what you're allowed to parse right now

1498
00:59:09,400 --> 00:59:13,960
and it's just like look are you allowed

1499
00:59:11,559 --> 00:59:16,680
to see an open brace here as the start

1500
00:59:13,960 --> 00:59:18,559
of an expression or or not right so like

1501
00:59:16,680 --> 00:59:22,319
in C you have open brace could be part

1502
00:59:18,559 --> 00:59:23,960
of a literal or it could be code and I

1503
00:59:22,319 --> 00:59:25,400
don't know you have a choice about how

1504
00:59:23,960 --> 00:59:27,640
to handle that right

1505
00:59:25,400 --> 00:59:29,799
but that I think by the time you have

1506
00:59:27,640 --> 00:59:32,280
those three parameters the left tree the

1507
00:59:29,799 --> 00:59:35,160
Min precedence and the control Flags

1508
00:59:32,280 --> 00:59:37,880
like you basically can do anything like

1509
00:59:35,160 --> 00:59:39,599
there's no you know um and it's much

1510
00:59:37,880 --> 00:59:42,039
more expressive and powerful than having

1511
00:59:39,599 --> 00:59:44,640
to fit it into some weird like stack

1512
00:59:42,039 --> 00:59:46,640
machine like from the Dragon book

1513
00:59:44,640 --> 00:59:49,359
so

1514
00:59:46,640 --> 00:59:52,160
um oh what was I going to say over here

1515
00:59:49,359 --> 00:59:55,200
oh your other option of how to do

1516
00:59:52,160 --> 00:59:56,039
this is to actually just Parts this as

1517
00:59:55,200 --> 00:59:58,720
one

1518
00:59:56,039 --> 01:00:00,640
expression and then again just say oh is

1519
00:59:58,720 --> 01:00:03,200
it a is it a binary operator that

1520
01:00:00,640 --> 01:00:04,880
happens to be comma okay that's the

1521
01:00:03,200 --> 01:00:08,160
first argument you have a little Loop

1522
01:00:04,880 --> 01:00:09,359
that like UNT trees it that way right um

1523
01:00:08,160 --> 01:00:11,000
You have that's the great thing about

1524
01:00:09,359 --> 01:00:14,400
programming is there's multiple ways to

1525
01:00:11,000 --> 01:00:16,039
solve problems um okay so I sort of

1526
01:00:14,400 --> 01:00:17,799
skipped over this thing about equal

1527
01:00:16,039 --> 01:00:20,240
precedents I talked about plus not

1528
01:00:17,799 --> 01:00:23,079
really mattering

1529
01:00:20,240 --> 01:00:27,039
um the official rule for this that you

1530
01:00:23,079 --> 01:00:28,240
will see in those papers is that um it

1531
01:00:27,039 --> 01:00:30,559
depends if it's left or right

1532
01:00:28,240 --> 01:00:33,480
associative right so if your operator's

1533
01:00:30,559 --> 01:00:36,880
left associative which most operators

1534
01:00:33,480 --> 01:00:38,680
are um there's really almost none that

1535
01:00:36,880 --> 01:00:41,559
are right associative someone someone in

1536
01:00:38,680 --> 01:00:43,640
a paper had or one of the blogs had the

1537
01:00:41,559 --> 01:00:45,000
example of an exponent operator which I

1538
01:00:43,640 --> 01:00:47,599
guess that makes sense that that's right

1539
01:00:45,000 --> 01:00:49,640
associative right y um I I don't have

1540
01:00:47,599 --> 01:00:52,559
that in my language C doesn't have it so

1541
01:00:49,640 --> 01:00:55,559
whatever but if you had that

1542
01:00:52,559 --> 01:00:58,039
then there's a few ways of of how to

1543
01:00:55,559 --> 01:01:00,799
handle it you could have an if statement

1544
01:00:58,039 --> 01:01:02,760
you could have an an extra because my

1545
01:01:00,799 --> 01:01:05,559
precedences are integer and I hope most

1546
01:01:02,760 --> 01:01:06,559
people's are um you could bias like when

1547
01:01:05,559 --> 01:01:11,240
you do this

1548
01:01:06,559 --> 01:01:13,440
comparison um where is it uh this one

1549
01:01:11,240 --> 01:01:15,880
right uh you could

1550
01:01:13,440 --> 01:01:18,440
add

1551
01:01:15,880 --> 01:01:20,559
um is it minus one or plus I don't want

1552
01:01:18,440 --> 01:01:22,000
to think about it but the point being

1553
01:01:20,559 --> 01:01:24,520
you could have a number that for most

1554
01:01:22,000 --> 01:01:26,559
operators is zero but for wrest

1555
01:01:24,520 --> 01:01:28,920
associative is one and that allows you

1556
01:01:26,559 --> 01:01:32,720
to continue in the loop right it would

1557
01:01:28,920 --> 01:01:34,640
have to be um minus one I guess uh or

1558
01:01:32,720 --> 01:01:35,839
plus one on this side right and that

1559
01:01:34,640 --> 01:01:39,200
would just

1560
01:01:35,839 --> 01:01:40,559
say uh keep stay in this loop as long as

1561
01:01:39,200 --> 01:01:42,280
it's the same precedence which is what

1562
01:01:40,559 --> 01:01:44,760
you want to do for right associative

1563
01:01:42,280 --> 01:01:49,000
operators um for left associative

1564
01:01:44,760 --> 01:01:51,799
operators um you want to do uh the left

1565
01:01:49,000 --> 01:01:55,680
leaning tree thing that that your Loop

1566
01:01:51,799 --> 01:01:57,279
would have produced right um

1567
01:01:55,680 --> 01:01:58,839
and again in my parser I don't think

1568
01:01:57,279 --> 01:02:01,720
about this rule at all because we have

1569
01:01:58,839 --> 01:02:04,960
no right associative operator so right

1570
01:02:01,720 --> 01:02:06,760
it's not even a thing yeah yeah yeah um

1571
01:02:04,960 --> 01:02:08,200
because it will always left associate by

1572
01:02:06,760 --> 01:02:10,440
default because of the way you're

1573
01:02:08,200 --> 01:02:12,359
passing the argument down and making

1574
01:02:10,440 --> 01:02:14,640
that decision yes you don't need to do

1575
01:02:12,359 --> 01:02:18,079
anything yeah yes and then that's

1576
01:02:14,640 --> 01:02:20,680
literally everything like and it's so

1577
01:02:18,079 --> 01:02:23,039
disappointing like on the one hand this

1578
01:02:20,680 --> 01:02:25,319
this information is out there in various

1579
01:02:23,039 --> 01:02:28,160
forms you can again you could follow the

1580
01:02:25,319 --> 01:02:30,440
links that I had earlier but like

1581
01:02:28,160 --> 01:02:32,079
there's just so much confusion around it

1582
01:02:30,440 --> 01:02:34,799
and so many

1583
01:02:32,079 --> 01:02:36,960
um like people pretend like it's science

1584
01:02:34,799 --> 01:02:40,079
or whatever but like what it really all

1585
01:02:36,960 --> 01:02:43,039
this really is all we are doing here is

1586
01:02:40,079 --> 01:02:45,720
saying it's almost tological it's like

1587
01:02:43,039 --> 01:02:49,520
look the

1588
01:02:45,720 --> 01:02:51,960
tree the tree is the parentheses so we

1589
01:02:49,520 --> 01:02:54,200
just need the tree to be the right shape

1590
01:02:51,960 --> 01:02:55,200
to be the parenthesis and how do you do

1591
01:02:54,200 --> 01:02:58,279
that

1592
01:02:55,200 --> 01:02:59,920
okay we need to compare precedences like

1593
01:02:58,279 --> 01:03:03,599
and I I guess it's a little bit clever

1594
01:02:59,920 --> 01:03:06,440
that it's not that much code but it's

1595
01:03:03,599 --> 01:03:09,760
just um it's staggering to

1596
01:03:06,440 --> 01:03:13,640
me how people make a big deal out of it

1597
01:03:09,760 --> 01:03:15,200
like I don't even know um I mean I guess

1598
01:03:13,640 --> 01:03:16,640
you know if you're newer at programming

1599
01:03:15,200 --> 01:03:19,079
this I'm sure this seems very

1600
01:03:16,640 --> 01:03:20,760
complicated maybe right but like if

1601
01:03:19,079 --> 01:03:24,359
you've ever shipped a commercial video

1602
01:03:20,760 --> 01:03:27,520
game like this is this is so simple

1603
01:03:24,359 --> 01:03:32,319
compared to so many of things we do

1604
01:03:27,520 --> 01:03:34,400
um yeah um do you so I the only thing

1605
01:03:32,319 --> 01:03:37,720
that I could think about is to talk

1606
01:03:34,400 --> 01:03:40,960
about The Crafting interpreters one um

1607
01:03:37,720 --> 01:03:43,920
unless you had other other topics or

1608
01:03:40,960 --> 01:03:48,000
questions yeah so

1609
01:03:43,920 --> 01:03:50,200
um I guess I'd like to just ask sort of

1610
01:03:48,000 --> 01:03:52,039
one follow-up question which you know I

1611
01:03:50,200 --> 01:03:56,279
could probably guess what the answer is

1612
01:03:52,039 --> 01:03:56,279
but yeah it would be

1613
01:03:56,680 --> 01:04:02,400
why do you need anything other than this

1614
01:03:58,760 --> 01:04:05,319
so it sounds like from what you said

1615
01:04:02,400 --> 01:04:07,039
that effectively the problem the reason

1616
01:04:05,319 --> 01:04:08,680
why you need something other than just a

1617
01:04:07,039 --> 01:04:10,359
loop that does exactly what you just

1618
01:04:08,680 --> 01:04:13,520
described to parse

1619
01:04:10,359 --> 01:04:17,480
everything is because of programming

1620
01:04:13,520 --> 01:04:20,319
constructs where the

1621
01:04:17,480 --> 01:04:23,200
symbols mean something different because

1622
01:04:20,319 --> 01:04:26,400
a previous symbol told you they would so

1623
01:04:23,200 --> 01:04:28,039
for example you gave you said for Loop

1624
01:04:26,400 --> 01:04:31,839
yeah I'm just trying to be concrete here

1625
01:04:28,039 --> 01:04:34,200
yes um so you see a four statement and

1626
01:04:31,839 --> 01:04:38,359
suddenly the meaning of semicolon kind

1627
01:04:34,200 --> 01:04:42,160
of changes like normally in C or C++ or

1628
01:04:38,359 --> 01:04:45,039
most languages you couldn't have a open

1629
01:04:42,160 --> 01:04:47,599
parentheses some stuff and then a

1630
01:04:45,039 --> 01:04:50,799
semicolon right because the semicolon is

1631
01:04:47,599 --> 01:04:52,559
a way of ending a line yeah and you're

1632
01:04:50,799 --> 01:04:55,920
ending a line in the middle of a for

1633
01:04:52,559 --> 01:04:58,319
statement which you know in en sorry in

1634
01:04:55,920 --> 01:05:00,480
the middle of of a par parenthetical you

1635
01:04:58,319 --> 01:05:02,799
wouldn't to do but because it's a for

1636
01:05:00,480 --> 01:05:04,200
statement that's not what that means so

1637
01:05:02,799 --> 01:05:07,279
I'm assuming

1638
01:05:04,200 --> 01:05:08,720
that uh let let me make a sort of bold

1639
01:05:07,279 --> 01:05:10,680
statement here being someone who doesn't

1640
01:05:08,720 --> 01:05:12,039
write parsers I'm just going off of what

1641
01:05:10,680 --> 01:05:14,480
you said

1642
01:05:12,039 --> 01:05:16,720
yeah would it be possible do you think

1643
01:05:14,480 --> 01:05:18,880
to write your entire compiler using just

1644
01:05:16,720 --> 01:05:22,599
that Loop and the only thing you would

1645
01:05:18,880 --> 01:05:25,279
do is have different precedence tables

1646
01:05:22,599 --> 01:05:29,000
based on that you switch when you saw

1647
01:05:25,279 --> 01:05:31,079
keywords like like is it really is is

1648
01:05:29,000 --> 01:05:32,599
really all of parsing just we do some

1649
01:05:31,079 --> 01:05:33,680
left and some right in alternating

1650
01:05:32,599 --> 01:05:34,720
because it seems like maybe it would

1651
01:05:33,680 --> 01:05:36,599
have to be since those are the only

1652
01:05:34,720 --> 01:05:38,279
trees you could produce or are there

1653
01:05:36,599 --> 01:05:40,119
actually things where it's like no you

1654
01:05:38,279 --> 01:05:42,559
need to actually custom parse some

1655
01:05:40,119 --> 01:05:44,720
things not just because it's easier to

1656
01:05:42,559 --> 01:05:47,039
write it that way and to report errors

1657
01:05:44,720 --> 01:05:48,559
which mean or you know or is it

1658
01:05:47,039 --> 01:05:49,880
basically programming languages no they

1659
01:05:48,559 --> 01:05:51,359
just don't have things that couldn't be

1660
01:05:49,880 --> 01:05:53,559
pared this way in general so in this

1661
01:05:51,359 --> 01:05:54,920
case you would make semicolon a really

1662
01:05:53,559 --> 01:05:57,119
low

1663
01:05:54,920 --> 01:05:59,599
yeah precedence operator you still have

1664
01:05:57,119 --> 01:06:01,799
the weirdness where

1665
01:05:59,599 --> 01:06:03,520
um you have a few weirdnesses with

1666
01:06:01,799 --> 01:06:06,359
semicolon specifically right so in the

1667
01:06:03,520 --> 01:06:08,400
four Loop case you're talking about it

1668
01:06:06,359 --> 01:06:09,960
acts like an operator because there

1669
01:06:08,400 --> 01:06:12,640
isn't one on the right although I

1670
01:06:09,960 --> 01:06:16,119
believe you could optionally put one

1671
01:06:12,640 --> 01:06:18,480
right but typic you're allowed not to

1672
01:06:16,119 --> 01:06:21,240
right which is weird right

1673
01:06:18,480 --> 01:06:23,000
um but with statements you're not

1674
01:06:21,240 --> 01:06:25,880
allowed to not put one on the last

1675
01:06:23,000 --> 01:06:28,119
statement but you you are allowed to put

1676
01:06:25,880 --> 01:06:31,279
five in a row with nothing in between

1677
01:06:28,119 --> 01:06:32,240
and so like your operator your normal

1678
01:06:31,279 --> 01:06:35,039
operator

1679
01:06:32,240 --> 01:06:37,400
parsing would have to add complexity to

1680
01:06:35,039 --> 01:06:39,559
deal with that anyway and so when you're

1681
01:06:37,400 --> 01:06:41,839
talking about things this

1682
01:06:39,559 --> 01:06:45,079
simple it's a substantial amount of

1683
01:06:41,839 --> 01:06:48,400
complexity so relative to the the base

1684
01:06:45,079 --> 01:06:52,039
and so I don't know that I would

1685
01:06:48,400 --> 01:06:55,119
ever seriously try to do it that way but

1686
01:06:52,039 --> 01:06:58,359
it might be a fun thing

1687
01:06:55,119 --> 01:07:00,079
um the thing so so just for context for

1688
01:06:58,359 --> 01:07:02,240
people you know we've sort of been

1689
01:07:00,079 --> 01:07:04,880
focusing on this like parse expression

1690
01:07:02,240 --> 01:07:06,680
is like an expression in a programming

1691
01:07:04,880 --> 01:07:09,279
language is is just like one of the

1692
01:07:06,680 --> 01:07:12,319
fundamental units that could be in most

1693
01:07:09,279 --> 01:07:15,000
places right I I don't know if there's a

1694
01:07:12,319 --> 01:07:16,480
better a better explanation than that

1695
01:07:15,000 --> 01:07:18,799
probably there is probably the Dragon

1696
01:07:16,480 --> 01:07:22,400
book has a 17-page explanation of

1697
01:07:18,799 --> 01:07:24,559
expression is that nobody understands um

1698
01:07:22,400 --> 01:07:26,279
but uh you know usually you at least in

1699
01:07:24,559 --> 01:07:27,599
a SE like language you'll have one

1700
01:07:26,279 --> 01:07:29,960
higher level thing which is like

1701
01:07:27,599 --> 01:07:32,000
statement level which would handle the

1702
01:07:29,960 --> 01:07:34,079
semicolon right and there are things

1703
01:07:32,000 --> 01:07:36,760
that are statements that are not

1704
01:07:34,079 --> 01:07:38,480
expressions like a a declaration of a

1705
01:07:36,760 --> 01:07:40,480
variable is a statement but you can't

1706
01:07:38,480 --> 01:07:43,480
have it down in the middle of stuff

1707
01:07:40,480 --> 01:07:45,920
right and so um you already tend to

1708
01:07:43,480 --> 01:07:47,960
naturally make this hierarchy of

1709
01:07:45,920 --> 01:07:48,880
functions that parse specific things and

1710
01:07:47,960 --> 01:07:52,760
I would

1711
01:07:48,880 --> 01:07:54,240
say that is actually the attraction of

1712
01:07:52,760 --> 01:07:55,880
this kind of parsing which again I'll

1713
01:07:54,240 --> 01:07:57,760
say recursive dissent because that's the

1714
01:07:55,880 --> 01:07:58,480
name that people know but like it's not

1715
01:07:57,760 --> 01:08:01,920
that

1716
01:07:58,480 --> 01:08:04,079
complicated like calling functions is a

1717
01:08:01,920 --> 01:08:06,039
thing that we do it's like not rocket

1718
01:08:04,079 --> 01:08:08,200
science to call functions and that's all

1719
01:08:06,039 --> 01:08:09,599
we're talking about so you have a

1720
01:08:08,200 --> 01:08:11,880
function that parses a statement and

1721
01:08:09,599 --> 01:08:13,119
that's just very clear right I mean

1722
01:08:11,880 --> 01:08:16,719
sometimes things get messy when you make

1723
01:08:13,119 --> 01:08:18,440
them complicated but at at its core

1724
01:08:16,719 --> 01:08:20,880
everything is laid out right there and

1725
01:08:18,440 --> 01:08:25,560
you see it right and that's very good

1726
01:08:20,880 --> 01:08:27,239
it's very underrated actually um

1727
01:08:25,560 --> 01:08:29,359
so the thing that you're talking about

1728
01:08:27,239 --> 01:08:30,759
would obfuscate that to some degree I

1729
01:08:29,359 --> 01:08:32,440
think oh yeah it wouldn't probably be

1730
01:08:30,759 --> 01:08:34,359
good for error reporting as we talked

1731
01:08:32,440 --> 01:08:36,159
about right because we're understanding

1732
01:08:34,359 --> 01:08:38,560
the code honestly it's gonna be like

1733
01:08:36,159 --> 01:08:41,799
operator president error it's like the

1734
01:08:38,560 --> 01:08:43,880
only error in the programming L dude

1735
01:08:41,799 --> 01:08:45,880
back when I was in college like shipping

1736
01:08:43,880 --> 01:08:48,359
GCC or

1737
01:08:45,880 --> 01:08:51,199
whatever still would tell you shift

1738
01:08:48,359 --> 01:08:52,799
reduce error or whatever when you got a

1739
01:08:51,199 --> 01:08:55,600
sytax error yeah shift

1740
01:08:52,799 --> 01:08:57,040
reduce [ __ ] awesome you know and

1741
01:08:55,600 --> 01:09:00,159
you're like dude I don't care how you

1742
01:08:57,040 --> 01:09:05,000
implemented the parser

1743
01:09:00,159 --> 01:09:06,679
like so bad so bad okay um let's talk

1744
01:09:05,000 --> 01:09:08,359
about this let me see if I can find the

1745
01:09:06,679 --> 01:09:10,000
the crafting interpreters thing I did

1746
01:09:08,359 --> 01:09:13,239
say it's very slow and you shouldn't do

1747
01:09:10,000 --> 01:09:16,239
it this is true I don't wish to bag on

1748
01:09:13,239 --> 01:09:18,960
it too hard though because it's also um

1749
01:09:16,239 --> 01:09:22,239
kind of awesome okay it's kind of

1750
01:09:18,960 --> 01:09:24,679
awesome okay okay um all right so before

1751
01:09:22,239 --> 01:09:27,279
before we go look at this one let's go

1752
01:09:24,679 --> 01:09:29,799
back and remember sort of the property

1753
01:09:27,279 --> 01:09:33,640
that makes this work for weird arbitrary

1754
01:09:29,799 --> 01:09:35,920
tree shapes is that this Loop here keeps

1755
01:09:33,640 --> 01:09:38,839
trying from the earlier precedence right

1756
01:09:35,920 --> 01:09:41,600
we keep parsing right leaning trees and

1757
01:09:38,839 --> 01:09:43,640
then gluing them on but it's like this

1758
01:09:41,600 --> 01:09:46,839
Loop is like the thing that makes it

1759
01:09:43,640 --> 01:09:48,799
work right okay so now I'm hoping I

1760
01:09:46,839 --> 01:09:51,400
actually had the paper copy of crafting

1761
01:09:48,799 --> 01:09:53,159
interpreters this is the online I don't

1762
01:09:51,400 --> 01:09:54,360
know if it's the same uh but it was

1763
01:09:53,159 --> 01:09:57,679
chapter six

1764
01:09:54,360 --> 01:09:59,719
in my copy so they're they talk about

1765
01:09:57,679 --> 01:10:01,320
BNF grammars and stuff which I wouldn't

1766
01:09:59,719 --> 01:10:05,560
encourage you here's here's the

1767
01:10:01,320 --> 01:10:08,040
explanation of the precedent problem um

1768
01:10:05,560 --> 01:10:10,800
again I didn't really read this either I

1769
01:10:08,040 --> 01:10:12,640
skimmed it okay recursive descent

1770
01:10:10,800 --> 01:10:15,239
parsing

1771
01:10:12,640 --> 01:10:17,840
um he's first parsing some stuff made

1772
01:10:15,239 --> 01:10:19,400
all out of equal signs so the precedent

1773
01:10:17,840 --> 01:10:21,320
that's like our plus sign

1774
01:10:19,400 --> 01:10:24,159
example

1775
01:10:21,320 --> 01:10:26,920
um okay now

1776
01:10:24,159 --> 01:10:29,640
I had to read this like five times to

1777
01:10:26,920 --> 01:10:32,080
understand what was going on because

1778
01:10:29,640 --> 01:10:33,480
it's like can this be made any bigger

1779
01:10:32,080 --> 01:10:36,760
it's kind of hard to read yeah yeah yeah

1780
01:10:33,480 --> 01:10:40,719
yeah yeah um it's it's pretty

1781
01:10:36,760 --> 01:10:43,640
stealth how okay so like the Precedence

1782
01:10:40,719 --> 01:10:45,239
explanation starts here and like I read

1783
01:10:43,640 --> 01:10:48,719
it and I was like where's the pre I

1784
01:10:45,239 --> 01:10:50,760
don't where's the Precedence right and

1785
01:10:48,719 --> 01:10:54,000
okay I just want to encourage

1786
01:10:50,760 --> 01:10:56,280
people there's a class of explanation

1787
01:10:54,000 --> 01:10:58,280
that you read it and it seems like you

1788
01:10:56,280 --> 01:10:59,840
get it but if you think about it you

1789
01:10:58,280 --> 01:11:01,440
realize you really don't get it and

1790
01:10:59,840 --> 01:11:03,800
because I had just worked on this

1791
01:11:01,440 --> 01:11:06,360
problem I read this

1792
01:11:03,800 --> 01:11:09,640
text and I was like dude I just

1793
01:11:06,360 --> 01:11:12,760
implemented a parser that does correct

1794
01:11:09,640 --> 01:11:15,280
precedence for our Corpus of 700 tests

1795
01:11:12,760 --> 01:11:17,480
and our shipping game that's 300,000

1796
01:11:15,280 --> 01:11:20,800
lines long I should understand this and

1797
01:11:17,480 --> 01:11:23,360
I don't I had to like step through it to

1798
01:11:20,800 --> 01:11:24,080
understand so I I guess part of that

1799
01:11:23,360 --> 01:11:27,360
though

1800
01:11:24,080 --> 01:11:29,800
just speaks to the difficulty of

1801
01:11:27,360 --> 01:11:31,880
explaining Concepts in text sometimes

1802
01:11:29,800 --> 01:11:35,080
right but okay

1803
01:11:31,880 --> 01:11:38,760
so somewhere up

1804
01:11:35,080 --> 01:11:41,120
here he there's a couple of sentences I

1805
01:11:38,760 --> 01:11:43,800
don't even know if I'm going to find

1806
01:11:41,120 --> 01:11:46,440
it

1807
01:11:43,800 --> 01:11:49,440
um yeah it's all in Java by the way have

1808
01:11:46,440 --> 01:11:51,480
fun with that um I can't find it okay

1809
01:11:49,440 --> 01:11:54,080
we'll just look at the code like this is

1810
01:11:51,480 --> 01:11:56,600
how stealth it is so what what happens

1811
01:11:54,080 --> 01:11:58,520
is you implement a bunch of functions

1812
01:11:56,600 --> 01:12:00,520
instead of one function for a binary

1813
01:11:58,520 --> 01:12:02,639
operator like I had you group your

1814
01:12:00,520 --> 01:12:04,920
operators into precedence level C does

1815
01:12:02,639 --> 01:12:06,760
this there's like a table of what

1816
01:12:04,920 --> 01:12:08,920
operator at what precedence and so for

1817
01:12:06,760 --> 01:12:11,239
each precedence level you make a

1818
01:12:08,920 --> 01:12:12,760
separate function it's sort of like Comm

1819
01:12:11,239 --> 01:12:16,360
where you have to make a separate class

1820
01:12:12,760 --> 01:12:18,520
for every button or whatever right yeah

1821
01:12:16,360 --> 01:12:21,920
okay but this is also what's awesome

1822
01:12:18,520 --> 01:12:23,520
about it right okay so minus and plus in

1823
01:12:21,920 --> 01:12:26,120
this toy language that they're parsing

1824
01:12:23,520 --> 01:12:29,239
are the lowest I I guess the double

1825
01:12:26,120 --> 01:12:32,679
equals is um comparison so it starts

1826
01:12:29,239 --> 01:12:34,080
actually up here so comparison says it's

1827
01:12:32,679 --> 01:12:35,719
got a while loop remember I said the

1828
01:12:34,080 --> 01:12:38,960
while loop is the Workhorse that makes

1829
01:12:35,719 --> 01:12:41,760
this work right while the Precedence is

1830
01:12:38,960 --> 01:12:44,800
going to be equal or higher you keep

1831
01:12:41,760 --> 01:12:47,199
doing the thing right so here we say

1832
01:12:44,800 --> 01:12:48,520
this is just parsing and it where does

1833
01:12:47,199 --> 01:12:51,040
he call

1834
01:12:48,520 --> 01:12:52,840
comparison I don't know anyway this is

1835
01:12:51,040 --> 01:12:55,840
the equivalent of our parse expression

1836
01:12:52,840 --> 01:12:59,080
you would enter here and okay maybe an

1837
01:12:55,840 --> 01:12:59,840
expression is a comparison operator if

1838
01:12:59,080 --> 01:13:04,320
it

1839
01:12:59,840 --> 01:13:06,639
is uh well we have something on the left

1840
01:13:04,320 --> 01:13:07,960
right that we parsed just like the the

1841
01:13:06,639 --> 01:13:09,280
version that you were talking about so

1842
01:13:07,960 --> 01:13:11,360
we pars the thing on the left first

1843
01:13:09,280 --> 01:13:14,920
actually then we look for the comparison

1844
01:13:11,360 --> 01:13:17,199
operator if it's one of these then um

1845
01:13:14,920 --> 01:13:19,840
parse a thing on the right and then make

1846
01:13:17,199 --> 01:13:22,679
a binary tree just like I was saying

1847
01:13:19,840 --> 01:13:24,440
okay the weird stealth magic is okay

1848
01:13:22,679 --> 01:13:26,520
well you'll note this isn't comparison

1849
01:13:24,440 --> 01:13:29,040
right it's a thing called term yeah

1850
01:13:26,520 --> 01:13:31,040
what's term term is this thing down here

1851
01:13:29,040 --> 01:13:33,840
that's like oh higher precedence

1852
01:13:31,040 --> 01:13:37,920
operators right maybe it's not one of

1853
01:13:33,840 --> 01:13:40,880
these maybe it's a minus or a plus right

1854
01:13:37,920 --> 01:13:42,600
so yeah do this right okay but what's on

1855
01:13:40,880 --> 01:13:44,840
the left because we have to pass the

1856
01:13:42,600 --> 01:13:47,120
left in it's Factor what's factor it's

1857
01:13:44,840 --> 01:13:51,719
this thing down here factor is like

1858
01:13:47,120 --> 01:13:55,280
maybe its times are divide right yep and

1859
01:13:51,719 --> 01:13:57,679
okay may but maybe it's a operator right

1860
01:13:55,280 --> 01:14:00,960
um or maybe it's primary and primary is

1861
01:13:57,679 --> 01:14:03,400
what I was calling Leaf of the tree

1862
01:14:00,960 --> 01:14:06,040
um I didn't like the word primary

1863
01:14:03,400 --> 01:14:07,679
because so he has simple stuff here plus

1864
01:14:06,040 --> 01:14:08,960
this but like all the for Loop and

1865
01:14:07,679 --> 01:14:11,000
whatever that we're talking about are

1866
01:14:08,960 --> 01:14:12,920
essentially they're sort of tree leaves

1867
01:14:11,000 --> 01:14:14,960
relative to everything else except they

1868
01:14:12,920 --> 01:14:16,159
have complex structure inside right

1869
01:14:14,960 --> 01:14:18,920
again they're like a black hole or

1870
01:14:16,159 --> 01:14:21,320
whatever yep

1871
01:14:18,920 --> 01:14:23,560
so this actually works and I had to

1872
01:14:21,320 --> 01:14:25,400
convince myself that this works again by

1873
01:14:23,560 --> 01:14:27,639
taking some of my test cases and like

1874
01:14:25,400 --> 01:14:30,920
stepping through but it literally does

1875
01:14:27,639 --> 01:14:32,880
do the right thing it's as if you took

1876
01:14:30,920 --> 01:14:34,840
any notion of press you got rid of all

1877
01:14:32,880 --> 01:14:37,040
the data in the solution that I talked

1878
01:14:34,840 --> 01:14:39,560
about and you baked it completely into

1879
01:14:37,040 --> 01:14:43,840
code now the reason I am saying please

1880
01:14:39,560 --> 01:14:46,480
do not do this is the following imagine

1881
01:14:43,840 --> 01:14:49,880
your input is the number three or

1882
01:14:46,480 --> 01:14:51,679
whatever it's time to pars a three yeah

1883
01:14:49,880 --> 01:14:54,639
which is common or the name of a

1884
01:14:51,679 --> 01:14:57,080
variable like these are all over your

1885
01:14:54,639 --> 01:15:00,480
program okay what do you have to

1886
01:14:57,080 --> 01:15:04,639
do to find out that it's three you're

1887
01:15:00,480 --> 01:15:08,679
like maybe it's greater than right maybe

1888
01:15:04,639 --> 01:15:12,719
it's maybe maybe and then and then you

1889
01:15:08,679 --> 01:15:15,600
come down here right yeah um and

1890
01:15:12,719 --> 01:15:17,440
so it's not it's not very efficient

1891
01:15:15,600 --> 01:15:20,120
firstly and then

1892
01:15:17,440 --> 01:15:22,920
secondly the thing is it's not very

1893
01:15:20,120 --> 01:15:25,920
fluid with respect to if you're working

1894
01:15:22,920 --> 01:15:28,280
on a language and you're adding new

1895
01:15:25,920 --> 01:15:29,719
things where does this go oh maybe this

1896
01:15:28,280 --> 01:15:32,040
should be higher precedence than this

1897
01:15:29,719 --> 01:15:35,120
thing no let me move it down here this

1898
01:15:32,040 --> 01:15:37,440
is kind of inflexible in that way and

1899
01:15:35,120 --> 01:15:38,960
and maybe easy to make copy pasta errors

1900
01:15:37,440 --> 01:15:40,600
or whatever right because you have to

1901
01:15:38,960 --> 01:15:42,239
keep you have to keep making all these

1902
01:15:40,600 --> 01:15:43,679
functions and then who calls who has to

1903
01:15:42,239 --> 01:15:45,920
change around anytime you change a

1904
01:15:43,679 --> 01:15:49,679
precedence

1905
01:15:45,920 --> 01:15:52,800
but I give it the gold star for

1906
01:15:49,679 --> 01:15:56,199
like the most hardcoded baked down

1907
01:15:52,800 --> 01:16:00,199
implement M mentation right um yeah you

1908
01:15:56,199 --> 01:16:02,719
can type it in entirely in just a top

1909
01:16:00,199 --> 01:16:05,159
down style without needing a table or

1910
01:16:02,719 --> 01:16:08,440
anything or anything yeah like hey my

1911
01:16:05,159 --> 01:16:11,480
embedded CPU does this it uses zero

1912
01:16:08,440 --> 01:16:14,000
bytes of memory

1913
01:16:11,480 --> 01:16:15,880
um I think on an embedded CPU you

1914
01:16:14,000 --> 01:16:19,360
probably really wouldn't want this but

1915
01:16:15,880 --> 01:16:21,000
okay well yeah I don't know um somebody

1916
01:16:19,360 --> 01:16:23,199
somebody in chat was saying he talks

1917
01:16:21,000 --> 01:16:25,719
more about precedence later and maybe

1918
01:16:23,199 --> 01:16:27,880
miss that part but like I said I missed

1919
01:16:25,719 --> 01:16:30,239
most of this part like I had to read

1920
01:16:27,880 --> 01:16:31,719
this like several times before I

1921
01:16:30,239 --> 01:16:33,199
understood what it was doing because it

1922
01:16:31,719 --> 01:16:36,320
just looks

1923
01:16:33,199 --> 01:16:38,360
like it just looks like redundant

1924
01:16:36,320 --> 01:16:40,040
recursive function declarations for

1925
01:16:38,360 --> 01:16:42,600
binary operators and it's like okay it

1926
01:16:40,040 --> 01:16:45,440
is that but the hierarchy of the

1927
01:16:42,600 --> 01:16:47,480
functions does the work put put in terms

1928
01:16:45,440 --> 01:16:49,440
of the way that you explained it with

1929
01:16:47,480 --> 01:16:51,120
the like we need to be able to build

1930
01:16:49,440 --> 01:16:52,679
left leaning trees and right leaning

1931
01:16:51,120 --> 01:16:55,520
trees and then we need to inter leave

1932
01:16:52,679 --> 01:16:58,360
them as as necessary yeah essentially

1933
01:16:55,520 --> 01:17:02,639
what he has done here is just said

1934
01:16:58,360 --> 01:17:07,480
well I am going to make the recursive

1935
01:17:02,639 --> 01:17:08,920
call part build one side of one lean and

1936
01:17:07,480 --> 01:17:12,800
I'm going to make the while loop build

1937
01:17:08,920 --> 01:17:17,239
the other lean and because each step can

1938
01:17:12,800 --> 01:17:18,560
do both we now have the ability to make

1939
01:17:17,239 --> 01:17:21,320
left leaning and right leaning inter

1940
01:17:18,560 --> 01:17:23,360
leave done yeah and we have solved the

1941
01:17:21,320 --> 01:17:25,440
problem right another way to say this

1942
01:17:23,360 --> 01:17:28,440
for people is instead of passing like

1943
01:17:25,440 --> 01:17:30,199
the minimum precedence as a parameter

1944
01:17:28,440 --> 01:17:32,440
it's like you made a bunch of copies of

1945
01:17:30,199 --> 01:17:34,199
the function and you put the name of

1946
01:17:32,440 --> 01:17:35,400
another function is essentially the

1947
01:17:34,199 --> 01:17:38,360
minimum precedence of what you're

1948
01:17:35,400 --> 01:17:41,400
allowed to post now right well stated

1949
01:17:38,360 --> 01:17:44,679
yes it's almost like you had tempate you

1950
01:17:41,400 --> 01:17:48,159
had like template like uh uh you know

1951
01:17:44,679 --> 01:17:50,239
less than Min pre clo you know close and

1952
01:17:48,159 --> 01:17:51,960
you just made an instance of every

1953
01:17:50,239 --> 01:17:54,520
different operator precedence as a

1954
01:17:51,960 --> 01:17:56,960
function yeah and call it yeah don't do

1955
01:17:54,520 --> 01:17:59,000
that I don't recommend that again Robert

1956
01:17:56,960 --> 01:18:01,320
nrom May recommend it he may not I don't

1957
01:17:59,000 --> 01:18:02,800
know why again I know he knows the other

1958
01:18:01,320 --> 01:18:06,440
thing because he wrote a blog post

1959
01:18:02,800 --> 01:18:08,120
explaining it 10 years before this so

1960
01:18:06,440 --> 01:18:10,360
this is not to bag on the author of this

1961
01:18:08,120 --> 01:18:12,840
in any way it's just I would

1962
01:18:10,360 --> 01:18:15,639
not if someone working for me wrote this

1963
01:18:12,840 --> 01:18:20,080
we would have a conversation you know

1964
01:18:15,639 --> 01:18:22,239
that's all I'm saying um I see but maybe

1965
01:18:20,080 --> 01:18:23,679
it's easier to understand I don't know I

1966
01:18:22,239 --> 01:18:25,159
don't know people

1967
01:18:23,679 --> 01:18:28,520
people can tell me if they find this

1968
01:18:25,159 --> 01:18:31,320
version easier than the the Min pre

1969
01:18:28,520 --> 01:18:33,679
version um I don't know but that's it

1970
01:18:31,320 --> 01:18:35,800
that was um so I just wanted to say you

1971
01:18:33,679 --> 01:18:38,679
know again I don't think any of this

1972
01:18:35,800 --> 01:18:40,360
information is super new because there's

1973
01:18:38,679 --> 01:18:42,280
people out there who know these facts

1974
01:18:40,360 --> 01:18:45,679
it's

1975
01:18:42,280 --> 01:18:49,360
just again when I went to go read

1976
01:18:45,679 --> 01:18:50,679
things like when you go read a source of

1977
01:18:49,360 --> 01:18:53,280
technical

1978
01:18:50,679 --> 01:18:56,360
knowledge these days you really really

1979
01:18:53,280 --> 01:18:58,719
have to be asking yourself how much you

1980
01:18:56,360 --> 01:19:01,280
should trust it right that was less true

1981
01:18:58,719 --> 01:19:03,199
before although as we know we we talked

1982
01:19:01,280 --> 01:19:06,159
about some examples that stretches way

1983
01:19:03,199 --> 01:19:08,480
back into time um and

1984
01:19:06,159 --> 01:19:10,440
so you know the again the problem when

1985
01:19:08,480 --> 01:19:13,440
you go trying to read about this stuff

1986
01:19:10,440 --> 01:19:14,840
is you don't know what to trust and if I

1987
01:19:13,440 --> 01:19:16,280
don't know that I should trust something

1988
01:19:14,840 --> 01:19:17,679
maybe there's a personality difference

1989
01:19:16,280 --> 01:19:19,600
between us if I don't know that I should

1990
01:19:17,679 --> 01:19:22,120
trust something like my energy

1991
01:19:19,600 --> 01:19:23,440
investment in figuring out if I should

1992
01:19:22,120 --> 01:19:25,639
trust it

1993
01:19:23,440 --> 01:19:28,320
depends on how many other options I have

1994
01:19:25,639 --> 01:19:31,120
right it's like if this is my only

1995
01:19:28,320 --> 01:19:33,000
option and I don't know how trustworthy

1996
01:19:31,120 --> 01:19:34,560
it is what else am I going to do I'm

1997
01:19:33,000 --> 01:19:37,639
going to figure it out I'm going to

1998
01:19:34,560 --> 01:19:40,960
study this description and try to

1999
01:19:37,639 --> 01:19:42,719
understand how it works um if you have

2000
01:19:40,960 --> 01:19:45,440
an entire internet full of other stuff

2001
01:19:42,719 --> 01:19:48,520
I'll just search for something else and

2002
01:19:45,440 --> 01:19:52,920
like there's just so much noise is the

2003
01:19:48,520 --> 01:19:54,800
problem and um it's really so simple and

2004
01:19:52,920 --> 01:19:56,239
so I just want to try to signal boost a

2005
01:19:54,800 --> 01:19:57,840
little bit I mean that's the reason why

2006
01:19:56,239 --> 01:19:59,159
I wanted to make it a public stream is

2007
01:19:57,840 --> 01:20:01,760
we could put it on YouTube next to the

2008
01:19:59,159 --> 01:20:03,920
other thing and it's a nice book end to

2009
01:20:01,760 --> 01:20:06,000
that question that we had about how to

2010
01:20:03,920 --> 01:20:07,960
do precedence and I was like oh just

2011
01:20:06,000 --> 01:20:10,920
write some code it's like okay well no

2012
01:20:07,960 --> 01:20:14,000
this is you would actually call this an

2013
01:20:10,920 --> 01:20:16,880
algorithm yeah um whereas the thing that

2014
01:20:14,000 --> 01:20:18,520
I used to do is not even really an Al I

2015
01:20:16,880 --> 01:20:20,199
mean you would the way that people use

2016
01:20:18,520 --> 01:20:22,400
the algorithm the word algorithm these

2017
01:20:20,199 --> 01:20:24,080
days everything is an algorithm but the

2018
01:20:22,400 --> 01:20:26,440
the thing I did before was like look

2019
01:20:24,080 --> 01:20:28,280
just write algorith but not the

2020
01:20:26,440 --> 01:20:31,639
algorithm which of course is something

2021
01:20:28,280 --> 01:20:35,360
totally different yes of course

2022
01:20:31,639 --> 01:20:36,880
um anyway I was just I was also hyped

2023
01:20:35,360 --> 01:20:38,560
that it was so simple and so easy to

2024
01:20:36,880 --> 01:20:40,880
figure it out so I was like hey let's

2025
01:20:38,560 --> 01:20:43,120
just do a little talk and go through I

2026
01:20:40,880 --> 01:20:45,840
would also say that like it's uh it's

2027
01:20:43,120 --> 01:20:48,840
good I I think your explanation is good

2028
01:20:45,840 --> 01:20:51,360
as well for people who want to

2029
01:20:48,840 --> 01:20:53,520
understand so so shunting yard is a good

2030
01:20:51,360 --> 01:20:55,520
example of a literal algorithm like here

2031
01:20:53,520 --> 01:20:57,000
is a very this is defin it's an

2032
01:20:55,520 --> 01:21:00,239
algorithm with with a name and

2033
01:20:57,000 --> 01:21:02,120
everything yes uh and you can understand

2034
01:21:00,239 --> 01:21:03,600
it much better once you've walked

2035
01:21:02,120 --> 01:21:04,760
through it the way you have because as

2036
01:21:03,600 --> 01:21:07,239
you pointed out it's basically just

2037
01:21:04,760 --> 01:21:09,960
doing the same thing but it does it it

2038
01:21:07,239 --> 01:21:12,040
explains it in terms of just if you just

2039
01:21:09,960 --> 01:21:14,960
have a stack instead of having an actual

2040
01:21:12,040 --> 01:21:17,040
recursive call of some kind uh and stuff

2041
01:21:14,960 --> 01:21:18,800
like that so it's like it's just helpful

2042
01:21:17,040 --> 01:21:20,400
to understand as well to have more

2043
01:21:18,800 --> 01:21:21,719
explanations more explanations are

2044
01:21:20,400 --> 01:21:23,120
better because there are like you said a

2045
01:21:21,719 --> 01:21:25,360
bunch of people who have done something

2046
01:21:23,120 --> 01:21:27,520
like this but it's not always easy to

2047
01:21:25,360 --> 01:21:28,639
understand why their thing works or what

2048
01:21:27,520 --> 01:21:32,040
it's

2049
01:21:28,639 --> 01:21:33,520
doing um but it's always doing this

2050
01:21:32,040 --> 01:21:36,440
basically I

2051
01:21:33,520 --> 01:21:39,560
mean the the output the correct output

2052
01:21:36,440 --> 01:21:41,080
is predetermined right yes and so

2053
01:21:39,560 --> 01:21:43,800
therefore

2054
01:21:41,080 --> 01:21:45,560
um I mean there's there's some freedom

2055
01:21:43,800 --> 01:21:46,880
in in what the implementation could be

2056
01:21:45,560 --> 01:21:50,280
obviously we just looked at this other

2057
01:21:46,880 --> 01:21:52,239
one but like it's kind of constrained by

2058
01:21:50,280 --> 01:21:54,880
how complex could the mapping possibly

2059
01:21:52,239 --> 01:21:57,159
be right like at some point if your

2060
01:21:54,880 --> 01:21:58,840
implementation is so complex you must be

2061
01:21:57,159 --> 01:22:01,639
doing a lot of extra stuff that could be

2062
01:21:58,840 --> 01:22:03,920
simplified away because the input is not

2063
01:22:01,639 --> 01:22:07,639
that complicated and the output is not

2064
01:22:03,920 --> 01:22:09,360
that complicated it's just like yeah and

2065
01:22:07,639 --> 01:22:13,679
I

2066
01:22:09,360 --> 01:22:15,960
just I don't understand why this has

2067
01:22:13,679 --> 01:22:19,760
been made so hard I mean I'm frustrated

2068
01:22:15,960 --> 01:22:22,080
because like look dude my hobby in

2069
01:22:19,760 --> 01:22:26,400
college was making toy programming

2070
01:22:22,080 --> 01:22:29,400
languages at first I would do

2071
01:22:26,400 --> 01:22:32,639
um uh you know parser generator kind of

2072
01:22:29,400 --> 01:22:35,840
stuff Yak yeah like I made like 11 or 12

2073
01:22:32,639 --> 01:22:37,960
of these right and then I very quickly

2074
01:22:35,840 --> 01:22:40,320
graduated to like yeah this actually

2075
01:22:37,960 --> 01:22:42,960
sucks if you use it and you you know

2076
01:22:40,320 --> 01:22:45,120
what you can write on your own so I very

2077
01:22:42,960 --> 01:22:48,199
by the end of that process was fully on

2078
01:22:45,120 --> 01:22:51,320
the write your own Lex gloyer and parser

2079
01:22:48,199 --> 01:22:53,239
train um however I actually don't

2080
01:22:51,320 --> 01:22:55,960
remember what I did for press back then

2081
01:22:53,239 --> 01:22:59,199
it's weird I know I did

2082
01:22:55,960 --> 01:23:01,239
something um because the stuff worked

2083
01:22:59,199 --> 01:23:03,440
and it's very frustrating to program in

2084
01:23:01,239 --> 01:23:05,920
a language that doesn't have that has an

2085
01:23:03,440 --> 01:23:07,560
infixed notation and no precedence but I

2086
01:23:05,920 --> 01:23:09,760
I don't remember and I don't have any of

2087
01:23:07,560 --> 01:23:12,400
that code I don't think you've got lurp

2088
01:23:09,760 --> 01:23:15,400
what did you do in there can we rewrite

2089
01:23:12,400 --> 01:23:19,040
lurp was weird because I

2090
01:23:15,400 --> 01:23:21,120
didn't yeah I could go look um but like

2091
01:23:19,040 --> 01:23:23,920
I maybe wasn't concerned with this kind

2092
01:23:21,120 --> 01:23:25,760
of thing yet anyway because I was more I

2093
01:23:23,920 --> 01:23:28,719
was more doing this weird like database

2094
01:23:25,760 --> 01:23:29,639
as a primitive thing and yeah I don't

2095
01:23:28,719 --> 01:23:32,360
know

2096
01:23:29,639 --> 01:23:34,320
I I mean it certainly had a alexir and a

2097
01:23:32,360 --> 01:23:35,800
parser in it and so I could go dig that

2098
01:23:34,320 --> 01:23:37,920
up but yeah I don't have any of my

2099
01:23:35,800 --> 01:23:39,040
college day code around so I wonder what

2100
01:23:37,920 --> 01:23:40,719
I

2101
01:23:39,040 --> 01:23:43,760
did

2102
01:23:40,719 --> 01:23:45,800
um but yeah it's just like how do I go

2103
01:23:43,760 --> 01:23:48,600
this long and not understand something

2104
01:23:45,800 --> 01:23:51,360
so simple and maybe it's my fault maybe

2105
01:23:48,600 --> 01:23:54,880
I'm dumb but I don't think so I think

2106
01:23:51,360 --> 01:23:57,239
like even like you know you go on hacker

2107
01:23:54,880 --> 01:24:01,239
so this thing one one name for this I

2108
01:23:57,239 --> 01:24:02,880
think is a pratt parser which I mean I'm

2109
01:24:01,239 --> 01:24:05,360
conflicted about names like that in

2110
01:24:02,880 --> 01:24:07,360
general because you know it's because of

2111
01:24:05,360 --> 01:24:08,880
this original paper that like I don't

2112
01:24:07,360 --> 01:24:11,199
understand but

2113
01:24:08,880 --> 01:24:14,480
um you know give credit where credit is

2114
01:24:11,199 --> 01:24:17,800
due but also I feel like when you name

2115
01:24:14,480 --> 01:24:19,239
stuff you make it sound complicated and

2116
01:24:17,800 --> 01:24:22,000
then you go on Hacker News and there's

2117
01:24:19,239 --> 01:24:25,760
people talking about how Pratt parser

2118
01:24:22,000 --> 01:24:27,360
combat ators are the future of computers

2119
01:24:25,760 --> 01:24:30,960
or whatever and you're just like oh my

2120
01:24:27,360 --> 01:24:34,239
God guys um like they're like new

2121
01:24:30,960 --> 01:24:35,719
advances in uh reverse frobin or

2122
01:24:34,239 --> 01:24:38,080
whatever and you're like what's that and

2123
01:24:35,719 --> 01:24:40,679
you're like oh it's we we've almost got

2124
01:24:38,080 --> 01:24:43,040
this new like theoretical parser to to

2125
01:24:40,679 --> 01:24:44,760
run at one character per second of of

2126
01:24:43,040 --> 01:24:46,480
input or whatever and you're just you're

2127
01:24:44,760 --> 01:24:48,239
kind of your head explodes about why

2128
01:24:46,480 --> 01:24:49,960
they are still like looking at this

2129
01:24:48,239 --> 01:24:53,000
stuff but

2130
01:24:49,960 --> 01:24:56,040
yeah yeah exactly

2131
01:24:53,000 --> 01:24:57,639
we throw an exception per character yeah

2132
01:24:56,040 --> 01:24:59,639
and so yeah I can understand the

2133
01:24:57,639 --> 01:25:01,239
exacerbation but to be fair that happens

2134
01:24:59,639 --> 01:25:04,119
in literally everything like there are

2135
01:25:01,239 --> 01:25:07,080
people rat huling in theoretical stuff

2136
01:25:04,119 --> 01:25:08,880
for everything uh someone says which

2137
01:25:07,080 --> 01:25:10,880
find sometimes they find something

2138
01:25:08,880 --> 01:25:12,679
someone says LOL but the book explains

2139
01:25:10,880 --> 01:25:16,000
that in the next part let's just look

2140
01:25:12,679 --> 01:25:16,760
because again my goal here is not is not

2141
01:25:16,000 --> 01:25:20,080
to

2142
01:25:16,760 --> 01:25:22,800
denigrate anything um

2143
01:25:20,080 --> 01:25:24,679
but I mean I I read the thing and it

2144
01:25:22,800 --> 01:25:26,520
sounded like I had gotten to the end of

2145
01:25:24,679 --> 01:25:28,760
the so recursive Des this is all the

2146
01:25:26,520 --> 01:25:30,960
stuff we looked at Sy and then it talks

2147
01:25:28,760 --> 01:25:33,960
about syntax errors and I was like okay

2148
01:25:30,960 --> 01:25:35,880
parsing must be done um do you mean yeah

2149
01:25:33,960 --> 01:25:40,400
that seems like the end yeah do you mean

2150
01:25:35,880 --> 01:25:43,719
part seven wiring up the

2151
01:25:40,400 --> 01:25:43,719
parser aor

2152
01:25:43,880 --> 01:25:49,440
handling delete the blah blah blah

2153
01:25:46,920 --> 01:25:53,119
design note logic versus

2154
01:25:49,440 --> 01:25:54,960
history should we put where okay

2155
01:25:53,119 --> 01:25:59,000
yeah so he's talking about that which I

2156
01:25:54,960 --> 01:25:59,000
probably agree with

2157
01:25:59,080 --> 01:26:03,199
um okay so this is like a a side note

2158
01:26:01,960 --> 01:26:05,360
about

2159
01:26:03,199 --> 01:26:07,840
precedence no this is a side note about

2160
01:26:05,360 --> 01:26:09,719
backward compatibility yeah this is not

2161
01:26:07,840 --> 01:26:13,239
really about that so do they mean part

2162
01:26:09,719 --> 01:26:15,320
seven next evaluating expressions no

2163
01:26:13,239 --> 01:26:17,960
that because that's iterating over the

2164
01:26:15,320 --> 01:26:20,400
tree and like chat what are you talking

2165
01:26:17,960 --> 01:26:23,920
about be more specific

2166
01:26:20,400 --> 01:26:27,199
chat oh wait wait wait wait there's okay

2167
01:26:23,920 --> 01:26:29,800
someone has given me a specific link yes

2168
01:26:27,199 --> 01:26:32,840
you needed we needed chat to be more

2169
01:26:29,800 --> 01:26:36,000
specific where the link isn't opening

2170
01:26:32,840 --> 01:26:39,360
chapter 17 oh so by the next part you

2171
01:26:36,000 --> 01:26:42,320
mean chapter 17 I mean I I think that's

2172
01:26:39,360 --> 01:26:44,040
fine again like maybe the advanced stuff

2173
01:26:42,320 --> 01:26:46,920
is at the end if you consider that but

2174
01:26:44,040 --> 01:26:48,960
that's not that I would yeah I would say

2175
01:26:46,920 --> 01:26:51,560
no because if if that's what you were

2176
01:26:48,960 --> 01:26:53,760
handed as your first explanation though

2177
01:26:51,560 --> 01:26:56,679
yeah right like like it's important to

2178
01:26:53,760 --> 01:26:58,159
explain it clearly the first time that

2179
01:26:56,679 --> 01:26:59,760
that's kind of what we're talking about

2180
01:26:58,159 --> 01:27:01,639
like obviously anyone who becomes an

2181
01:26:59,760 --> 01:27:03,600
expert in parsers will know about Pratt

2182
01:27:01,639 --> 01:27:05,159
parsers or whatever else you want to

2183
01:27:03,600 --> 01:27:08,400
call this sort of stuff because you'll

2184
01:27:05,159 --> 01:27:09,760
study the problem with ton the point is

2185
01:27:08,400 --> 01:27:11,520
if you're someone who doesn't want to

2186
01:27:09,760 --> 01:27:13,320
become an expert in parsers you just

2187
01:27:11,520 --> 01:27:17,119
want to write a parser the first

2188
01:27:13,320 --> 01:27:18,880
explanation should explain this that's

2189
01:27:17,119 --> 01:27:20,800
that's the whole point of this whole

2190
01:27:18,880 --> 01:27:23,239
thing the Dragon book for all I know

2191
01:27:20,800 --> 01:27:24,800
might have a PR parser mentioned in some

2192
01:27:23,239 --> 01:27:27,400
exercise to the reader I almost

2193
01:27:24,800 --> 01:27:29,239
guarantee they do but but they don't you

2194
01:27:27,400 --> 01:27:31,000
know that's not the problem the problem

2195
01:27:29,239 --> 01:27:32,679
is not that that the information doesn't

2196
01:27:31,000 --> 01:27:34,480
exist it's that it's not presented as

2197
01:27:32,679 --> 01:27:35,880
the first way to understand it is that

2198
01:27:34,480 --> 01:27:37,360
you have left and right leaning trees

2199
01:27:35,880 --> 01:27:39,320
and you're trying to inter leave them

2200
01:27:37,360 --> 01:27:42,679
which is the which is the critical part

2201
01:27:39,320 --> 01:27:47,280
right yeah I'm looking in the P section

2202
01:27:42,679 --> 01:27:52,440
really fast Pratt VR 189 to 90 yeah so

2203
01:27:47,280 --> 01:27:55,600
they mention it for like one page yeah

2204
01:27:52,440 --> 01:27:58,880
in the Dragon book yep yeah and it's

2205
01:27:55,600 --> 01:28:01,159
like yeah in the references for chapter

2206
01:27:58,880 --> 01:28:05,560
3 so they don't even really talk about

2207
01:28:01,159 --> 01:28:08,679
the algorithm it's like references okay

2208
01:28:05,560 --> 01:28:09,880
um so this is if this is about parsing

2209
01:28:08,679 --> 01:28:12,080
it's misleading because it's called

2210
01:28:09,880 --> 01:28:14,880
compiling expressions and that to me

2211
01:28:12,080 --> 01:28:17,280
says like backend

2212
01:28:14,880 --> 01:28:18,679
stuff this is definitely back in but

2213
01:28:17,280 --> 01:28:21,320
there was a thing that said side note

2214
01:28:18,679 --> 01:28:24,520
it's just part okay Pratt parsers are a

2215
01:28:21,320 --> 01:28:27,280
sort of oral Trad ition no compiler or

2216
01:28:24,520 --> 01:28:30,159
language book I've read teaches

2217
01:28:27,280 --> 01:28:32,960
them okay so so he's talking about that

2218
01:28:30,159 --> 01:28:34,719
paper here it's the most elegant way I

2219
01:28:32,960 --> 01:28:37,280
know to parse why are we parsing

2220
01:28:34,719 --> 01:28:39,920
Expressions again in section 17 that's

2221
01:28:37,280 --> 01:28:41,440
really weird no one would know to even

2222
01:28:39,920 --> 01:28:42,920
look at this if you were just building a

2223
01:28:41,440 --> 01:28:45,600
parser because you wouldn't be reading

2224
01:28:42,920 --> 01:28:47,280
this part I mean I guess you know so I'm

2225
01:28:45,600 --> 01:28:48,600
using it as a reference right but if

2226
01:28:47,280 --> 01:28:49,760
you're using it as a learning book you

2227
01:28:48,600 --> 01:28:52,199
read it differently and you probably

2228
01:28:49,760 --> 01:28:55,560
read the whole thing so I don't know no

2229
01:28:52,199 --> 01:28:56,840
okay no I object I object again because

2230
01:28:55,560 --> 01:28:59,400
this is exactly what happens with the

2231
01:28:56,840 --> 01:29:01,880
Dragon book you read the parsing part

2232
01:28:59,400 --> 01:29:03,880
and you go wow this is really confusing

2233
01:29:01,880 --> 01:29:07,040
you may never get to the compiling part

2234
01:29:03,880 --> 01:29:08,920
like you have to teach the parsing well

2235
01:29:07,040 --> 01:29:10,480
because without a like solid

2236
01:29:08,920 --> 01:29:12,239
understanding of how to build a parser

2237
01:29:10,480 --> 01:29:13,639
and keep that simple they're they're

2238
01:29:12,239 --> 01:29:16,159
never going to get to the part where

2239
01:29:13,639 --> 01:29:19,400
they like you know do optimization

2240
01:29:16,159 --> 01:29:20,840
passes or whatever else right so like no

2241
01:29:19,400 --> 01:29:23,400
this is the same problem as the Dragon

2242
01:29:20,840 --> 01:29:24,679
book again yeah I mean I don't I don't

2243
01:29:23,400 --> 01:29:27,880
understand the motivation behind doing

2244
01:29:24,679 --> 01:29:29,960
this later maybe we should ask him um

2245
01:29:27,880 --> 01:29:32,400
yeah it it seems weird to me because

2246
01:29:29,960 --> 01:29:34,159
he's like oh now we're I guess so it's

2247
01:29:32,400 --> 01:29:35,760
called crafting interpreters right and

2248
01:29:34,159 --> 01:29:37,639
an interpreter is a lighter weight thing

2249
01:29:35,760 --> 01:29:39,360
than a compiler where you have some

2250
01:29:37,639 --> 01:29:41,000
other program that's the runtime

2251
01:29:39,360 --> 01:29:44,199
typically you might even look just at

2252
01:29:41,000 --> 01:29:47,320
the tree and like run plus by saying oh

2253
01:29:44,199 --> 01:29:48,920
I'm visiting the binary tree and this

2254
01:29:47,320 --> 01:29:50,920
node is plus and so I'm going to add a

2255
01:29:48,920 --> 01:29:54,480
and b or whatever right and then

2256
01:29:50,920 --> 01:29:56,280
compilers are when you take that several

2257
01:29:54,480 --> 01:29:58,239
steps further such that you can create a

2258
01:29:56,280 --> 01:29:59,880
program that could run on its own

2259
01:29:58,239 --> 01:30:00,760
without something else running it right

2260
01:29:59,880 --> 01:30:03,760
that's the difference between an

2261
01:30:00,760 --> 01:30:07,320
interpreter and a compiler um I don't

2262
01:30:03,760 --> 01:30:09,600
know why that like he's acting here

2263
01:30:07,320 --> 01:30:12,040
like that causes you to change the

2264
01:30:09,600 --> 01:30:13,639
parsing which it doesn't yeah it's very

2265
01:30:12,040 --> 01:30:16,320
strange the parsing the method of

2266
01:30:13,639 --> 01:30:18,000
parsing is orthogonal so I have to

2267
01:30:16,320 --> 01:30:19,480
believe that this is more incidental

2268
01:30:18,000 --> 01:30:20,840
like he want he felt like that was more

2269
01:30:19,480 --> 01:30:22,719
advanced and wanted to leave it till

2270
01:30:20,840 --> 01:30:24,800
later Poss

2271
01:30:22,719 --> 01:30:27,800
it's just weird I don't I don't get it

2272
01:30:24,800 --> 01:30:27,800
okay

2273
01:30:28,239 --> 01:30:31,960
um but yeah this is

2274
01:30:32,960 --> 01:30:38,080
mostly parsing token what why are we

2275
01:30:35,960 --> 01:30:39,320
here again it's so weird to redo this

2276
01:30:38,080 --> 01:30:41,440
like you'd think that this would have

2277
01:30:39,320 --> 01:30:43,159
been in the first part where about about

2278
01:30:41,440 --> 01:30:45,080
parsing maybe this was going to be a

2279
01:30:43,159 --> 01:30:47,639
second book or something and it wasn't

2280
01:30:45,080 --> 01:30:49,400
long enough maybe or maybe maybe this

2281
01:30:47,639 --> 01:30:52,360
book is more of just a collection of

2282
01:30:49,400 --> 01:30:55,080
things and that got Loosely reorganized

2283
01:30:52,360 --> 01:30:57,760
and it wasn't ever designed as a book

2284
01:30:55,080 --> 01:31:01,400
like I I reshuffled my blog posts or

2285
01:30:57,760 --> 01:31:04,480
whatever you know sometimes that can

2286
01:31:01,400 --> 01:31:09,199
happen Okay parsing prefix expressions

2287
01:31:04,480 --> 01:31:09,199
parsers for to parenthesis for

2288
01:31:10,159 --> 01:31:14,119
grouping I still don't really I mean I'm

2289
01:31:12,360 --> 01:31:16,119
skimming again obviously but I still

2290
01:31:14,119 --> 01:31:18,320
don't see the actual okay here we go

2291
01:31:16,119 --> 01:31:20,760
here we go this is the actual part that

2292
01:31:18,320 --> 01:31:23,280
explains it it's yeah two-thirds of the

2293
01:31:20,760 --> 01:31:27,040
way down sections 17 about a compiler

2294
01:31:23,280 --> 01:31:29,480
inste 17.5 I mean it's good it again

2295
01:31:27,040 --> 01:31:32,440
this is good information I'm glad it's

2296
01:31:29,480 --> 01:31:34,480
I'm glad it's here I just don't quite

2297
01:31:32,440 --> 01:31:35,960
understand don't understand the order of

2298
01:31:34,480 --> 01:31:38,480
the information and again it need to get

2299
01:31:35,960 --> 01:31:40,040
moved up yeah it's not it's not temporal

2300
01:31:38,480 --> 01:31:42,040
in the order he learned it or anything

2301
01:31:40,040 --> 01:31:46,480
because he wrote that blog 10 years

2302
01:31:42,040 --> 01:31:46,480
before this so he knew this the whole

2303
01:31:47,239 --> 01:31:53,800
time

2304
01:31:49,800 --> 01:31:57,800
um so he's here he's in leaving parsing

2305
01:31:53,800 --> 01:31:59,400
with output which again it's a fun stunt

2306
01:31:57,800 --> 01:32:02,639
but like you don't want to do that once

2307
01:31:59,400 --> 01:32:06,119
you're compiler exceeds a

2308
01:32:02,639 --> 01:32:08,280
certain complexity but I mean for

2309
01:32:06,119 --> 01:32:10,760
teaching I guess it's it's fun to show

2310
01:32:08,280 --> 01:32:13,719
how simple it could be to right to emit

2311
01:32:10,760 --> 01:32:16,920
code right

2312
01:32:13,719 --> 01:32:16,920
um all

2313
01:32:16,960 --> 01:32:23,400
right there's a precedence table pre

2314
01:32:20,400 --> 01:32:25,679
none for all these

2315
01:32:23,400 --> 01:32:28,679
things I don't

2316
01:32:25,679 --> 01:32:28,679
know

2317
01:32:28,760 --> 01:32:31,960
um get

2318
01:32:33,000 --> 01:32:37,400
rule

2319
01:32:35,000 --> 01:32:41,239
okay yeah so he's broken it into a

2320
01:32:37,400 --> 01:32:43,199
couple of functions here

2321
01:32:41,239 --> 01:32:45,880
but

2322
01:32:43,199 --> 01:32:48,159
um and I

2323
01:32:45,880 --> 01:32:50,119
don't I don't know if these definitions

2324
01:32:48,159 --> 01:32:53,639
are above or below Advance might be

2325
01:32:50,119 --> 01:32:53,639
eating a token

2326
01:32:54,440 --> 01:32:59,440
oh God he's broken these into separate

2327
01:32:56,600 --> 01:33:02,760
functions that you

2328
01:32:59,440 --> 01:33:06,880
return because Java all right I I'm not

2329
01:33:02,760 --> 01:33:10,560
gonna understand this yeah yeah but so

2330
01:33:06,880 --> 01:33:10,560
he returns a function from get

2331
01:33:14,360 --> 01:33:19,440
rule I I don't know I don't know get

2332
01:33:17,000 --> 01:33:19,440
rule is

2333
01:33:19,679 --> 01:33:25,159
later this looks more complicated at

2334
01:33:21,920 --> 01:33:27,360
than it needs to be honestly but okay

2335
01:33:25,159 --> 01:33:29,199
but but he does talk about it and

2336
01:33:27,360 --> 01:33:30,800
reference it I don't I can't evaluate

2337
01:33:29,199 --> 01:33:32,400
just from a skim how good I think the

2338
01:33:30,800 --> 01:33:35,000
explanation is but the information is

2339
01:33:32,400 --> 01:33:36,440
there and but once again it's not it

2340
01:33:35,000 --> 01:33:38,679
doesn't look like it's explaining it in

2341
01:33:36,440 --> 01:33:40,800
terms of like I really liked your

2342
01:33:38,679 --> 01:33:42,440
explanation of it in terms of like look

2343
01:33:40,800 --> 01:33:43,960
we know that it's either going to be one

2344
01:33:42,440 --> 01:33:45,480
a tree that goes this way or a tree that

2345
01:33:43,960 --> 01:33:47,000
goes that way and all we have to do is

2346
01:33:45,480 --> 01:33:49,600
like alternate between those to get the

2347
01:33:47,000 --> 01:33:50,920
right thing here we go that's a much

2348
01:33:49,600 --> 01:33:53,040
easier way to understand how these

2349
01:33:50,920 --> 01:33:55,080
algorithms work work and so again I

2350
01:33:53,040 --> 01:33:57,360
would say that needs to be kind of front

2351
01:33:55,080 --> 01:33:58,560
and center I think in an explanation

2352
01:33:57,360 --> 01:34:01,040
because a lot of times these things are

2353
01:33:58,560 --> 01:34:02,600
implicit like they don't really like say

2354
01:34:01,040 --> 01:34:05,119
what actually needs to happen for the

2355
01:34:02,600 --> 01:34:07,360
algorithm and it leaves you wondering

2356
01:34:05,119 --> 01:34:09,119
what the algorithms actually does well

2357
01:34:07,360 --> 01:34:13,000
that's that's my big thing that's my

2358
01:34:09,119 --> 01:34:15,119
beef about a lot of things like

2359
01:34:13,000 --> 01:34:18,000
technical writing generally this book by

2360
01:34:15,119 --> 01:34:20,520
the way is sort of this book is I I do

2361
01:34:18,000 --> 01:34:23,480
agree that I don't while skimming see

2362
01:34:20,520 --> 01:34:25,639
and the Deep explanation that I would

2363
01:34:23,480 --> 01:34:27,639
like but maybe it's there and I just

2364
01:34:25,639 --> 01:34:29,639
maybe we spend some more time with it

2365
01:34:27,639 --> 01:34:31,280
yeah not a criticism of this at all but

2366
01:34:29,639 --> 01:34:33,320
more like when you read some of these

2367
01:34:31,280 --> 01:34:35,639
computer science papers right there's

2368
01:34:33,320 --> 01:34:37,920
like an academic computer science voice

2369
01:34:35,639 --> 01:34:39,679
that people have learned to write in

2370
01:34:37,920 --> 01:34:41,239
that is not very much like the voice of

2371
01:34:39,679 --> 01:34:44,239
the great computer science papers by the

2372
01:34:41,239 --> 01:34:46,800
way so right you know think about that

2373
01:34:44,239 --> 01:34:48,760
but it's it's a voice that involves

2374
01:34:46,800 --> 01:34:50,880
trying to sound smart but also not

2375
01:34:48,760 --> 01:34:54,760
explaining things too much and

2376
01:34:50,880 --> 01:34:56,719
especially not explaining um the

2377
01:34:54,760 --> 01:34:58,840
important part the the reason you would

2378
01:34:56,719 --> 01:35:00,639
do something and the context and when

2379
01:34:58,840 --> 01:35:02,520
would you do this and and when might it

2380
01:35:00,639 --> 01:35:04,560
be a better idea to do something else

2381
01:35:02,520 --> 01:35:08,360
right and like all of those that's the

2382
01:35:04,560 --> 01:35:10,119
real information like the algorithm like

2383
01:35:08,360 --> 01:35:11,400
if you have enough context and

2384
01:35:10,119 --> 01:35:13,040
understanding of the problem usually

2385
01:35:11,400 --> 01:35:17,560
algorithms are not that hard especially

2386
01:35:13,040 --> 01:35:20,440
if you have like a hint at what it is um

2387
01:35:17,560 --> 01:35:22,119
but like we we seem to have all this

2388
01:35:20,440 --> 01:35:23,600
writing that's the opposite and that's

2389
01:35:22,119 --> 01:35:25,560
what you know there was this tweet that

2390
01:35:23,600 --> 01:35:28,040
I deleted because I didn't want to

2391
01:35:25,560 --> 01:35:29,880
harass people accidentally but it was

2392
01:35:28,040 --> 01:35:32,080
about that before about that

2393
01:35:29,880 --> 01:35:33,400
probabilistic algorithm book before you

2394
01:35:32,080 --> 01:35:35,639
mention that tweet you should point out

2395
01:35:33,400 --> 01:35:37,600
that like this thankfully this crafting

2396
01:35:35,639 --> 01:35:40,719
interpreters page seems to have be

2397
01:35:37,600 --> 01:35:42,199
written in a much yes nicer fashion

2398
01:35:40,719 --> 01:35:44,159
which is nice like if you look at just

2399
01:35:42,199 --> 01:35:46,159
what's on the screen right now that's

2400
01:35:44,159 --> 01:35:47,480
very human readable right like no one's

2401
01:35:46,159 --> 01:35:49,480
going to be like what the heck is he

2402
01:35:47,480 --> 01:35:51,639
talking about they're they're like oh I

2403
01:35:49,480 --> 01:35:53,119
get it right like okay yeah see what

2404
01:35:51,639 --> 01:35:55,880
he's saying here so that's very

2405
01:35:53,119 --> 01:35:57,960
refreshing as well oh absolutely all in

2406
01:35:55,880 --> 01:36:00,159
favor if you're ever going to explain

2407
01:35:57,960 --> 01:36:02,719
something make it more like this and

2408
01:36:00,159 --> 01:36:05,159
less like whatever random computer

2409
01:36:02,719 --> 01:36:07,560
science paper the gjk paper that's the

2410
01:36:05,159 --> 01:36:09,639
ultimate reference of all time just read

2411
01:36:07,560 --> 01:36:12,360
the gjk paper and if your paper sounds

2412
01:36:09,639 --> 01:36:15,360
anything like that delete the entire

2413
01:36:12,360 --> 01:36:17,239
latch file and make a new one

2414
01:36:15,360 --> 01:36:20,320
yeah

2415
01:36:17,239 --> 01:36:23,080
um yeah okay so the information's in

2416
01:36:20,320 --> 01:36:25,440
there

2417
01:36:23,080 --> 01:36:27,600
someone says Java is asked walk interp

2418
01:36:25,440 --> 01:36:29,760
and C part is bite code inter turp I

2419
01:36:27,600 --> 01:36:35,040
don't know what c part means I guess

2420
01:36:29,760 --> 01:36:35,040
this is in C so they're redoing stuff in

2421
01:36:36,639 --> 01:36:43,360
C I don't know what Java looks like but

2422
01:36:39,080 --> 01:36:46,880
this looks like C to me so yeah um

2423
01:36:43,360 --> 01:36:48,920
anyway yeah the end I think we're out of

2424
01:36:46,880 --> 01:36:51,440
stuff to talk about but it's just yes I

2425
01:36:48,920 --> 01:36:55,400
wanted to do my part to signal boost

2426
01:36:51,440 --> 01:36:58,760
several things one this is very simple

2427
01:36:55,400 --> 01:37:00,440
don't first of all if you understand it

2428
01:36:58,760 --> 01:37:01,800
don't get all high and mighty and try to

2429
01:37:00,440 --> 01:37:05,400
confuse other people about it because

2430
01:37:01,800 --> 01:37:08,159
it's actually pretty simple yep

2431
01:37:05,400 --> 01:37:11,000
two what do we do about this cultural

2432
01:37:08,159 --> 01:37:13,800
problem that we have where if something

2433
01:37:11,000 --> 01:37:15,679
as simple as this still despite these

2434
01:37:13,800 --> 01:37:17,840
other people having done what they can

2435
01:37:15,679 --> 01:37:20,199
to publicize it is still not understood

2436
01:37:17,840 --> 01:37:21,600
by many people right what about the

2437
01:37:20,199 --> 01:37:25,520
things that are actually more

2438
01:37:21,600 --> 01:37:30,440
complicated right what about those

2439
01:37:25,520 --> 01:37:32,520
um I don't know but uh I mean I think

2440
01:37:30,440 --> 01:37:36,119
it's a fitness function problem right

2441
01:37:32,520 --> 01:37:39,480
like currently there is no reinforcement

2442
01:37:36,119 --> 01:37:41,960
function for someone else was able to

2443
01:37:39,480 --> 01:37:45,400
understand it in fact it's somewhat the

2444
01:37:41,960 --> 01:37:47,599
opposite like for academic stuff it's

2445
01:37:45,400 --> 01:37:49,800
probably easier to generate more papers

2446
01:37:47,599 --> 01:37:51,320
the less number of people understand

2447
01:37:49,800 --> 01:37:52,760
what you're talking about because

2448
01:37:51,320 --> 01:37:54,719
they're much less likely to reject it

2449
01:37:52,760 --> 01:37:57,760
from a journal if they don't really know

2450
01:37:54,719 --> 01:37:59,920
what you said exactly right like like if

2451
01:37:57,760 --> 01:38:03,400
you understand something you might

2452
01:37:59,920 --> 01:38:04,880
realize it's not new yes but if you

2453
01:38:03,400 --> 01:38:06,880
don't understand something and it just

2454
01:38:04,880 --> 01:38:08,880
kind of sounds like it's roughly

2455
01:38:06,880 --> 01:38:10,119
something then you'll be like oh yeah

2456
01:38:08,880 --> 01:38:12,320
you should publish that right or

2457
01:38:10,119 --> 01:38:14,480
whatever so I assume that part of the

2458
01:38:12,320 --> 01:38:16,800
problem is that if literally just

2459
01:38:14,480 --> 01:38:19,280
getting papers published is your Fitness

2460
01:38:16,800 --> 01:38:21,280
function you're kind of it this is what

2461
01:38:19,280 --> 01:38:22,960
happened so you just have to stop that

2462
01:38:21,280 --> 01:38:24,440
like the whole idea of like peer rreview

2463
01:38:22,960 --> 01:38:26,320
journals and all that that has to go

2464
01:38:24,440 --> 01:38:28,440
away that was a very bad idea it should

2465
01:38:26,320 --> 01:38:31,440
never have happened and what you should

2466
01:38:28,440 --> 01:38:33,239
be doing is like hey if a particular

2467
01:38:31,440 --> 01:38:35,599
publication is able to actually have

2468
01:38:33,239 --> 01:38:37,599
other people be able to go do something

2469
01:38:35,599 --> 01:38:39,400
with it that is the actual Fitness

2470
01:38:37,599 --> 01:38:41,920
function and how do we get there how do

2471
01:38:39,400 --> 01:38:43,320
we get more towards that right yeah I

2472
01:38:41,920 --> 01:38:46,520
agree with that I I think one other

2473
01:38:43,320 --> 01:38:48,119
thing that happens is a lot of so-called

2474
01:38:46,520 --> 01:38:50,639
algorithms

2475
01:38:48,119 --> 01:38:52,599
right like especially as you get more

2476
01:38:50,639 --> 01:38:54,639
applied and these papers that claim

2477
01:38:52,599 --> 01:38:57,639
performance wins and stuff which are

2478
01:38:54,639 --> 01:39:00,360
usually almost never real

2479
01:38:57,639 --> 01:39:02,320
um garbage collection is faster than man

2480
01:39:00,360 --> 01:39:04,159
manual memory management yeah or or even

2481
01:39:02,320 --> 01:39:07,280
our tweak on garbage collection improves

2482
01:39:04,159 --> 01:39:09,000
it by 13% and it it doesn't really right

2483
01:39:07,280 --> 01:39:11,199
and it also by the way has all these

2484
01:39:09,000 --> 01:39:13,119
pathological cases and stuff and inputs

2485
01:39:11,199 --> 01:39:14,840
we we just wanted to get this paper out

2486
01:39:13,119 --> 01:39:17,560
so we didn't really think about this

2487
01:39:14,840 --> 01:39:19,159
other thing right and it's like these

2488
01:39:17,560 --> 01:39:20,440
papers are full of that stuff and the

2489
01:39:19,159 --> 01:39:21,760
more you understand what they're

2490
01:39:20,440 --> 01:39:24,320
actually saying

2491
01:39:21,760 --> 01:39:25,880
the more you see those holes right

2492
01:39:24,320 --> 01:39:27,080
whereas if you if you don't really

2493
01:39:25,880 --> 01:39:30,920
understand the algorithm and you're just

2494
01:39:27,080 --> 01:39:33,719
like oh yeah yeah looks good right

2495
01:39:30,920 --> 01:39:35,040
um same thing right that that feeds into

2496
01:39:33,719 --> 01:39:37,440
that paper Fitness function thing you

2497
01:39:35,040 --> 01:39:40,840
were talking about um and from a

2498
01:39:37,440 --> 01:39:43,960
slightly different direction so yeah oh

2499
01:39:40,840 --> 01:39:47,040
dude I just I have so much beef about

2500
01:39:43,960 --> 01:39:49,599
computer science papers that claim

2501
01:39:47,040 --> 01:39:52,520
performance improvements it's been it's

2502
01:39:49,599 --> 01:39:54,840
been sadness every time yeah there's

2503
01:39:52,520 --> 01:39:56,679
there's a lot of issues with that most

2504
01:39:54,840 --> 01:39:59,560
computer science papers don't know how

2505
01:39:56,679 --> 01:40:04,199
to measure things so they're very

2506
01:39:59,560 --> 01:40:07,199
suspicious usually yeah um but yeah yeah

2507
01:40:04,199 --> 01:40:09,360
all right so we we have to bring back

2508
01:40:07,199 --> 01:40:11,639
the meme because yeah bring back the

2509
01:40:09,360 --> 01:40:14,040
meme this is what the people want this

2510
01:40:11,639 --> 01:40:15,960
is what the people want this is all so

2511
01:40:14,040 --> 01:40:18,599
the only takeaway that you really need

2512
01:40:15,960 --> 01:40:21,000
from from this stream is this meme yes

2513
01:40:18,599 --> 01:40:23,119
this is what this is about the entire

2514
01:40:21,000 --> 01:40:27,760
intellectual content of this stream

2515
01:40:23,119 --> 01:40:30,280
honestly can I make one can I make one

2516
01:40:27,760 --> 01:40:33,719
change to this meme to make it even more

2517
01:40:30,280 --> 01:40:37,159
awesome yes can the dude in the cloak

2518
01:40:33,719 --> 01:40:37,159
say that's left

2519
01:40:39,480 --> 01:40:45,719
sometimes that might be too smart but

2520
01:40:43,000 --> 01:40:47,880
let's let's do it let's here we go so is

2521
01:40:45,719 --> 01:40:50,920
that that makes it more specific to

2522
01:40:47,880 --> 01:40:53,800
parsing this particular parsing we are

2523
01:40:50,920 --> 01:40:53,800
we are a prompt

2524
01:40:56,400 --> 01:41:00,639
service cuz then it's like almost

2525
01:40:58,520 --> 01:41:02,440
impossible to even understand the meeme

2526
01:41:00,639 --> 01:41:05,719
unless you've seen this

2527
01:41:02,440 --> 01:41:09,119
stream because it won't make any sense

2528
01:41:05,719 --> 01:41:13,080
otherwise so do we want to modify

2529
01:41:09,119 --> 01:41:18,800
this or I think that was fine I'll put a

2530
01:41:13,080 --> 01:41:18,800
one must use ler one

2531
01:41:19,840 --> 01:41:24,800
generator with flex and

2532
01:41:24,960 --> 01:41:30,679
hjs with

2533
01:41:27,159 --> 01:41:32,639
them I mean there was a thing like uh

2534
01:41:30,679 --> 01:41:34,560
this is my only suggestion there that's

2535
01:41:32,639 --> 01:41:38,040
probably what you should put but I

2536
01:41:34,560 --> 01:41:40,760
remember the red dragon edition of the

2537
01:41:38,040 --> 01:41:43,599
book having some garbage on the front

2538
01:41:40,760 --> 01:41:45,760
like lr1 parser generator and syntax

2539
01:41:43,599 --> 01:41:47,679
directed translation can you can you

2540
01:41:45,760 --> 01:41:50,040
just copy what it said and stick it at

2541
01:41:47,679 --> 01:41:53,320
the top there because that is pretty

2542
01:41:50,040 --> 01:41:57,639
close to perfect as well okay okay um

2543
01:41:53,320 --> 01:42:00,960
syntax directed translation to defeat

2544
01:41:57,639 --> 01:42:03,119
the complexity of compiler design that's

2545
01:42:00,960 --> 01:42:04,880
literally what it says it says Okay so

2546
01:42:03,119 --> 01:42:07,239
the dragon this is the new version but

2547
01:42:04,880 --> 01:42:09,199
it's in principle it's a it's like when

2548
01:42:07,239 --> 01:42:11,480
Disney remakes The Lion King in live

2549
01:42:09,199 --> 01:42:15,280
action so all the elements of the scene

2550
01:42:11,480 --> 01:42:18,360
are the same um the dragon is wearing a

2551
01:42:15,280 --> 01:42:22,040
shirt that says complexity of compiler

2552
01:42:18,360 --> 01:42:24,840
design and the sword you can't really

2553
01:42:22,040 --> 01:42:27,320
see it but the sword is the sword of ler

2554
01:42:24,840 --> 01:42:30,000
parser generator you got to get that in

2555
01:42:27,320 --> 01:42:32,400
there and the shield of syntax directed

2556
01:42:30,000 --> 01:42:34,360
translation right yes all of which is

2557
01:42:32,400 --> 01:42:36,040
[ __ ] the one that isn't the one

2558
01:42:34,360 --> 01:42:38,199
phrase on here that isn't [ __ ] is

2559
01:42:36,040 --> 01:42:40,320
complexity of compiler design which is

2560
01:42:38,199 --> 01:42:42,599
true uh which is true but parsing isn't

2561
01:42:40,320 --> 01:42:44,840
the complicated part it's the rest of it

2562
01:42:42,599 --> 01:42:47,840
that's hard

2563
01:42:44,840 --> 01:42:52,760
so

2564
01:42:47,840 --> 01:42:52,760
uh syntax directed translation

2565
01:42:55,679 --> 01:42:59,560
with ler parser

2566
01:43:00,679 --> 01:43:05,400
generator yes it might be a little small

2567
01:43:03,320 --> 01:43:08,159
but yeah

2568
01:43:05,400 --> 01:43:10,920
well what can you do what can you memes

2569
01:43:08,159 --> 01:43:13,560
are this is the complexity of memes all

2570
01:43:10,920 --> 01:43:17,719
right I don't know I think this is as

2571
01:43:13,560 --> 01:43:22,080
high r as it goes yep all right see we

2572
01:43:17,719 --> 01:43:26,440
are we are a full service shop here

2573
01:43:22,080 --> 01:43:28,159
um yeah okay very low res oh it went off

2574
01:43:26,440 --> 01:43:32,040
the

2575
01:43:28,159 --> 01:43:34,599
top no no didn't oh I can't see it I

2576
01:43:32,040 --> 01:43:38,520
can't see the top of the meme am I uh so

2577
01:43:34,599 --> 01:43:41,760
my my OBS may not be oh okay okay no it

2578
01:43:38,520 --> 01:43:43,679
is it is maybe it's Google is not

2579
01:43:41,760 --> 01:43:46,560
showing you it could be Google is

2580
01:43:43,679 --> 01:43:48,760
Googling it as long as as it's visible

2581
01:43:46,560 --> 01:43:50,159
in the real meme I'm fine with it oh now

2582
01:43:48,760 --> 01:43:51,199
I can see it it was just the zoom I

2583
01:43:50,159 --> 01:43:52,960
guess

2584
01:43:51,199 --> 01:43:55,159
was making me not see it well the zoom

2585
01:43:52,960 --> 01:43:58,960
in yeah was cutting off the bottom for

2586
01:43:55,159 --> 01:44:02,199
me so ah okay

2587
01:43:58,960 --> 01:44:02,199
yeah okay

2588
01:44:02,360 --> 01:44:05,639
so that's

2589
01:44:05,719 --> 01:44:09,400
great thanks everybody um we could do

2590
01:44:08,159 --> 01:44:12,080
questions or something if you want to

2591
01:44:09,400 --> 01:44:14,880
hang out otherwise that's that's all I

2592
01:44:12,080 --> 01:44:16,599
want to talk about totally up to you

2593
01:44:14,880 --> 01:44:19,599
does anyone have intelligent questions

2594
01:44:16,599 --> 01:44:21,639
that is worth the time of Casey mtori

2595
01:44:19,599 --> 01:44:24,320
when he could be

2596
01:44:21,639 --> 01:44:26,880
off making new things for his

2597
01:44:24,320 --> 01:44:28,599
substack gallivanting yeah or

2598
01:44:26,880 --> 01:44:31,920
gallivanting or doing both of those

2599
01:44:28,599 --> 01:44:31,920
things simultaneously serious

2600
01:44:40,480 --> 01:44:44,159
questions oh someone is saying the

2601
01:44:42,400 --> 01:44:46,360
crafting interpreter book was in two

2602
01:44:44,159 --> 01:44:48,159
parts part one was in Java and part two

2603
01:44:46,360 --> 01:44:50,400
was in C and so maybe that corresponds

2604
01:44:48,159 --> 01:44:52,199
to The Interpreter and compiler Parts

2605
01:44:50,400 --> 01:44:54,679
but but then online it's all smooshed

2606
01:44:52,199 --> 01:44:56,280
together now that makes more sense I do

2607
01:44:54,679 --> 01:44:57,400
think it it feels like it that when we

2608
01:44:56,280 --> 01:44:58,480
were looking at it I was like this kind

2609
01:44:57,400 --> 01:45:00,440
of feels like a thing that was like it

2610
01:44:58,480 --> 01:45:01,800
was written in various ways and then you

2611
01:45:00,440 --> 01:45:03,840
know assembled and that kind of thing

2612
01:45:01,800 --> 01:45:05,639
always has some rough edges there like

2613
01:45:03,840 --> 01:45:06,800
Mike AB br's books were that way right

2614
01:45:05,639 --> 01:45:08,560
like they were like hey these were

2615
01:45:06,800 --> 01:45:10,159
series of Articles and then we kind of

2616
01:45:08,560 --> 01:45:11,679
reworked them for a book and whatever so

2617
01:45:10,159 --> 01:45:12,840
you kind of get a there's a little bit

2618
01:45:11,679 --> 01:45:15,080
of things where it's like wait why is

2619
01:45:12,840 --> 01:45:17,239
this here or in this spot and it's like

2620
01:45:15,080 --> 01:45:19,840
well you know yeah we're not going to

2621
01:45:17,239 --> 01:45:21,239
rewrite the entire thing to make it flow

2622
01:45:19,840 --> 01:45:24,560
correctly so

2623
01:45:21,239 --> 01:45:26,800
yes so here's a question um are

2624
01:45:24,560 --> 01:45:29,520
parenthesized expressions ever done in

2625
01:45:26,800 --> 01:45:32,000
parse Leaf in my example um so we did

2626
01:45:29,520 --> 01:45:35,760
sort of skip I

2627
01:45:32,000 --> 01:45:37,480
mean it's essentially the same as some

2628
01:45:35,760 --> 01:45:39,440
of these other cases we talked about of

2629
01:45:37,480 --> 01:45:41,000
more complex syntax it's actually it's

2630
01:45:39,440 --> 01:45:43,440
essentially the same as the for Loop

2631
01:45:41,000 --> 01:45:45,920
right so here's the

2632
01:45:43,440 --> 01:45:48,920
thing

2633
01:45:45,920 --> 01:45:51,360
um when you when you

2634
01:45:48,920 --> 01:45:53,440
parse when you're going to par an

2635
01:45:51,360 --> 01:45:56,960
expression let me I've got so many

2636
01:45:53,440 --> 01:46:00,199
versions of this function yeah like when

2637
01:45:56,960 --> 01:46:03,360
you're going to parse an expression um

2638
01:46:00,199 --> 01:46:05,159
you know you parse a leaf here and parse

2639
01:46:03,360 --> 01:46:07,320
Leaf I talked about in the very

2640
01:46:05,159 --> 01:46:09,560
beginning and just ignored it after

2641
01:46:07,320 --> 01:46:12,159
because it's like it's not the point but

2642
01:46:09,560 --> 01:46:14,199
when you're here what this is is just

2643
01:46:12,159 --> 01:46:18,119
looking at the next token and deciding

2644
01:46:14,199 --> 01:46:21,080
what is your value and if instead of a

2645
01:46:18,119 --> 01:46:22,679
three you see an open parentheses

2646
01:46:21,080 --> 01:46:25,560
then right here you just say if it's an

2647
01:46:22,679 --> 01:46:27,400
open parentheses return it's not really

2648
01:46:25,560 --> 01:46:29,599
a leaf because it's a sub expression but

2649
01:46:27,400 --> 01:46:31,719
you just go in right now the way that I

2650
01:46:29,599 --> 01:46:34,520
do un operators I skipped over uni

2651
01:46:31,719 --> 01:46:37,040
operators because it's like it's not

2652
01:46:34,520 --> 01:46:39,960
it's not really worth bothering but I

2653
01:46:37,040 --> 01:46:43,080
just handle them here as well I just say

2654
01:46:39,960 --> 01:46:45,520
if this is a un operator then

2655
01:46:43,080 --> 01:46:48,480
call the

2656
01:46:45,520 --> 01:46:51,000
uh call the parse expression with the

2657
01:46:48,480 --> 01:46:52,800
Precedence of that Unity operator

2658
01:46:51,000 --> 01:46:55,880
and there you go oh that is one

2659
01:46:52,800 --> 01:46:57,520
interesting change or difference between

2660
01:46:55,880 --> 01:46:59,679
the old version of the parser and the

2661
01:46:57,520 --> 01:47:04,679
new one besides getting rid of the tree

2662
01:46:59,679 --> 01:47:06,639
changing code um is before I you know I

2663
01:47:04,679 --> 01:47:08,400
had unit operator precedences for some

2664
01:47:06,639 --> 01:47:10,960
reason although they didn't really do

2665
01:47:08,400 --> 01:47:12,320
anything um and I had binary operator

2666
01:47:10,960 --> 01:47:15,080
precedences but they weren't even on the

2667
01:47:12,320 --> 01:47:18,560
same scale because they didn't likea

2668
01:47:15,080 --> 01:47:20,880
right so you unified them yes um and so

2669
01:47:18,560 --> 01:47:24,159
now they're like they're on the same you

2670
01:47:20,880 --> 01:47:25,760
know ruler and so when you're doing

2671
01:47:24,159 --> 01:47:27,920
things this generally if you don't pass

2672
01:47:25,760 --> 01:47:30,119
in the correct precedence from here

2673
01:47:27,920 --> 01:47:32,400
you'll mess up your your un versus

2674
01:47:30,119 --> 01:47:35,360
binary precedence but but basically

2675
01:47:32,400 --> 01:47:37,440
things either go here or in the parse

2676
01:47:35,360 --> 01:47:38,920
binary and it's like your entire grammar

2677
01:47:37,440 --> 01:47:41,920
you

2678
01:47:38,920 --> 01:47:41,920
know

2679
01:47:42,080 --> 01:47:47,119
okay what about parsing each binary

2680
01:47:44,800 --> 01:47:49,000
operator along with its right operand

2681
01:47:47,119 --> 01:47:51,599
and then just inserting that where it

2682
01:47:49,000 --> 01:47:55,679
fits and then link

2683
01:47:51,599 --> 01:47:55,679
um isn't that sort of what this is

2684
01:47:56,679 --> 01:48:05,119
doing past

2685
01:47:59,960 --> 01:48:08,719
bin uh parse un okay while token is

2686
01:48:05,119 --> 01:48:08,719
binary op parse

2687
01:48:11,119 --> 01:48:15,360
uny this is sort of like the tree

2688
01:48:13,480 --> 01:48:17,280
changing thing I was talking about this

2689
01:48:15,360 --> 01:48:19,840
is like a very compact version of it

2690
01:48:17,280 --> 01:48:22,480
because you're parsing it and then

2691
01:48:19,840 --> 01:48:25,199
you're like changing the links right if

2692
01:48:22,480 --> 01:48:25,199
I'm reading this

2693
01:48:28,400 --> 01:48:33,840
correctly I mean yeah so so hybrid

2694
01:48:31,880 --> 01:48:35,560
approaches between these two things I

2695
01:48:33,840 --> 01:48:37,880
think could work I'm not sure why you

2696
01:48:35,560 --> 01:48:39,400
would do

2697
01:48:37,880 --> 01:48:42,239
that

2698
01:48:39,400 --> 01:48:45,599
um I'm not thinking that hard about like

2699
01:48:42,239 --> 01:48:49,199
you're obviously you're starting at the

2700
01:48:45,599 --> 01:48:52,199
root sorry go ahead well it's

2701
01:48:49,199 --> 01:48:52,199
like

2702
01:48:53,520 --> 01:48:56,920
I don't know maybe this is just another

2703
01:48:54,960 --> 01:48:59,080
way of writing the same Loop but with it

2704
01:48:56,920 --> 01:49:02,400
is like basically this is this is the

2705
01:48:59,080 --> 01:49:04,800
unrec kursiv version of the thing right

2706
01:49:02,400 --> 01:49:08,440
you okay you keep building right leaning

2707
01:49:04,800 --> 01:49:11,480
trees or I should say you keep using the

2708
01:49:08,440 --> 01:49:15,000
right slot yeah you walk down the right

2709
01:49:11,480 --> 01:49:17,440
side until you need to walk down the

2710
01:49:15,000 --> 01:49:21,040
left side but the the only thing that

2711
01:49:17,440 --> 01:49:23,960
suss so I guess when this says part un I

2712
01:49:21,040 --> 01:49:26,840
was assuming that that meant like a un

2713
01:49:23,960 --> 01:49:28,920
operator or a leaf but I guess it means

2714
01:49:26,840 --> 01:49:31,280
an increasing precedence run like I was

2715
01:49:28,920 --> 01:49:33,040
talking about because otherwise why

2716
01:49:31,280 --> 01:49:35,400
would you ever need to cursor more than

2717
01:49:33,040 --> 01:49:38,719
one step or whatever you know that's

2718
01:49:35,400 --> 01:49:42,520
that's what's confusing me about this

2719
01:49:38,719 --> 01:49:45,199
um I don't know anyway um why not do it

2720
01:49:42,520 --> 01:49:47,440
this way I mean sure like if this works

2721
01:49:45,199 --> 01:49:51,119
that's great it's not really in

2722
01:49:47,440 --> 01:49:54,360
principle different um the you know the

2723
01:49:51,119 --> 01:49:56,360
the core idea again to to put it in the

2724
01:49:54,360 --> 01:49:58,920
bell curve meme way the core idea was

2725
01:49:56,360 --> 01:50:01,360
just that you know the default tree

2726
01:49:58,920 --> 01:50:04,480
making that you would do is Right In

2727
01:50:01,360 --> 01:50:07,800
some cases already and then just use

2728
01:50:04,480 --> 01:50:10,280
that to to construct the thing right I

2729
01:50:07,800 --> 01:50:11,960
would say there's one reason like again

2730
01:50:10,280 --> 01:50:13,760
I don't write parsers so I'm just going

2731
01:50:11,960 --> 01:50:15,320
off of what I've heard so far but yeah

2732
01:50:13,760 --> 01:50:18,560
one thing that I that doesn't look great

2733
01:50:15,320 --> 01:50:21,119
about this is effectively this gets

2734
01:50:18,560 --> 01:50:23,679
worse the more you have to do that inner

2735
01:50:21,119 --> 01:50:25,920
while loop so that's very sus I would

2736
01:50:23,679 --> 01:50:27,560
never do that right right so like in in

2737
01:50:25,920 --> 01:50:29,560
the one that John wrote Because You're

2738
01:50:27,560 --> 01:50:32,520
Building it kind of in order from the

2739
01:50:29,560 --> 01:50:34,320
bottom up you don't have that problem

2740
01:50:32,520 --> 01:50:35,920
you're always just going to the right or

2741
01:50:34,320 --> 01:50:38,760
going to the left and you're just doing

2742
01:50:35,920 --> 01:50:41,599
one step yeah or ever yeah this

2743
01:50:38,760 --> 01:50:44,360
version's like well now every time I get

2744
01:50:41,599 --> 01:50:46,000
a new one in I have to chase down to

2745
01:50:44,360 --> 01:50:47,719
find where I would have been when I

2746
01:50:46,000 --> 01:50:49,679
inserted it in John's version so it's

2747
01:50:47,719 --> 01:50:51,360
kind of it by flipping those two it

2748
01:50:49,679 --> 01:50:53,000
feels worse like it feels like this is

2749
01:50:51,360 --> 01:50:55,520
going to be like an N squ kind of a

2750
01:50:53,000 --> 01:50:57,360
thing that could happen if you construct

2751
01:50:55,520 --> 01:50:59,360
a adversarial input sort of thing I

2752
01:50:57,360 --> 01:51:01,199
could be wrong about honestly my my

2753
01:50:59,360 --> 01:51:03,920
brain's tired so I'm not thinking that

2754
01:51:01,199 --> 01:51:06,000
hard about it but um that's my only

2755
01:51:03,920 --> 01:51:08,119
thought does that yeah I mean this this

2756
01:51:06,000 --> 01:51:09,480
while loop I don't like how that looks

2757
01:51:08,119 --> 01:51:12,119
which I think is a summary of what you

2758
01:51:09,480 --> 01:51:13,679
just said um yeah the thing here's a

2759
01:51:12,119 --> 01:51:15,520
thing another thing about computer

2760
01:51:13,679 --> 01:51:17,400
school is they teach you to make trees

2761
01:51:15,520 --> 01:51:20,320
all the time and that navigating trees

2762
01:51:17,400 --> 01:51:22,040
is cool and fun um trees are really bad

2763
01:51:20,320 --> 01:51:23,599
and I want to at some point try to

2764
01:51:22,040 --> 01:51:25,719
figure out a way to make a version of

2765
01:51:23,599 --> 01:51:27,320
our compiler that does not use trees

2766
01:51:25,719 --> 01:51:30,920
it's difficult because they are in

2767
01:51:27,320 --> 01:51:32,920
principle trees in the sense that like

2768
01:51:30,920 --> 01:51:35,320
any recursive data structure is kind of

2769
01:51:32,920 --> 01:51:37,920
a tree sort of I guess because you're

2770
01:51:35,320 --> 01:51:41,400
referring to some other part that may be

2771
01:51:37,920 --> 01:51:42,599
small or it may be quite large um I

2772
01:51:41,400 --> 01:51:46,320
assume that

2773
01:51:42,599 --> 01:51:48,679
rpn kind of the existence of rpn means

2774
01:51:46,320 --> 01:51:51,119
somewhat implicitly that Expressions

2775
01:51:48,679 --> 01:51:53,800
anyway never need to be represented as a

2776
01:51:51,119 --> 01:51:55,400
tree you can just do them right like

2777
01:51:53,800 --> 01:51:57,560
like you you could easily make a

2778
01:51:55,400 --> 01:52:00,320
compiler if only it only ever dealt with

2779
01:51:57,560 --> 01:52:02,760
Expressions you would never have to have

2780
01:52:00,320 --> 01:52:04,760
a tree to get the right answer anyway

2781
01:52:02,760 --> 01:52:09,599
you might want a tree for other reasons

2782
01:52:04,760 --> 01:52:11,360
yes yes um so anyway the the thing about

2783
01:52:09,599 --> 01:52:12,560
like trees are bad for two reasons and I

2784
01:52:11,360 --> 01:52:15,440
think we talked about this a little bit

2785
01:52:12,560 --> 01:52:17,760
before maybe but all my experience since

2786
01:52:15,440 --> 01:52:20,000
then keeps like if I had time I wish I

2787
01:52:17,760 --> 01:52:24,560
had time to think about it right um the

2788
01:52:20,000 --> 01:52:26,599
nodes are really big like the tree for

2789
01:52:24,560 --> 01:52:29,159
this thing or just's take something

2790
01:52:26,599 --> 01:52:31,599
simpler like this is like node for the

2791
01:52:29,159 --> 01:52:34,239
equal node for this node for this node

2792
01:52:31,599 --> 01:52:36,239
for the UN operator maybe we don't have

2793
01:52:34,239 --> 01:52:38,560
statement nodes but some people would

2794
01:52:36,239 --> 01:52:41,400
and like it's like five nodes and they

2795
01:52:38,560 --> 01:52:43,159
all have like the probably the base node

2796
01:52:41,400 --> 01:52:44,679
that describes where they are in the

2797
01:52:43,159 --> 01:52:47,000
program so you can do error reporting

2798
01:52:44,679 --> 01:52:49,560
and all that and like probably some

2799
01:52:47,000 --> 01:52:51,800
stuff that helps link it to the later

2800
01:52:49,560 --> 01:52:55,040
result results of compilation right and

2801
01:52:51,800 --> 01:52:57,719
so like I don't know how big our bass

2802
01:52:55,040 --> 01:53:01,079
note is but it's like 100 bytes I don't

2803
01:52:57,719 --> 01:53:03,480
know it's like it's stupid right and so

2804
01:53:01,079 --> 01:53:07,000
imagine this was 500 characters long

2805
01:53:03,480 --> 01:53:09,960
instead of like 12 or whatever it is 11

2806
01:53:07,000 --> 01:53:14,199
um let me actually count 48 9 10 12 I

2807
01:53:09,960 --> 01:53:16,520
got it right so so that's a factor of 50

2808
01:53:14,199 --> 01:53:20,520
bigger than your Source text and that's

2809
01:53:16,520 --> 01:53:23,000
kind of dumb it just is yeah um and

2810
01:53:20,520 --> 01:53:24,920
I mean Casey probably knows like I'm I'm

2811
01:53:23,000 --> 01:53:28,000
not the most hardcore person about

2812
01:53:24,920 --> 01:53:30,599
optimization because I'm I more prefer

2813
01:53:28,000 --> 01:53:32,800
making functionality work but like I

2814
01:53:30,599 --> 01:53:34,320
don't do stupid slow crap and I don't

2815
01:53:32,800 --> 01:53:36,400
make things way bigger than they need to

2816
01:53:34,320 --> 01:53:38,040
be if it's important and like this is

2817
01:53:36,400 --> 01:53:41,119
really important because we instantiate

2818
01:53:38,040 --> 01:53:43,440
like millions of these nodes right and I

2819
01:53:41,119 --> 01:53:45,520
just it's hard to make them smaller

2820
01:53:43,440 --> 01:53:48,040
while it still I mean there's things I

2821
01:53:45,520 --> 01:53:51,840
could do to reduce a small number of

2822
01:53:48,040 --> 01:53:54,280
bites at great effort right right and

2823
01:53:51,840 --> 01:53:55,440
so yeah I just want to re-envision it at

2824
01:53:54,280 --> 01:53:57,800
some point as something that doesn't use

2825
01:53:55,440 --> 01:53:59,639
trees so the other thing about trees is

2826
01:53:57,800 --> 01:54:01,880
like this looks like a cheap operation

2827
01:53:59,639 --> 01:54:04,400
right but you're going to things that

2828
01:54:01,880 --> 01:54:06,320
might be distant in memory now that's

2829
01:54:04,400 --> 01:54:07,840
less bad here in the middle of a parser

2830
01:54:06,320 --> 01:54:10,440
because you probably just parsed this

2831
01:54:07,840 --> 01:54:12,840
stuff recently and if your allocator is

2832
01:54:10,440 --> 01:54:16,520
not like returning an address that's

2833
01:54:12,840 --> 01:54:20,239
like red mod size of and address space

2834
01:54:16,520 --> 01:54:21,880
you know then um that probably has

2835
01:54:20,239 --> 01:54:23,960
better Behavior right if it gives you

2836
01:54:21,880 --> 01:54:26,840
nodes that are next to each other but

2837
01:54:23,960 --> 01:54:28,360
you're still I mean it's still N squared

2838
01:54:26,840 --> 01:54:30,280
right it's N squared in the length of an

2839
01:54:28,360 --> 01:54:33,000
expression am I wrong about that chat

2840
01:54:30,280 --> 01:54:35,199
like like the the the main problem I see

2841
01:54:33,000 --> 01:54:37,560
with doing it backwards like this is

2842
01:54:35,199 --> 01:54:40,280
just that it's end squared unless I'm

2843
01:54:37,560 --> 01:54:41,760
misreading you maybe I can't see the

2844
01:54:40,280 --> 01:54:44,079
chat right now

2845
01:54:41,760 --> 01:54:45,639
so I don't know what they think but

2846
01:54:44,079 --> 01:54:46,920
that's my gut feeling is that like you

2847
01:54:45,639 --> 01:54:48,960
wouldn't do it this way because it's s

2848
01:54:46,920 --> 01:54:50,599
squared for no reason like no real

2849
01:54:48,960 --> 01:54:51,760
benefit if there was a benefit to it

2850
01:54:50,599 --> 01:54:53,840
maybe you'd say well I'll eat the nend

2851
01:54:51,760 --> 01:54:55,040
squared because you know I know that my

2852
01:54:53,840 --> 01:54:56,079
language you know I'm not trying to make

2853
01:54:55,040 --> 01:54:58,199
a language where you can have

2854
01:54:56,079 --> 01:55:00,480
Expressions that are you know a thousand

2855
01:54:58,199 --> 01:55:02,360
elements long or something which is fine

2856
01:55:00,480 --> 01:55:04,599
but you know it seems like a bad

2857
01:55:02,360 --> 01:55:05,719
decision yeah unless you got something

2858
01:55:04,599 --> 01:55:07,639
from it there there's something

2859
01:55:05,719 --> 01:55:09,800
someone's saying that I want to address

2860
01:55:07,639 --> 01:55:12,880
about this because this is a

2861
01:55:09,800 --> 01:55:17,119
common uh people who know a little bit

2862
01:55:12,880 --> 01:55:20,639
of optimization stuff modern things say

2863
01:55:17,119 --> 01:55:23,599
this and I want to push back on it just

2864
01:55:20,639 --> 01:55:26,400
just again to spread the the knowledge

2865
01:55:23,599 --> 01:55:27,719
so someone is saying someone said hey

2866
01:55:26,400 --> 01:55:28,960
allocating every time you want to create

2867
01:55:27,719 --> 01:55:30,159
a node we'll slow everything down and

2868
01:55:28,960 --> 01:55:32,639
someone else is saying you're Assuming

2869
01:55:30,159 --> 01:55:34,440
he's doing Malik every time he could

2870
01:55:32,639 --> 01:55:35,520
just be doing bump allocation and

2871
01:55:34,440 --> 01:55:36,960
actually I don't see the rest of the

2872
01:55:35,520 --> 01:55:39,119
context of the conversation because

2873
01:55:36,960 --> 01:55:41,480
there's a lot going on so maybe that

2874
01:55:39,119 --> 01:55:44,440
wasn't directly in reference to this but

2875
01:55:41,480 --> 01:55:48,599
if what is meant is it's not that bad to

2876
01:55:44,440 --> 01:55:50,280
do this or even make a tree because

2877
01:55:48,599 --> 01:55:51,800
you're not actually calling Malik it's

2878
01:55:50,280 --> 01:55:54,719
like okay yes it's good that you're not

2879
01:55:51,800 --> 01:55:56,400
calling Malo for every node that's great

2880
01:55:54,719 --> 01:55:59,079
that is a good step to take to make your

2881
01:55:56,400 --> 01:56:01,239
program faster it does not really

2882
01:55:59,079 --> 01:56:04,800
fundamentally solve certain classes of

2883
01:56:01,239 --> 01:56:06,320
problems you're still visiting memory

2884
01:56:04,800 --> 01:56:07,960
that may not be next to each other

2885
01:56:06,320 --> 01:56:08,760
because the reason you have a tree by

2886
01:56:07,960 --> 01:56:11,560
the

2887
01:56:08,760 --> 01:56:13,000
way right in the start we were all doing

2888
01:56:11,560 --> 01:56:14,639
left leaning trees and right leaning

2889
01:56:13,000 --> 01:56:15,960
trees which are pretty linear and so if

2890
01:56:14,639 --> 01:56:18,000
you have something like that that's

2891
01:56:15,960 --> 01:56:19,880
really long and it's all allocated in

2892
01:56:18,000 --> 01:56:22,599
memory from the leaf up or the root down

2893
01:56:19,880 --> 01:56:24,560
or whatever um actually in our case that

2894
01:56:22,599 --> 01:56:26,520
wouldn't have been true cuz like the the

2895
01:56:24,560 --> 01:56:28,679
left child was allocated and then we did

2896
01:56:26,520 --> 01:56:30,280
all the sub stuff and then we came back

2897
01:56:28,679 --> 01:56:32,320
like things may not end up being very

2898
01:56:30,280 --> 01:56:33,800
close to each other in memory actually

2899
01:56:32,320 --> 01:56:35,320
depending on the size of the tree but

2900
01:56:33,800 --> 01:56:37,719
the whole reason you have a tree is

2901
01:56:35,320 --> 01:56:40,320
because the shapes can get more complex

2902
01:56:37,719 --> 01:56:42,880
and then you navigate that more complex

2903
01:56:40,320 --> 01:56:45,239
shape and anytime you navigate a more

2904
01:56:42,880 --> 01:56:47,800
complex shape than that you you're

2905
01:56:45,239 --> 01:56:49,719
Crossing like any link between nodes is

2906
01:56:47,800 --> 01:56:51,199
a link between things that may be

2907
01:56:49,719 --> 01:56:53,360
getting further and further apart in

2908
01:56:51,199 --> 01:56:55,639
time right and

2909
01:56:53,360 --> 01:56:57,520
so on the one hand maybe that's a

2910
01:56:55,639 --> 01:57:00,400
fundamental part of the

2911
01:56:57,520 --> 01:57:02,360
problem but on the other hand you don't

2912
01:57:00,400 --> 01:57:03,880
want to do it more than you have to and

2913
01:57:02,360 --> 01:57:06,119
this looks like more than you have to to

2914
01:57:03,880 --> 01:57:08,639
me right that's what well could we can

2915
01:57:06,119 --> 01:57:09,880
we bring up the um a tangential that can

2916
01:57:08,639 --> 01:57:12,199
we bring up the meme

2917
01:57:09,880 --> 01:57:13,599
again okay which one version one or

2918
01:57:12,199 --> 01:57:15,679
version two version it doesn't matter

2919
01:57:13,599 --> 01:57:18,400
because I just need I just need the

2920
01:57:15,679 --> 01:57:22,960
visual reference

2921
01:57:18,400 --> 01:57:25,199
okay yeah so uh the other thing that you

2922
01:57:22,960 --> 01:57:26,040
could think about with this Meme here is

2923
01:57:25,199 --> 01:57:29,960
that

2924
01:57:26,040 --> 01:57:32,719
like uh on the the the guy who on the

2925
01:57:29,960 --> 01:57:34,800
left would be saying like just call

2926
01:57:32,719 --> 01:57:36,679
malok uh and then the guy in the middle

2927
01:57:34,800 --> 01:57:39,440
would be like you could be using a bump

2928
01:57:36,679 --> 01:57:41,800
allocator right yeah yeah uh and then

2929
01:57:39,440 --> 01:57:45,280
the guy on the right is like but what

2930
01:57:41,800 --> 01:57:47,239
about the page faults because actually

2931
01:57:45,280 --> 01:57:49,960
when you parse something like this even

2932
01:57:47,239 --> 01:57:52,400
if you're using a bump allocator if your

2933
01:57:49,960 --> 01:57:54,880
nodes are all huge you will page fault

2934
01:57:52,400 --> 01:57:56,840
all over the place and it's bad right

2935
01:57:54,880 --> 01:57:59,280
like there's compilers have this really

2936
01:57:56,840 --> 01:58:02,880
bad uh problem that a lot of programs

2937
01:57:59,280 --> 01:58:04,480
don't have uh which is that at startup

2938
01:58:02,880 --> 01:58:05,639
they don't have any memory because why

2939
01:58:04,480 --> 01:58:07,079
would they right you're just cold

2940
01:58:05,639 --> 01:58:09,800
calling them off of the command line

2941
01:58:07,079 --> 01:58:11,560
this is just how we have unfortunately

2942
01:58:09,800 --> 01:58:13,000
designed the execution environment of

2943
01:58:11,560 --> 01:58:14,320
modern Computing not much you can do

2944
01:58:13,000 --> 01:58:15,599
about it people expect to be able to

2945
01:58:14,320 --> 01:58:17,520
call a compiler for command line when

2946
01:58:15,599 --> 01:58:20,239
you do that the compiler doesn't have

2947
01:58:17,520 --> 01:58:22,840
any memory provisioned and so extra bite

2948
01:58:20,239 --> 01:58:24,560
you use is like well I should say every

2949
01:58:22,840 --> 01:58:26,639
extra 4K you use on something like

2950
01:58:24,560 --> 01:58:28,920
Windows is another page fault waiting to

2951
01:58:26,639 --> 01:58:31,320
happen which slows down the runtime of

2952
01:58:28,920 --> 01:58:33,960
your parser so you actually do care

2953
01:58:31,320 --> 01:58:35,719
about the size of things even if you're

2954
01:58:33,960 --> 01:58:37,280
using a bump allocator and think you're

2955
01:58:35,719 --> 01:58:39,800
not paying very much for allocation you

2956
01:58:37,280 --> 01:58:42,719
probably actually are in this particular

2957
01:58:39,800 --> 01:58:44,199
case yeah I told Casey this before um

2958
01:58:42,719 --> 01:58:46,520
and I think it sparked some of the

2959
01:58:44,199 --> 01:58:48,280
experiments he did but um it did

2960
01:58:46,520 --> 01:58:49,679
actually last time we measured it which

2961
01:58:48,280 --> 01:58:52,400
was a while ago and we haven't measured

2962
01:58:49,679 --> 01:58:54,440
it again since then but like 12% of our

2963
01:58:52,400 --> 01:58:57,760
runtime was just getting memory from the

2964
01:58:54,440 --> 01:58:59,480
operating system like it was a lot you

2965
01:58:57,760 --> 01:59:01,000
know like 12% when you're trying to

2966
01:58:59,480 --> 01:59:03,719
speed something up if you could make it

2967
01:59:01,000 --> 01:59:05,440
12% faster you're really happy if it's

2968
01:59:03,719 --> 01:59:08,960
already fast yeah if it was already a

2969
01:59:05,440 --> 01:59:13,560
reasonable program yeah yeah and and so

2970
01:59:08,960 --> 01:59:16,360
yeah it's just these things are problems

2971
01:59:13,560 --> 01:59:17,960
yeah uh someone says in a compiler I'm

2972
01:59:16,360 --> 01:59:20,159
working on I noticed in my code that I

2973
01:59:17,960 --> 01:59:22,440
only do depth first reverse

2974
01:59:20,159 --> 01:59:25,599
so I just linearized the tree into an

2975
01:59:22,440 --> 01:59:27,520
array of nodes in depth first order um

2976
01:59:25,599 --> 01:59:31,880
that's what you do too John isn't it

2977
01:59:27,520 --> 01:59:33,920
sort of in your compiler um kind of yeah

2978
01:59:31,880 --> 01:59:36,480
okay I

2979
01:59:33,920 --> 01:59:38,040
mean I still have the nodes I still have

2980
01:59:36,480 --> 01:59:41,000
the tree structure and sometimes I need

2981
01:59:38,040 --> 01:59:43,599
to ask what's the child doing right now

2982
01:59:41,000 --> 01:59:45,880
but I do I do linearize the nodes it's

2983
01:59:43,599 --> 01:59:49,360
for a little bit of a different purpose

2984
01:59:45,880 --> 01:59:51,360
which um which is about being able to

2985
01:59:49,360 --> 01:59:53,079
stop compilation and resume you know

2986
01:59:51,360 --> 01:59:57,000
because an identifier isn't ready or

2987
01:59:53,079 --> 01:59:59,199
something um you know now that

2988
01:59:57,000 --> 02:00:02,040
said the thing I've been thinking lately

2989
01:59:59,199 --> 02:00:04,560
is I do that I actually I used to do it

2990
02:00:02,040 --> 02:00:06,040
just by literally linearizing the nodes

2991
02:00:04,560 --> 02:00:09,320
like having a big array of all the

2992
02:00:06,040 --> 02:00:11,679
pointers and then then then I was

2993
02:00:09,320 --> 02:00:13,639
like you know that's kind of maybe too

2994
02:00:11,679 --> 02:00:15,400
dumb and you can imagine pathological

2995
02:00:13,639 --> 02:00:18,760
cases where you just allocate a giant

2996
02:00:15,400 --> 02:00:20,239
ass array that is not helpful so I went

2997
02:00:18,760 --> 02:00:23,000
to something that's a little bit more of

2998
02:00:20,239 --> 02:00:25,440
like a stack thing where you push

2999
02:00:23,000 --> 02:00:26,800
something on and then it expands its

3000
02:00:25,440 --> 02:00:28,239
children onto the stack and then you

3001
02:00:26,800 --> 02:00:32,119
visit them so it has a much smaller

3002
02:00:28,239 --> 02:00:34,440
memory footprint and it's way slower so

3003
02:00:32,119 --> 02:00:36,760
um but it was it took like a painful

3004
02:00:34,440 --> 02:00:38,560
week of stuff to do that conversion

3005
02:00:36,760 --> 02:00:40,239
because the a lot of the compiler is

3006
02:00:38,560 --> 02:00:42,520
about what can we compile right now and

3007
02:00:40,239 --> 02:00:44,840
it's all intimately related to that

3008
02:00:42,520 --> 02:00:46,800
structure yeah um actually and then

3009
02:00:44,840 --> 02:00:48,520
there's other system like while you have

3010
02:00:46,800 --> 02:00:51,480
that information there's other systems

3011
02:00:48,520 --> 02:00:53,840
that we're using it you know and it was

3012
02:00:51,480 --> 02:00:56,520
just really I was supposed to be

3013
02:00:53,840 --> 02:00:58,560
enjoying a vacation in Hawaii and I was

3014
02:00:56,520 --> 02:01:02,320
painfully actually no that wasn't quite

3015
02:00:58,560 --> 02:01:04,639
what this was but you know

3016
02:01:02,320 --> 02:01:06,880
um so I want to go back to maybe

3017
02:01:04,639 --> 02:01:09,639
something that's more linearized but the

3018
02:01:06,880 --> 02:01:11,239
the real observation to make is you know

3019
02:01:09,639 --> 02:01:13,679
maybe a lot of

3020
02:01:11,239 --> 02:01:15,520
things a lot of things are guaranteed to

3021
02:01:13,679 --> 02:01:17,480
actually compile if you have the leaves

3022
02:01:15,520 --> 02:01:19,599
right so the main thing that that might

3023
02:01:17,480 --> 02:01:20,960
not be ready to compile is an identif

3024
02:01:19,599 --> 02:01:24,360
right that just refers to something in

3025
02:01:20,960 --> 02:01:27,000
your program uh a stru d reference right

3026
02:01:24,360 --> 02:01:30,760
a DOT operator similarly you might not

3027
02:01:27,000 --> 02:01:33,400
know the struct yet but beyond that it's

3028
02:01:30,760 --> 02:01:35,079
like eh like what are what's the problem

3029
02:01:33,400 --> 02:01:37,079
really and so you could imagine

3030
02:01:35,079 --> 02:01:38,920
linearizing only those things and then

3031
02:01:37,079 --> 02:01:41,000
because identifiers get like look just

3032
02:01:38,920 --> 02:01:43,760
look at this right how many times do we

3033
02:01:41,000 --> 02:01:45,480
use the word next here um the way we do

3034
02:01:43,760 --> 02:01:47,239
it and the way basically everybody does

3035
02:01:45,480 --> 02:01:49,800
it that's six different identifiers with

3036
02:01:47,239 --> 02:01:51,480
the word next in it and the way I

3037
02:01:49,800 --> 02:01:53,159
linearize my thing those are at

3038
02:01:51,480 --> 02:01:57,520
arbitrary

3039
02:01:53,159 --> 02:01:59,040
positions throughout um this array among

3040
02:01:57,520 --> 02:02:00,400
the other nodes because it's just I walk

3041
02:01:59,040 --> 02:02:01,239
the tree and get the leaves and put them

3042
02:02:00,400 --> 02:02:03,760
in

3043
02:02:01,239 --> 02:02:05,840
right if you were just were saying these

3044
02:02:03,760 --> 02:02:07,800
are the identifiers we need before we

3045
02:02:05,840 --> 02:02:10,360
can proceed because that's the thing

3046
02:02:07,800 --> 02:02:12,040
you're most common to block on and then

3047
02:02:10,360 --> 02:02:13,599
if you're only worried about those you

3048
02:02:12,040 --> 02:02:15,840
could have a much tighter Loop that's

3049
02:02:13,599 --> 02:02:17,920
just like looking up names and only

3050
02:02:15,840 --> 02:02:19,800
concerned with those data structures

3051
02:02:17,920 --> 02:02:22,320
then you might notice that you asked for

3052
02:02:19,800 --> 02:02:23,800
the same thing six times because it's

3053
02:02:22,320 --> 02:02:27,040
much closer together and you're like oh

3054
02:02:23,800 --> 02:02:28,159
yeah there only needs to be one right um

3055
02:02:27,040 --> 02:02:29,840
so there's probably a lot of

3056
02:02:28,159 --> 02:02:32,119
efficiencies that could happen that way

3057
02:02:29,840 --> 02:02:34,440
but it is it's a large structural change

3058
02:02:32,119 --> 02:02:36,320
and so I just haven't wanted to do it

3059
02:02:34,440 --> 02:02:40,679
yet

3060
02:02:36,320 --> 02:02:44,560
um yeah someday I just bra anniversary

3061
02:02:40,679 --> 02:02:46,079
edition is coming out on April 30th and

3062
02:02:44,560 --> 02:02:48,520
part of the reason it is coming out at

3063
02:02:46,079 --> 02:02:52,079
that time is that I'm not rewriting the

3064
02:02:48,520 --> 02:02:55,800
core of the the compiler at

3065
02:02:52,079 --> 02:02:59,239
all um do you store additional for later

3066
02:02:55,800 --> 02:03:01,159
phases in syntax tree what's your

3067
02:02:59,239 --> 02:03:02,199
opinion on having multiple internal

3068
02:03:01,159 --> 02:03:04,239
representations for different

3069
02:03:02,199 --> 02:03:06,800
compilation steps this is something

3070
02:03:04,239 --> 02:03:09,520
where so I'm very contrarian by Nature

3071
02:03:06,800 --> 02:03:11,119
so when I do something I tend to do the

3072
02:03:09,520 --> 02:03:14,520
opposite of the Dragon book right or

3073
02:03:11,119 --> 02:03:16,639
whatever and compiler education loves

3074
02:03:14,520 --> 02:03:20,360
making a new representation for your

3075
02:03:16,639 --> 02:03:22,639
program to do a pass on it right like

3076
02:03:20,360 --> 02:03:25,679
Hey we're going to make we've got our

3077
02:03:22,639 --> 02:03:29,400
syntax tree now we're going to make a a

3078
02:03:25,679 --> 02:03:31,639
control flow graph so that you can

3079
02:03:29,400 --> 02:03:33,280
decide where the program goes or

3080
02:03:31,639 --> 02:03:35,400
whatever and then we'll make a different

3081
02:03:33,280 --> 02:03:37,920
thing out of that and all this and

3082
02:03:35,400 --> 02:03:41,079
actually one of the um God I'm blanking

3083
02:03:37,920 --> 02:03:45,679
on his name because again I'm old uh

3084
02:03:41,079 --> 02:03:47,280
Cliff click who runs a a coffee compiler

3085
02:03:45,679 --> 02:03:50,199
Club

3086
02:03:47,280 --> 02:03:51,760
stream uh I think it's mostly for his

3087
02:03:50,199 --> 02:03:53,199
it's really it's sort of for anyone who

3088
02:03:51,760 --> 02:03:56,159
wants to talk about compilers but it

3089
02:03:53,199 --> 02:03:57,840
ends up the more motivated people doing

3090
02:03:56,159 --> 02:03:59,239
the most work end up being the topic of

3091
02:03:57,840 --> 02:04:03,480
conversation and it's so it's usually

3092
02:03:59,239 --> 02:04:05,800
his compiler right um but he actually

3093
02:04:03,480 --> 02:04:08,480
again there's this weird thing where

3094
02:04:05,800 --> 02:04:10,199
really good basic points sometimes get

3095
02:04:08,480 --> 02:04:13,199
conflated with other things so he has a

3096
02:04:10,199 --> 02:04:15,520
paper called sea of nodes which is about

3097
02:04:13,199 --> 02:04:19,639
a different representation that's not

3098
02:04:15,520 --> 02:04:22,159
exactly as tree like I guess it's still

3099
02:04:19,639 --> 02:04:25,040
right maybe it is a tree I don't I don't

3100
02:04:22,159 --> 02:04:27,440
even remember um well it's a c according

3101
02:04:25,040 --> 02:04:30,239
to the title but it's not it's not a a

3102
02:04:27,440 --> 02:04:34,360
more extremely hierarchical thing but

3103
02:04:30,239 --> 02:04:35,760
the actual very good takeaway to take

3104
02:04:34,360 --> 02:04:38,360
from that even if you don't want to use

3105
02:04:35,760 --> 02:04:41,480
that representation is that when you're

3106
02:04:38,360 --> 02:04:44,000
going to compute something like um you

3107
02:04:41,480 --> 02:04:46,480
know to do control flow or data flow

3108
02:04:44,000 --> 02:04:49,320
analysis you need to know some things

3109
02:04:46,480 --> 02:04:51,719
like what code could bring Branch to

3110
02:04:49,320 --> 02:04:53,480
this point right where where can we go

3111
02:04:51,719 --> 02:04:56,000
after this right and that makes up the

3112
02:04:53,480 --> 02:04:58,360
control flow graph and the data flow

3113
02:04:56,000 --> 02:05:00,119
graph is like that for you know value

3114
02:04:58,360 --> 02:05:03,239
numbers or whatever your representation

3115
02:05:00,119 --> 02:05:05,079
is of of what variables could be right

3116
02:05:03,239 --> 02:05:07,800
and all of the way the way this is

3117
02:05:05,079 --> 02:05:11,400
always taught is you start with a syntax

3118
02:05:07,800 --> 02:05:14,280
tree that just exists it's just out in

3119
02:05:11,400 --> 02:05:16,040
The Ether it is a primordial syntax tree

3120
02:05:14,280 --> 02:05:19,599
and then you Traverse the syntax tree

3121
02:05:16,040 --> 02:05:22,119
and you do analysis on it to build these

3122
02:05:19,599 --> 02:05:24,719
other graphs and the point is that's

3123
02:05:22,119 --> 02:05:27,559
really stupid because for

3124
02:05:24,719 --> 02:05:29,559
example um actually I said syntax tree

3125
02:05:27,559 --> 02:05:31,639
but often it's later often it's like

3126
02:05:29,559 --> 02:05:33,000
semantic you've done like some type

3127
02:05:31,639 --> 02:05:34,360
checking and stuff so you know what the

3128
02:05:33,000 --> 02:05:37,559
things are right but it's still in a

3129
02:05:34,360 --> 02:05:38,880
tree it I I tend to conflate these to go

3130
02:05:37,559 --> 02:05:41,199
back to the original question for a

3131
02:05:38,880 --> 02:05:43,880
second because we do literally put

3132
02:05:41,199 --> 02:05:46,159
everything on the syntax tree node all

3133
02:05:43,880 --> 02:05:48,360
the later information of of compilation

3134
02:05:46,159 --> 02:05:52,400
goes on there as well there's some ways

3135
02:05:48,360 --> 02:05:53,880
in which that's bad um actually to

3136
02:05:52,400 --> 02:05:56,000
finish answering that part of the

3137
02:05:53,880 --> 02:05:58,880
question

3138
02:05:56,000 --> 02:06:01,400
um I guess I just did like the reason I

3139
02:05:58,880 --> 02:06:03,520
did that is because I just wanted to be

3140
02:06:01,400 --> 02:06:06,000
the polar like I didn't want 17

3141
02:06:03,520 --> 02:06:07,880
different trees a that's complicated B

3142
02:06:06,000 --> 02:06:09,400
it's really slow you're copying all your

3143
02:06:07,880 --> 02:06:11,679
data all these times and I'm like I want

3144
02:06:09,400 --> 02:06:15,320
my compiler to be fast so we're just G

3145
02:06:11,679 --> 02:06:17,679
to do as little as we have to to do the

3146
02:06:15,320 --> 02:06:22,040
work right like that's that should be

3147
02:06:17,679 --> 02:06:23,719
for a modern programmer who wants to be

3148
02:06:22,040 --> 02:06:27,119
way better than the average programmer

3149
02:06:23,719 --> 02:06:28,079
in 2024 theistic you should have is that

3150
02:06:27,119 --> 02:06:30,639
you

3151
02:06:28,079 --> 02:06:32,119
do what you need in order you need to

3152
02:06:30,639 --> 02:06:34,400
have a

3153
02:06:32,119 --> 02:06:36,599
clear uh picture of the problem which

3154
02:06:34,400 --> 02:06:40,000
sometimes is very difficult and then you

3155
02:06:36,599 --> 02:06:41,800
just do as little as you need to to

3156
02:06:40,000 --> 02:06:43,639
solve that specific problem that should

3157
02:06:41,800 --> 02:06:44,840
be your first step then once you have

3158
02:06:43,639 --> 02:06:46,840
that

3159
02:06:44,840 --> 02:06:48,800
program you might analyze the

3160
02:06:46,840 --> 02:06:49,920
performance and say oh I didn't real I

3161
02:06:48,800 --> 02:06:51,320
mean if you realize it's going to be

3162
02:06:49,920 --> 02:06:53,040
slow don't do it that way but if you

3163
02:06:51,320 --> 02:06:55,320
didn't realize and then you run it on

3164
02:06:53,040 --> 02:06:56,599
real world data you have some

3165
02:06:55,320 --> 02:06:59,840
information that helps you make it

3166
02:06:56,599 --> 02:07:02,040
better that's all great but like there's

3167
02:06:59,840 --> 02:07:05,520
there's this Cult of complexity in the

3168
02:07:02,040 --> 02:07:07,920
education system for computer science

3169
02:07:05,520 --> 02:07:09,440
it's just like [ __ ] yeah dude 17 trees

3170
02:07:07,920 --> 02:07:10,719
it's awesome right you're being a

3171
02:07:09,440 --> 02:07:14,040
computer scientist when you make all

3172
02:07:10,719 --> 02:07:16,480
these trees and it's like I think the

3173
02:07:14,040 --> 02:07:19,040
thing is John on that that the cover of

3174
02:07:16,480 --> 02:07:21,239
the compiler book there yeah where it

3175
02:07:19,040 --> 02:07:23,880
shows where it where it helpfully has

3176
02:07:21,239 --> 02:07:25,400
the P the different words on the various

3177
02:07:23,880 --> 02:07:27,559
parts of the metaphor so that you're not

3178
02:07:25,400 --> 02:07:28,960
confused about what the metaphor is a

3179
02:07:27,559 --> 02:07:30,360
lot of people don't know this but

3180
02:07:28,960 --> 02:07:32,800
because you can't see it but on the

3181
02:07:30,360 --> 02:07:37,320
night's underwear underneath his armor

3182
02:07:32,800 --> 02:07:37,320
it does say [ __ ] ton of intermediate

3183
02:07:37,639 --> 02:07:42,559
representations that's another tool that

3184
02:07:39,880 --> 02:07:45,480
they use in that book to slay the dragon

3185
02:07:42,559 --> 02:07:48,360
of compiler complexity of complexity yes

3186
02:07:45,480 --> 02:07:50,280
it's by having like 12 different IRS

3187
02:07:48,360 --> 02:07:52,320
yeah for every possible thing you might

3188
02:07:50,280 --> 02:07:53,679
do but okay so so to get back to the

3189
02:07:52,320 --> 02:07:55,639
point that Cliff makes very well which

3190
02:07:53,679 --> 02:07:57,320
is an important point which also needs

3191
02:07:55,639 --> 02:07:59,639
to be signal

3192
02:07:57,320 --> 02:08:02,000
boosted just in the same way we said

3193
02:07:59,639 --> 02:08:03,520
parsing precedence is simple a lot of

3194
02:08:02,000 --> 02:08:04,639
stuff about compilers is simple and

3195
02:08:03,520 --> 02:08:07,440
again it's important because some of

3196
02:08:04,639 --> 02:08:09,280
it's really complicated and hard so we

3197
02:08:07,440 --> 02:08:11,559
need to identify the simple

3198
02:08:09,280 --> 02:08:14,000
things and just understand how simple

3199
02:08:11,559 --> 02:08:15,800
they are so all this construction of

3200
02:08:14,000 --> 02:08:17,440
control flow graphs and data flow graphs

3201
02:08:15,800 --> 02:08:19,880
and the algorithms they give

3202
02:08:17,440 --> 02:08:21,440
you are only

3203
02:08:19,880 --> 02:08:23,840
necessary

3204
02:08:21,440 --> 02:08:26,159
because you didn't have any information

3205
02:08:23,840 --> 02:08:27,480
about this tree that you got at the

3206
02:08:26,159 --> 02:08:29,599
start because that's how the algorithm

3207
02:08:27,480 --> 02:08:32,159
is written in reality and we do this

3208
02:08:29,599 --> 02:08:34,159
actually when we do our control flow

3209
02:08:32,159 --> 02:08:36,559
representation it's not really a graph

3210
02:08:34,159 --> 02:08:39,440
it's like an array of like some values

3211
02:08:36,559 --> 02:08:43,320
right

3212
02:08:39,440 --> 02:08:45,639
um like for example you have a for Loop

3213
02:08:43,320 --> 02:08:48,239
right this comes through in our compiler

3214
02:08:45,639 --> 02:08:50,880
it's one node you've got a child that's

3215
02:08:48,239 --> 02:08:53,040
like the condition right and then the

3216
02:08:50,880 --> 02:08:54,760
then block and the else block and then

3217
02:08:53,040 --> 02:08:56,520
maybe some other modifiers are on this

3218
02:08:54,760 --> 02:08:58,679
node and we've done all the type

3219
02:08:56,520 --> 02:09:00,840
checking so we know the variables are

3220
02:08:58,679 --> 02:09:03,159
valid we know what type they are we

3221
02:09:00,840 --> 02:09:04,840
actually do some more complex things

3222
02:09:03,159 --> 02:09:06,920
where we allow you to overload for Loops

3223
02:09:04,840 --> 02:09:09,520
for data structures right and so we know

3224
02:09:06,920 --> 02:09:10,840
if that's happening or not then it's

3225
02:09:09,520 --> 02:09:12,719
time to Output the code and what does

3226
02:09:10,840 --> 02:09:14,639
that look like actually let's take an if

3227
02:09:12,719 --> 02:09:18,079
statement if statement is even simpler

3228
02:09:14,639 --> 02:09:21,079
it's the simplest one sorry if statement

3229
02:09:18,079 --> 02:09:23,880
so you parse it keyword if in C there's

3230
02:09:21,079 --> 02:09:25,559
paren whatever you parse those there's a

3231
02:09:23,880 --> 02:09:27,960
condition child and then there's a then

3232
02:09:25,559 --> 02:09:30,400
block sorry I said then block and else

3233
02:09:27,960 --> 02:09:33,440
block for the for loop it's like I've

3234
02:09:30,400 --> 02:09:35,960
been playing too many video games um for

3235
02:09:33,440 --> 02:09:38,760
Loop sorry we don't do else blocks

3236
02:09:35,960 --> 02:09:41,040
python does or whatever we just have a

3237
02:09:38,760 --> 02:09:43,880
body of the for Loop for if statement

3238
02:09:41,040 --> 02:09:46,000
condition then block else block we know

3239
02:09:43,880 --> 02:09:48,360
everything about them and then it's time

3240
02:09:46,000 --> 02:09:51,159
to start generating code which is when

3241
02:09:48,360 --> 02:09:54,679
what you need control flow and data flow

3242
02:09:51,159 --> 02:09:56,800
information for right um you actually

3243
02:09:54,679 --> 02:09:58,079
don't really need data flow information

3244
02:09:56,800 --> 02:10:00,040
unless you're going to optimize or

3245
02:09:58,079 --> 02:10:02,400
control flow information this is all

3246
02:10:00,040 --> 02:10:03,760
only about optimization which I don't

3247
02:10:02,400 --> 02:10:06,440
even know if they really tell you that

3248
02:10:03,760 --> 02:10:07,679
in that book um okay you sort of need

3249
02:10:06,440 --> 02:10:10,000
control flow information just to

3250
02:10:07,679 --> 02:10:12,040
generate the code at all though right

3251
02:10:10,000 --> 02:10:13,400
not really I mean you need jumps and

3252
02:10:12,040 --> 02:10:17,760
stuff I mean you

3253
02:10:13,400 --> 02:10:19,000
need you need to to know the jump Target

3254
02:10:17,760 --> 02:10:21,639
yeah yeah

3255
02:10:19,000 --> 02:10:23,559
that's not that's not control flow

3256
02:10:21,639 --> 02:10:27,040
because that that exists that exists in

3257
02:10:23,559 --> 02:10:29,800
an isolation like

3258
02:10:27,040 --> 02:10:33,320
okay yeah

3259
02:10:29,800 --> 02:10:36,679
um anyway

3260
02:10:33,320 --> 02:10:38,760
uh so my point is just the point that

3261
02:10:36,679 --> 02:10:42,000
Cliff makes which is very simple

3262
02:10:38,760 --> 02:10:43,800
is um you've got what's called a basic

3263
02:10:42,000 --> 02:10:45,360
block in compilers this is another

3264
02:10:43,800 --> 02:10:47,760
concept that I wouldn't really argue

3265
02:10:45,360 --> 02:10:48,800
with a basic block is just some

3266
02:10:47,760 --> 02:10:50,079
statements

3267
02:10:48,800 --> 02:10:51,199
where if any of them are going to run

3268
02:10:50,079 --> 02:10:53,760
they're all going to run because there's

3269
02:10:51,199 --> 02:10:54,760
no branches or whatever actually there's

3270
02:10:53,760 --> 02:10:57,119
different kind

3271
02:10:54,760 --> 02:10:58,760
of sometimes you could Branch out of a

3272
02:10:57,119 --> 02:11:00,280
basic block and you call that a basic

3273
02:10:58,760 --> 02:11:04,040
block sometimes you

3274
02:11:00,280 --> 02:11:08,040
have a minimal basic block versus a

3275
02:11:04,040 --> 02:11:09,880
whatever basic I don't know anyway I for

3276
02:11:08,040 --> 02:11:12,440
mine again in in the pursuit of

3277
02:11:09,880 --> 02:11:14,119
Simplicity a basic block for me is you

3278
02:11:12,440 --> 02:11:15,400
can't Branch into the middle anywhere

3279
02:11:14,119 --> 02:11:16,920
but you could leave if you want you

3280
02:11:15,400 --> 02:11:19,239
could leave early

3281
02:11:16,920 --> 02:11:20,719
right okay

3282
02:11:19,239 --> 02:11:22,559
you're generating your bite code or

3283
02:11:20,719 --> 02:11:24,559
whatever representation for your if

3284
02:11:22,559 --> 02:11:26,840
statement you're going to Output the

3285
02:11:24,559 --> 02:11:28,320
condition no matter what because you

3286
02:11:26,840 --> 02:11:31,159
can't do anything till you know so you

3287
02:11:28,320 --> 02:11:32,719
just that's in your same basic block as

3288
02:11:31,159 --> 02:11:34,320
whatever the code was before the if

3289
02:11:32,719 --> 02:11:36,559
statement you start outputting the

3290
02:11:34,320 --> 02:11:38,760
condition and then you're going to

3291
02:11:36,559 --> 02:11:42,000
Branch somewhere right and you're going

3292
02:11:38,760 --> 02:11:45,159
to Branch to the then block or the else

3293
02:11:42,000 --> 02:11:48,159
block instead of

3294
02:11:45,159 --> 02:11:50,400
just making some tree and then later

3295
02:11:48,159 --> 02:11:53,320
running analysis on the

3296
02:11:50,400 --> 02:11:55,159
tree you know because it's an if

3297
02:11:53,320 --> 02:11:57,159
statement okay we're about to make two

3298
02:11:55,159 --> 02:11:59,360
new blocks the then block and the else

3299
02:11:57,159 --> 02:12:04,360
block okay those are basic

3300
02:11:59,360 --> 02:12:06,280
blocks um I think in C isn't this this

3301
02:12:04,360 --> 02:12:10,760
block in C the term for like a curly

3302
02:12:06,280 --> 02:12:13,199
BRAC and whatever I think so it could be

3303
02:12:10,760 --> 02:12:15,280
confusing this is just a basic block

3304
02:12:13,199 --> 02:12:17,079
means a very specific thing in compiler

3305
02:12:15,280 --> 02:12:20,199
stuff

3306
02:12:17,079 --> 02:12:23,920
um a block in C could be composed of

3307
02:12:20,199 --> 02:12:26,760
many basic blocks right um

3308
02:12:23,920 --> 02:12:29,159
so you have a then block you have an

3309
02:12:26,760 --> 02:12:30,679
else block so you do the condition and

3310
02:12:29,159 --> 02:12:32,159
then how do you write this if you're

3311
02:12:30,679 --> 02:12:34,840
writing your own pseudo machine code

3312
02:12:32,159 --> 02:12:37,679
it's like well if the condition is

3313
02:12:34,840 --> 02:12:39,599
true well if it's if it's false we jump

3314
02:12:37,679 --> 02:12:41,040
over the then block to the else block

3315
02:12:39,599 --> 02:12:42,800
right and then at the bottom of the then

3316
02:12:41,040 --> 02:12:45,960
block we jump over the else block to

3317
02:12:42,800 --> 02:12:47,320
like whatever's afterward right and so

3318
02:12:45,960 --> 02:12:48,679
because you're not allowed to jump into

3319
02:12:47,320 --> 02:12:50,119
a basic block

3320
02:12:48,679 --> 02:12:51,760
when you make a then block that's a new

3321
02:12:50,119 --> 02:12:52,639
basic block from the one that had the

3322
02:12:51,760 --> 02:12:55,400
condition in it and when you make the

3323
02:12:52,639 --> 02:12:58,840
else block that's a new basic block but

3324
02:12:55,400 --> 02:12:59,599
you know you know what the parent is and

3325
02:12:58,840 --> 02:13:01,639
you

3326
02:12:59,599 --> 02:13:04,840
know

3327
02:13:01,639 --> 02:13:07,719
um you know they're

3328
02:13:04,840 --> 02:13:09,239
uh you know any any childs of these

3329
02:13:07,719 --> 02:13:12,880
blocks are going to be determined by

3330
02:13:09,239 --> 02:13:15,280
recursive code generation and so like

3331
02:13:12,880 --> 02:13:18,280
there is no analysis step to create the

3332
02:13:15,280 --> 02:13:20,000
tree is the point like or what ever

3333
02:13:18,280 --> 02:13:21,880
whatever your representation is at every

3334
02:13:20,000 --> 02:13:26,119
step because you know the functionality

3335
02:13:21,880 --> 02:13:29,960
of the node you just do it you just say

3336
02:13:26,119 --> 02:13:31,920
oh um you know add these to the

3337
02:13:29,960 --> 02:13:34,000
successor list because we created the

3338
02:13:31,920 --> 02:13:36,199
blocks when we're processing the if

3339
02:13:34,000 --> 02:13:40,040
statement so all these algorithms for

3340
02:13:36,199 --> 02:13:42,599
like walking over a tree to do this and

3341
02:13:40,040 --> 02:13:44,480
to find like the dominating well I don't

3342
02:13:42,599 --> 02:13:48,119
know maybe dominating Frontier still

3343
02:13:44,480 --> 02:13:50,760
exists but most of the creation of the

3344
02:13:48,119 --> 02:13:51,920
thing is literally just the code that

3345
02:13:50,760 --> 02:13:55,199
you would

3346
02:13:51,920 --> 02:13:57,000
type to record something in the data

3347
02:13:55,199 --> 02:13:59,719
structure of your choice like that is

3348
02:13:57,000 --> 02:14:01,719
literally what it is it's insane right

3349
02:13:59,719 --> 02:14:06,040
and people just write tons of papers and

3350
02:14:01,719 --> 02:14:07,960
books about it it's nutballs um again

3351
02:14:06,040 --> 02:14:09,520
it's actually very similar to a thing

3352
02:14:07,960 --> 02:14:12,400
one of my game developer articles that I

3353
02:14:09,520 --> 02:14:14,239
wrote which was after I got fed up with

3354
02:14:12,400 --> 02:14:16,679
all the terrain LOD stuff that I was

3355
02:14:14,239 --> 02:14:18,199
doing which was some of my earliest

3356
02:14:16,679 --> 02:14:20,040
experience with being disappointed in

3357
02:14:18,199 --> 02:14:22,960
computer science papers that promise

3358
02:14:20,040 --> 02:14:25,559
performance good performance

3359
02:14:22,960 --> 02:14:27,320
um I decided to think about like hey

3360
02:14:25,559 --> 02:14:30,480
let's do LOD for terrain is static

3361
02:14:27,320 --> 02:14:32,360
meshes right oh but you have to you have

3362
02:14:30,480 --> 02:14:34,960
to chop the meshes because the far away

3363
02:14:32,360 --> 02:14:36,760
pieces need to be lower res and stuff

3364
02:14:34,960 --> 02:14:38,440
and oh that's a hard problem to know how

3365
02:14:36,760 --> 02:14:40,800
to stitch those together you got to have

3366
02:14:38,440 --> 02:14:42,239
Hur everybody at GDC was telling me that

3367
02:14:40,800 --> 02:14:44,040
or not every the few people I talked to

3368
02:14:42,239 --> 02:14:46,119
they were like oh yeah you would need a

3369
02:14:44,040 --> 02:14:48,480
weird heuristic to whatever and I'm like

3370
02:14:46,119 --> 02:14:50,520
wait a minute you had the input mesh

3371
02:14:48,480 --> 02:14:52,320
and then you chopped it you like know

3372
02:14:50,520 --> 02:14:55,599
what polygons go together and then as

3373
02:14:52,320 --> 02:14:57,320
you reduce the L on the other side you

3374
02:14:55,599 --> 02:15:00,760
know the source

3375
02:14:57,320 --> 02:15:03,400
polygons right that generate you know

3376
02:15:00,760 --> 02:15:06,559
like LOD means you turn fine detail into

3377
02:15:03,400 --> 02:15:08,760
coar detail so if you have two triangles

3378
02:15:06,559 --> 02:15:11,559
and you realize you could make them one

3379
02:15:08,760 --> 02:15:13,440
triangle then you you actually know that

3380
02:15:11,559 --> 02:15:15,599
information and so if you wanted to

3381
02:15:13,440 --> 02:15:17,880
maintain a seam between those two things

3382
02:15:15,599 --> 02:15:20,480
of different lods you actually can do it

3383
02:15:17,880 --> 02:15:22,679
perfectly with no heris because you made

3384
02:15:20,480 --> 02:15:26,040
the lower detail representation so you

3385
02:15:22,679 --> 02:15:29,199
just say oh here's the highres

3386
02:15:26,040 --> 02:15:31,440
seam the lower these two triangles

3387
02:15:29,199 --> 02:15:34,440
collapse into one they had edges on that

3388
02:15:31,440 --> 02:15:37,199
seam so make those two edges into like

3389
02:15:34,440 --> 02:15:39,559
you know one thing and it was very

3390
02:15:37,199 --> 02:15:41,199
simple and that was all it was and it's

3391
02:15:39,559 --> 02:15:42,239
like the same thing in compilers it's

3392
02:15:41,199 --> 02:15:45,679
kind of

3393
02:15:42,239 --> 02:15:47,320
astonishing um sorry that was that was a

3394
02:15:45,679 --> 02:15:48,960
long explanation that nobody cares about

3395
02:15:47,320 --> 02:15:51,280
and nobody understands because I'm tired

3396
02:15:48,960 --> 02:15:53,079
and and rambling so it's what happens

3397
02:15:51,280 --> 02:15:54,400
when I play video games and then sleep

3398
02:15:53,079 --> 02:15:57,360
for six

3399
02:15:54,400 --> 02:16:01,159
hours um let me let's video it wasn't

3400
02:15:57,360 --> 02:16:04,159
video games a video game it was a very

3401
02:16:01,159 --> 02:16:06,639
specific singular video game a uh stress

3402
02:16:04,159 --> 02:16:08,760
testing simulator someone is saying is

3403
02:16:06,639 --> 02:16:11,440
it a bad idea to use the correct grammar

3404
02:16:08,760 --> 02:16:14,320
for operator precedence okay first of

3405
02:16:11,440 --> 02:16:17,280
all uh I'm inclined to ignore this

3406
02:16:14,320 --> 02:16:18,360
question I won't but I'm inclined to

3407
02:16:17,280 --> 02:16:20,800
ignore the question question because you

3408
02:16:18,360 --> 02:16:23,719
saying correct grammar which is like

3409
02:16:20,800 --> 02:16:27,079
some kind of Harvard [ __ ] to say right

3410
02:16:23,719 --> 02:16:29,920
like yes there are um there is this

3411
02:16:27,079 --> 02:16:31,960
Backus now forum for example it's the

3412
02:16:29,920 --> 02:16:34,519
most popular way of representing this

3413
02:16:31,960 --> 02:16:38,120
kind of grammar for a programming

3414
02:16:34,519 --> 02:16:39,760
language what do you what do you mean by

3415
02:16:38,120 --> 02:16:43,439
correct

3416
02:16:39,760 --> 02:16:46,519
okay um why why are you elevating that

3417
02:16:43,439 --> 02:16:48,319
to some it may or may not be a useful

3418
02:16:46,519 --> 02:16:50,639
way to represent things for for me I

3419
02:16:48,319 --> 02:16:52,439
have never written this out this is you

3420
02:16:50,639 --> 02:16:55,120
know what these are is in like a sort of

3421
02:16:52,439 --> 02:16:58,000
a pseudo kind of mathy but kind of

3422
02:16:55,120 --> 02:16:59,319
programming language form these are like

3423
02:16:58,000 --> 02:17:01,160
what the things are in your language

3424
02:16:59,319 --> 02:17:03,679
I've literally never written that for

3425
02:17:01,160 --> 02:17:05,920
this compiler so I don't I don't care

3426
02:17:03,679 --> 02:17:07,840
about this kind of representation so I

3427
02:17:05,920 --> 02:17:10,479
object to the word correct it's like

3428
02:17:07,840 --> 02:17:13,240
when people say they're making their C++

3429
02:17:10,479 --> 02:17:15,479
code const correct I'm like the word

3430
02:17:13,240 --> 02:17:19,240
correct there is a propaganda word it is

3431
02:17:15,479 --> 02:17:22,920
not describing anything technical

3432
02:17:19,240 --> 02:17:25,559
um but okay

3433
02:17:22,920 --> 02:17:28,519
so yeah I mean the problem is this is

3434
02:17:25,559 --> 02:17:33,120
just going to be really slow like you're

3435
02:17:28,519 --> 02:17:36,160
writing a a buttload of if statements

3436
02:17:33,120 --> 02:17:38,080
and okay I mean you can do that right

3437
02:17:36,160 --> 02:17:40,280
you're gonna you're going to take lots

3438
02:17:38,080 --> 02:17:41,639
of Branch prediction failures and even

3439
02:17:40,280 --> 02:17:44,319
if you don't it's just a lot of

3440
02:17:41,639 --> 02:17:48,000
instructions that you don't need I mean

3441
02:17:44,319 --> 02:17:50,479
isn't this also basically like the even

3442
02:17:48,000 --> 02:17:52,880
more expanded version of what we read in

3443
02:17:50,479 --> 02:17:55,280
that uhing interpreters book like this

3444
02:17:52,880 --> 02:17:57,160
is basically that it's that exact code

3445
02:17:55,280 --> 02:17:59,800
but you just expanded it

3446
02:17:57,160 --> 02:18:02,040
out um well it's also in the opposite

3447
02:17:59,800 --> 02:18:04,319
order so we have compare here and then

3448
02:18:02,040 --> 02:18:07,120
add here so you go up the file as the

3449
02:18:04,319 --> 02:18:08,719
Precedence goes up right but like I said

3450
02:18:07,120 --> 02:18:11,280
I mean if you miss that part don't do

3451
02:18:08,719 --> 02:18:13,880
this um it's

3452
02:18:11,280 --> 02:18:18,240
not it's not the right way to do it I

3453
02:18:13,880 --> 02:18:19,160
would say also uh one thing that I find

3454
02:18:18,240 --> 02:18:22,240
just

3455
02:18:19,160 --> 02:18:23,920
personally as more of a consumer of this

3456
02:18:22,240 --> 02:18:27,599
information than a

3457
02:18:23,920 --> 02:18:29,479
producer is I find BNF form to be kind

3458
02:18:27,599 --> 02:18:32,160
of useless for me to understand what the

3459
02:18:29,479 --> 02:18:34,639
heck actually happens in a programming

3460
02:18:32,160 --> 02:18:37,160
language like if you present me the BNF

3461
02:18:34,639 --> 02:18:40,760
for as much of C++ as you can write it

3462
02:18:37,160 --> 02:18:43,080
for which is not all of it yes um it

3463
02:18:40,760 --> 02:18:46,280
doesn't really help me no like I can't

3464
02:18:43,080 --> 02:18:48,000
really like some things are fairly clear

3465
02:18:46,280 --> 02:18:49,880
like it's like oh okay if I just read

3466
02:18:48,000 --> 02:18:51,120
like multiply expression I can sort of

3467
02:18:49,880 --> 02:18:53,359
understand what the BNF does there but

3468
02:18:51,120 --> 02:18:55,200
like go to like type declaration and I'm

3469
02:18:53,359 --> 02:18:57,679
like I have no idea how this helps me

3470
02:18:55,200 --> 02:18:59,920
like by the time I finish like going

3471
02:18:57,679 --> 02:19:01,800
through and going like okay so the con

3472
02:18:59,920 --> 02:19:03,760
could could have gone in either order

3473
02:19:01,800 --> 02:19:05,880
around wait what's this thing again oh

3474
02:19:03,760 --> 02:19:09,479
it's this because you constantly have to

3475
02:19:05,880 --> 02:19:10,960
introduce non-terminals yeah to explain

3476
02:19:09,479 --> 02:19:13,080
what's going on in the BNF that's sort

3477
02:19:10,960 --> 02:19:15,120
of how they work and non-terminals are

3478
02:19:13,080 --> 02:19:16,760
by their definition things which often

3479
02:19:15,120 --> 02:19:18,080
times don't exist in the actual

3480
02:19:16,760 --> 02:19:20,639
programming light like

3481
02:19:18,080 --> 02:19:23,000
they don't have an actual like thing a

3482
02:19:20,639 --> 02:19:24,840
human would read They're a artificial

3483
02:19:23,000 --> 02:19:27,359
category of thing which you then have to

3484
02:19:24,840 --> 02:19:30,840
learn what it is so one problem I have

3485
02:19:27,359 --> 02:19:32,800
with BNS generally is when people try to

3486
02:19:30,840 --> 02:19:34,519
use that as the way to formally Define a

3487
02:19:32,800 --> 02:19:37,880
programming language well that may be

3488
02:19:34,519 --> 02:19:40,519
fine for ingesting into various tools of

3489
02:19:37,880 --> 02:19:42,160
some kind if that's really your thing

3490
02:19:40,519 --> 02:19:43,880
yeah that's fine but as something that

3491
02:19:42,160 --> 02:19:45,840
humans work with I don't find them to be

3492
02:19:43,880 --> 02:19:47,719
very good yeah if I'm going to learn a

3493
02:19:45,840 --> 02:19:49,439
new programming language I don't want to

3494
02:19:47,719 --> 02:19:51,240
see that at all right I don't want to

3495
02:19:49,439 --> 02:19:54,560
see it at all yeah the one thing that

3496
02:19:51,240 --> 02:19:56,560
you could say it's useful for is like

3497
02:19:54,560 --> 02:19:58,880
after I've designed my language and it's

3498
02:19:56,560 --> 02:20:00,800
kind of done I want to analyze my

3499
02:19:58,880 --> 02:20:03,840
grammar to make sure I didn't like do

3500
02:20:00,800 --> 02:20:05,200
something stupid you know like maybe

3501
02:20:03,840 --> 02:20:08,200
there's a

3502
02:20:05,200 --> 02:20:10,000
weird see this is a very Hy this is what

3503
02:20:08,200 --> 02:20:11,840
people say I guess like last time I

3504
02:20:10,000 --> 02:20:14,319
argued with somebody who's very

3505
02:20:11,840 --> 02:20:16,399
argumentative that you know um who I

3506
02:20:14,319 --> 02:20:19,120
haven't spoken to in years at this point

3507
02:20:16,399 --> 02:20:23,680
um okay making this argument I know who

3508
02:20:19,120 --> 02:20:26,399
it is yes and um but it's just a very

3509
02:20:23,680 --> 02:20:29,280
hypothetical case because like look if

3510
02:20:26,399 --> 02:20:30,399
if there's a weird so so one thing you

3511
02:20:29,280 --> 02:20:32,000
know the whole thing we were saying

3512
02:20:30,399 --> 02:20:34,680
before about oh there's a shift reduce

3513
02:20:32,000 --> 02:20:38,000
conflict or whatever

3514
02:20:34,680 --> 02:20:40,359
right the the BNF of the language and

3515
02:20:38,000 --> 02:20:43,359
then going through this kind of process

3516
02:20:40,359 --> 02:20:45,800
of you know breaking it down into token

3517
02:20:43,359 --> 02:20:47,520
by token and then analyzing like what

3518
02:20:45,800 --> 02:20:50,000
what is the scope of all things that

3519
02:20:47,520 --> 02:20:52,160
could happen next right is an analysis

3520
02:20:50,000 --> 02:20:53,439
you can do with that representation and

3521
02:20:52,160 --> 02:20:55,280
then you could print or you know

3522
02:20:53,439 --> 02:20:57,439
essentially a shift reduce conflict

3523
02:20:55,280 --> 02:20:59,560
report or whatever of

3524
02:20:57,439 --> 02:21:01,640
like these are the weird things in your

3525
02:20:59,560 --> 02:21:03,399
grammar but the thing is in reality

3526
02:21:01,640 --> 02:21:04,720
that's never going to be a problem

3527
02:21:03,399 --> 02:21:07,319
because if you used your programming

3528
02:21:04,720 --> 02:21:09,160
language at all you would notice that

3529
02:21:07,319 --> 02:21:11,560
you tried to type something and it

3530
02:21:09,160 --> 02:21:12,720
didn't come out the way you wanted and

3531
02:21:11,560 --> 02:21:15,319
then you would change

3532
02:21:12,720 --> 02:21:18,359
it and so it's like it's a it's an

3533
02:21:15,319 --> 02:21:21,520
academic solution to a nonpr in a sense

3534
02:21:18,359 --> 02:21:24,439
like if if the destruction of the

3535
02:21:21,520 --> 02:21:26,960
Earth was at stake and I was like I need

3536
02:21:24,439 --> 02:21:28,920
to make really sure that I didn't make a

3537
02:21:26,960 --> 02:21:30,920
weird mistake here I would totally go do

3538
02:21:28,920 --> 02:21:33,760
that

3539
02:21:30,920 --> 02:21:37,000
right but like that's just not how

3540
02:21:33,760 --> 02:21:38,880
things are I also don't know how useful

3541
02:21:37,000 --> 02:21:40,439
even it is in the case where where the

3542
02:21:38,880 --> 02:21:45,000
Earth is about to be destroyed which of

3543
02:21:40,439 --> 02:21:46,600
course happens often um and that is that

3544
02:21:45,000 --> 02:21:48,160
it doesn't really tell you much about

3545
02:21:46,600 --> 02:21:49,520
the part that you're likely to actually

3546
02:21:48,160 --> 02:21:51,640
have problems with which is the rest of

3547
02:21:49,520 --> 02:21:54,399
the compiler so it's like having this

3548
02:21:51,640 --> 02:21:56,600
like extremely formal description that

3549
02:21:54,399 --> 02:21:59,439
leaves out basically any semantic

3550
02:21:56,600 --> 02:22:01,000
checking at all and then the the

3551
02:21:59,439 --> 02:22:02,319
explanation for well how do we do the

3552
02:22:01,000 --> 02:22:03,520
semantic check like what's the notation

3553
02:22:02,319 --> 02:22:06,000
for the semantic checking part they're

3554
02:22:03,520 --> 02:22:07,760
like well we don't have that is not like

3555
02:22:06,000 --> 02:22:09,640
that doesn't help like that's just like

3556
02:22:07,760 --> 02:22:12,120
you you made this artificial thing that

3557
02:22:09,640 --> 02:22:14,120
we have to then go learn as a separate

3558
02:22:12,120 --> 02:22:15,800
exercise that actually doesn't capture

3559
02:22:14,120 --> 02:22:17,760
most of the problem so what was the

3560
02:22:15,800 --> 02:22:19,040
point like yeah if you got to the point

3561
02:22:17,760 --> 02:22:21,479
where you could describe the entire

3562
02:22:19,040 --> 02:22:23,240
correctness of a programming language in

3563
02:22:21,479 --> 02:22:25,920
some kind of really concise notation

3564
02:22:23,240 --> 02:22:28,200
then that's maybe more interesting um

3565
02:22:25,920 --> 02:22:29,800
and you know maybe some theoretical CS

3566
02:22:28,200 --> 02:22:33,000
people have actually done that but

3567
02:22:29,800 --> 02:22:35,319
that's not BNF so BNF is just kind of

3568
02:22:33,000 --> 02:22:37,240
frustrating to me most the time I don't

3569
02:22:35,319 --> 02:22:39,600
see yeah like I said I don't see much of

3570
02:22:37,240 --> 02:22:43,280
the point in BNF except to prove that

3571
02:22:39,600 --> 02:22:44,840
you went to computer school um I have

3572
02:22:43,280 --> 02:22:46,840
much more Sympathy for the people who

3573
02:22:44,840 --> 02:22:49,120
are trying to do like program prover

3574
02:22:46,840 --> 02:22:50,399
systems yeah and that's more interesting

3575
02:22:49,120 --> 02:22:52,560
I also think that those are a little

3576
02:22:50,399 --> 02:22:54,200
impractical at the current time unless

3577
02:22:52,560 --> 02:22:55,880
we make some big breakthrough but at

3578
02:22:54,200 --> 02:22:58,399
least that makes sense to me I'm like

3579
02:22:55,880 --> 02:23:00,319
okay I get it yes it is very hard for me

3580
02:22:58,399 --> 02:23:02,319
to know if my program is correct in fact

3581
02:23:00,319 --> 02:23:04,160
actually no it's easy for me to know

3582
02:23:02,319 --> 02:23:05,520
that it's it's not correct it's got

3583
02:23:04,160 --> 02:23:08,319
problems I just don't know what the

3584
02:23:05,520 --> 02:23:11,439
problems are okay right

3585
02:23:08,319 --> 02:23:13,120
yeah so so I'm very sympathetic to that

3586
02:23:11,439 --> 02:23:16,000
initiative

3587
02:23:13,120 --> 02:23:17,920
which the BNF is like maybe more of a

3588
02:23:16,000 --> 02:23:19,760
cargo cult version of that but you know

3589
02:23:17,920 --> 02:23:22,200
like here's the

3590
02:23:19,760 --> 02:23:24,279
thing all that stuff goes way back into

3591
02:23:22,200 --> 02:23:27,160
the 70s and the 60s and maybe even the

3592
02:23:24,279 --> 02:23:30,000
50s when

3593
02:23:27,160 --> 02:23:31,760
like it was like maybe computer language

3594
02:23:30,000 --> 02:23:33,160
is a little bit like human language

3595
02:23:31,760 --> 02:23:37,560
right and you had all these cognitive

3596
02:23:33,160 --> 02:23:39,760
scientists like trying to do grammar for

3597
02:23:37,560 --> 02:23:41,520
English and stuff like whatever like all

3598
02:23:39,760 --> 02:23:44,080
that stuff is kind of mixed

3599
02:23:41,520 --> 02:23:45,840
together um and again I don't put the

3600
02:23:44,080 --> 02:23:49,040
fault

3601
02:23:45,840 --> 02:23:52,160
on um any of the people who came up with

3602
02:23:49,040 --> 02:23:55,479
these ideas right I do put the fault on

3603
02:23:52,160 --> 02:23:58,080
our system both academic and Industrial

3604
02:23:55,479 --> 02:24:02,040
to the extent it participates in this of

3605
02:23:58,080 --> 02:24:04,279
propagating these weird incorrect

3606
02:24:02,040 --> 02:24:06,439
Notions of what you should be doing

3607
02:24:04,279 --> 02:24:08,800
right that's the part that failed having

3608
02:24:06,439 --> 02:24:11,840
different ideas about how to represent

3609
02:24:08,800 --> 02:24:13,279
your grammar is great like there might

3610
02:24:11,840 --> 02:24:15,680
be some cool ones that nobody's thought

3611
02:24:13,279 --> 02:24:17,880
of and it would be good to add those to

3612
02:24:15,680 --> 02:24:21,080
the world if if they have something to

3613
02:24:17,880 --> 02:24:23,680
add but after that there needs to be

3614
02:24:21,080 --> 02:24:26,800
some diligent step of the collective

3615
02:24:23,680 --> 02:24:27,880
intelligence wherein we decide correctly

3616
02:24:26,800 --> 02:24:30,000
and

3617
02:24:27,880 --> 02:24:32,200
accurately what is really the good way

3618
02:24:30,000 --> 02:24:34,200
to do things and we've been pretty bad

3619
02:24:32,200 --> 02:24:37,760
at that as far as I can tell yeah it's

3620
02:24:34,200 --> 02:24:39,800
it's it's piss poor yeah uh here's a

3621
02:24:37,760 --> 02:24:41,840
concrete question how do you parse so

3622
02:24:39,800 --> 02:24:43,880
someone is asking about dot we talked

3623
02:24:41,840 --> 02:24:45,479
about dot struct references before

3624
02:24:43,880 --> 02:24:47,720
there's a couple of constructs we have

3625
02:24:45,479 --> 02:24:49,120
we have like A.B that's a struct

3626
02:24:47,720 --> 02:24:52,080
reference just so I can see and then our

3627
02:24:49,120 --> 02:24:54,240
struct literals because we allow you to

3628
02:24:52,080 --> 02:24:56,479
use them as an expression and like infer

3629
02:24:54,240 --> 02:24:58,920
the type and stuff and I didn't want to

3630
02:24:56,479 --> 02:25:01,080
worry about weird parsing ambiguities

3631
02:24:58,920 --> 02:25:05,240
for now we put a dot in front of our

3632
02:25:01,080 --> 02:25:07,920
brace so if you have a struct type and

3633
02:25:05,240 --> 02:25:11,960
um you know you could have your your

3634
02:25:07,920 --> 02:25:11,960
elements in here

3635
02:25:12,000 --> 02:25:17,479
um you know and they could be different

3636
02:25:14,200 --> 02:25:20,200
types or whatever um and they're just

3637
02:25:17,479 --> 02:25:25,960
asking what does that do so if this is a

3638
02:25:20,200 --> 02:25:28,160
struct right then this is a value copy

3639
02:25:25,960 --> 02:25:30,720
of that struct with the fields filled in

3640
02:25:28,160 --> 02:25:32,359
by these values and you could use names

3641
02:25:30,720 --> 02:25:33,960
if you want here you could say like name

3642
02:25:32,359 --> 02:25:36,439
equals hello and these could be out of

3643
02:25:33,960 --> 02:25:39,680
order if you specify to you whatever s s

3644
02:25:36,439 --> 02:25:43,520
is a type name or an identifier

3645
02:25:39,680 --> 02:25:45,800
uh those are the same thing okay so it's

3646
02:25:43,520 --> 02:25:48,760
it's an identifier that has to be

3647
02:25:45,800 --> 02:25:51,880
evaluatable as a a constant and it has

3648
02:25:48,760 --> 02:25:53,720
to refer to a type right okay so it

3649
02:25:51,880 --> 02:25:55,359
could be it could be something that's

3650
02:25:53,720 --> 02:25:56,840
just referring to a type or it could be

3651
02:25:55,359 --> 02:26:00,240
an actual type name but it just has to

3652
02:25:56,840 --> 02:26:02,520
be something that becomes that can be

3653
02:26:00,240 --> 02:26:04,240
you can get a list of fields from it yes

3654
02:26:02,520 --> 02:26:06,439
the compiler knows what stru this is at

3655
02:26:04,240 --> 02:26:07,920
compile time is the point right got it

3656
02:26:06,439 --> 02:26:09,560
it could be a more complex like we have

3657
02:26:07,920 --> 02:26:14,240
compile time executions you could run

3658
02:26:09,560 --> 02:26:16,880
some stuff right right whatever um so

3659
02:26:14,240 --> 02:26:19,600
they're just asking how do you know the

3660
02:26:16,880 --> 02:26:22,680
difference and the answer is just when

3661
02:26:19,600 --> 02:26:24,520
you see a DOT so so we have dot in our

3662
02:26:22,680 --> 02:26:26,160
binary operator parsing but when we see

3663
02:26:24,520 --> 02:26:28,760
a DOT we just look one token ahead and

3664
02:26:26,160 --> 02:26:31,720
we say is there a brace it's very simple

3665
02:26:28,760 --> 02:26:34,840
right if there's a brace it's this

3666
02:26:31,720 --> 02:26:36,840
otherwise par an expression because this

3667
02:26:34,840 --> 02:26:39,000
like open brace whatever closed brace is

3668
02:26:36,840 --> 02:26:41,720
not really an expression in the way that

3669
02:26:39,000 --> 02:26:43,439
we have this programmed as Casey was

3670
02:26:41,720 --> 02:26:45,920
saying before you could play games about

3671
02:26:43,439 --> 02:26:48,000
what's an expression and what's not and

3672
02:26:45,920 --> 02:26:50,880
yeah you know I just chose not to do

3673
02:26:48,000 --> 02:26:52,520
that for this so this is this is a very

3674
02:26:50,880 --> 02:26:54,000
just like the for Loop example we were

3675
02:26:52,520 --> 02:26:56,520
talking about where you have specialized

3676
02:26:54,000 --> 02:26:59,000
parsing that's exactly what this is it's

3677
02:26:56,520 --> 02:27:03,840
like we go into a special mode that does

3678
02:26:59,000 --> 02:27:03,840
this thing and then we return that back

3679
02:27:03,920 --> 02:27:10,200
out um and that's sort of the here's the

3680
02:27:07,399 --> 02:27:12,319
thing here's the interesting thing is in

3681
02:27:10,200 --> 02:27:15,120
designing your grammar so I you know I

3682
02:27:12,319 --> 02:27:16,920
put the dot here just to make it easy I

3683
02:27:15,120 --> 02:27:19,000
don't know you could you could maybe say

3684
02:27:16,920 --> 02:27:21,040
that but then as you're developing a

3685
02:27:19,000 --> 02:27:22,479
language you have to deal with like

3686
02:27:21,040 --> 02:27:25,000
you're kind of asking for it at some

3687
02:27:22,479 --> 02:27:27,080
point like oh now this kind of

3688
02:27:25,000 --> 02:27:30,960
expression looks like that kind of

3689
02:27:27,080 --> 02:27:33,000
expression and it's not clear which is

3690
02:27:30,960 --> 02:27:35,279
which and you have maybe if it is clear

3691
02:27:33,000 --> 02:27:37,240
to the programmer you have to do more

3692
02:27:35,279 --> 02:27:39,279
work to like make the code look more

3693
02:27:37,240 --> 02:27:42,720
ahead to determine which one it is or

3694
02:27:39,279 --> 02:27:43,880
whatever but the thing is you don't

3695
02:27:42,720 --> 02:27:45,800
really want to be playing that game

3696
02:27:43,880 --> 02:27:47,240
anyway like you want people to be able

3697
02:27:45,800 --> 02:27:51,080
to just look at the program prr and know

3698
02:27:47,240 --> 02:27:53,240
what it means right and the more there's

3699
02:27:51,080 --> 02:27:55,160
a parallelism where the more that you

3700
02:27:53,240 --> 02:27:57,080
have to make the parser do crazy stuff

3701
02:27:55,160 --> 02:27:59,640
to look ahead to determine maybe this is

3702
02:27:57,080 --> 02:28:02,200
something weird someone looking at the

3703
02:27:59,640 --> 02:28:05,200
code may not understand that either

3704
02:28:02,200 --> 02:28:06,720
right um and so you just want things to

3705
02:28:05,200 --> 02:28:09,120
be simple to read and simple to

3706
02:28:06,720 --> 02:28:12,319
understand and that tends to correspond

3707
02:28:09,120 --> 02:28:15,279
to simple grammars that's actually why

3708
02:28:12,319 --> 02:28:17,240
for example so C has this is a putting

3709
02:28:15,279 --> 02:28:20,000
this dot here is a kind of a defensive

3710
02:28:17,240 --> 02:28:22,399
grammar design where it's like I just

3711
02:28:20,000 --> 02:28:25,279
like it better if it's clear C has that

3712
02:28:22,399 --> 02:28:27,279
in like you know if statements and uh

3713
02:28:25,279 --> 02:28:31,600
you know they have parentheses around

3714
02:28:27,279 --> 02:28:34,000
them why well because sometimes what's

3715
02:28:31,600 --> 02:28:36,160
inside the parentheses might look like

3716
02:28:34,000 --> 02:28:37,319
like if there's a un operator afterward

3717
02:28:36,160 --> 02:28:39,920
because you don't have to put braces

3718
02:28:37,319 --> 02:28:41,120
afterward if there's a un operator and

3719
02:28:39,920 --> 02:28:42,399
you have an expression inside the

3720
02:28:41,120 --> 02:28:43,319
parentheses it might and the parentheses

3721
02:28:42,399 --> 02:28:45,000
weren't there it might look like a

3722
02:28:43,319 --> 02:28:46,279
binary operator and we're we're just

3723
02:28:45,000 --> 02:28:47,800
going to say screw it there's

3724
02:28:46,279 --> 02:28:51,120
parentheses es and that's how we solve

3725
02:28:47,800 --> 02:28:53,640
this problem and sometimes you do that

3726
02:28:51,120 --> 02:28:54,880
um sometimes people get on my case that

3727
02:28:53,640 --> 02:28:57,439
they wish there was a little less

3728
02:28:54,880 --> 02:28:59,359
punctuation but I'm like we could look

3729
02:28:57,439 --> 02:29:00,880
at that later in the meantime I just

3730
02:28:59,359 --> 02:29:02,840
want it to be very clear what everything

3731
02:29:00,880 --> 02:29:04,439
is and I don't want these weird problems

3732
02:29:02,840 --> 02:29:08,279
and I don't want people to be writing

3733
02:29:04,439 --> 02:29:11,680
code we exactly had one exact we don't

3734
02:29:08,279 --> 02:29:13,640
have that many un operators that are

3735
02:29:11,680 --> 02:29:15,040
that you tend to use in that case we

3736
02:29:13,640 --> 02:29:17,600
don't have the parentheses which is why

3737
02:29:15,040 --> 02:29:20,120
I'm saying all this um

3738
02:29:17,600 --> 02:29:21,840
there was one Unity operator that was

3739
02:29:20,120 --> 02:29:27,319
causing problems and we just changed it

3740
02:29:21,840 --> 02:29:31,600
to to a post uh postorder unit operator

3741
02:29:27,319 --> 02:29:31,600
and then that problem goes away

3742
02:29:31,920 --> 02:29:36,520
um

3743
02:29:33,840 --> 02:29:38,960
okay do you do something in crazy in the

3744
02:29:36,520 --> 02:29:42,160
lexer to maximize throughput No like

3745
02:29:38,960 --> 02:29:44,760
lexer is just really fast

3746
02:29:42,160 --> 02:29:47,560
um I

3747
02:29:44,760 --> 02:29:50,200
don't like the par is really fast and

3748
02:29:47,560 --> 02:29:52,600
it's way slower than the lexer um one

3749
02:29:50,200 --> 02:29:55,439
thing we do like we don't allocate a

3750
02:29:52,600 --> 02:29:57,240
trillion tokens right we reuse there's

3751
02:29:55,439 --> 02:29:58,880
like you know some number of tokens that

3752
02:29:57,240 --> 02:30:00,479
we allowed to look ahead and there's

3753
02:29:58,880 --> 02:30:04,040
just like a ring buffer of them right

3754
02:30:00,479 --> 02:30:05,800
and so um we're not allocating we're

3755
02:30:04,040 --> 02:30:07,680
especially not calling Malik per token

3756
02:30:05,800 --> 02:30:11,120
but we're not actually allocating new

3757
02:30:07,680 --> 02:30:12,479
tokens um we are allocating subdata of

3758
02:30:11,120 --> 02:30:14,800
tokens so if you have an identifier we

3759
02:30:12,479 --> 02:30:16,560
need to know the name of the identifier

3760
02:30:14,800 --> 02:30:17,680
we just make that little string some

3761
02:30:16,560 --> 02:30:20,880
where that's cheap to allocate and

3762
02:30:17,680 --> 02:30:20,880
pointed it

3763
02:30:23,359 --> 02:30:28,160
um yeah uh shout out to Coffee compiler

3764
02:30:26,160 --> 02:30:31,240
club by the way they they could use more

3765
02:30:28,160 --> 02:30:32,920
viewership it is a niche topic but they

3766
02:30:31,240 --> 02:30:35,800
they're on YouTube let's let's find a

3767
02:30:32,920 --> 02:30:40,439
YouTube video

3768
02:30:35,800 --> 02:30:40,439
since they tend to be pretty long and in

3769
02:30:41,120 --> 02:30:46,880
depth updated seven days ago yeah

3770
02:30:44,319 --> 02:30:48,800
they're still doing it I wasn't sure but

3771
02:30:46,880 --> 02:30:51,479
yeah they just talk about compiler

3772
02:30:48,800 --> 02:30:53,800
stuffff every week it is invite only to

3773
02:30:51,479 --> 02:30:57,200
be on the

3774
02:30:53,800 --> 02:30:59,000
thing um so probably no bozos but if you

3775
02:30:57,200 --> 02:31:00,640
want to watch them it's pretty easy it's

3776
02:30:59,000 --> 02:31:04,560
just as you can see it's a niche topic

3777
02:31:00,640 --> 02:31:04,560
like 300 views 400

3778
02:31:04,840 --> 02:31:11,800
views yeah some of them I guess get more

3779
02:31:12,120 --> 02:31:16,720
uh yeah we'll post this on YouTube are

3780
02:31:14,640 --> 02:31:19,000
you bored Casey do you want to cut it

3781
02:31:16,720 --> 02:31:21,439
here or do you want to keep going what's

3782
02:31:19,000 --> 02:31:23,800
what's your level of Interest I mean I'm

3783
02:31:21,439 --> 02:31:25,200
happy to do whatever you're up for it s

3784
02:31:23,800 --> 02:31:26,600
it sounds like if there's more

3785
02:31:25,200 --> 02:31:28,520
interesting questions that's fine with

3786
02:31:26,600 --> 02:31:30,840
me I don't have much to add right I'm

3787
02:31:28,520 --> 02:31:32,800
only here to ask questions you're not

3788
02:31:30,840 --> 02:31:35,560
you're not in the middle of yeah doing

3789
02:31:32,800 --> 02:31:37,640
these things um I I will say that

3790
02:31:35,560 --> 02:31:40,040
starting I think I didn't have enough

3791
02:31:37,640 --> 02:31:41,319
breakfast and I have a lack of sugar to

3792
02:31:40,040 --> 02:31:43,960
the brain which is why I started

3793
02:31:41,319 --> 02:31:46,160
munching truffles truffles yeah so I

3794
02:31:43,960 --> 02:31:50,920
feel like a couple of the answers that

3795
02:31:46,160 --> 02:31:52,520
I've been giving in the past q&as for 15

3796
02:31:50,920 --> 02:31:55,200
20 minutes were a little too Meandering

3797
02:31:52,520 --> 02:31:57,120
and a little too like not quite the best

3798
02:31:55,200 --> 02:31:58,640
answer but well maybe that's the end

3799
02:31:57,120 --> 02:32:01,359
then maybe let's see if there's good

3800
02:31:58,640 --> 02:32:03,000
questions okay yeah that's the thing is

3801
02:32:01,359 --> 02:32:04,359
I don't want to put bad answers to

3802
02:32:03,000 --> 02:32:06,880
questions out

3803
02:32:04,359 --> 02:32:09,000
there so I saw as I'm scrolling through

3804
02:32:06,880 --> 02:32:11,000
the chat Oxford comma correct was

3805
02:32:09,000 --> 02:32:14,359
something that somebody

3806
02:32:11,000 --> 02:32:15,840
said yeah what if you develop things

3807
02:32:14,359 --> 02:32:18,800
that work with various languages so you

3808
02:32:15,840 --> 02:32:19,960
need not one parser but a dozen do you

3809
02:32:18,800 --> 02:32:21,439
think writing them individually is

3810
02:32:19,960 --> 02:32:23,800
better anyway as opposed to using parser

3811
02:32:21,439 --> 02:32:25,160
generator yes but also if you find

3812
02:32:23,800 --> 02:32:26,479
yourself using a dozen programming

3813
02:32:25,160 --> 02:32:28,080
languages you're doing something super

3814
02:32:26,479 --> 02:32:31,399
super super

3815
02:32:28,080 --> 02:32:32,960
wrong editor an editor might be an

3816
02:32:31,399 --> 02:32:36,000
example though like right like I'm

3817
02:32:32,960 --> 02:32:38,319
making I'm making Sublime I'm the author

3818
02:32:36,000 --> 02:32:42,359
of sublime and everyone's like I want

3819
02:32:38,319 --> 02:32:43,520
syntax highlighting for squeam Lang and

3820
02:32:42,359 --> 02:32:45,439
you're like I don't even know what

3821
02:32:43,520 --> 02:32:48,680
squeam Lang is but now I'm pulling up

3822
02:32:45,439 --> 02:32:50,359
the you know web page for that yeah what

3823
02:32:48,680 --> 02:32:53,040
you know what do you do in those cases

3824
02:32:50,359 --> 02:32:54,479
and like probably a parser generator

3825
02:32:53,040 --> 02:32:56,040
would be great but the problem is

3826
02:32:54,479 --> 02:32:57,640
usually that they don't work very well

3827
02:32:56,040 --> 02:32:59,319
like the problem is not that it wouldn't

3828
02:32:57,640 --> 02:33:00,880
be great if there was some magic way to

3829
02:32:59,319 --> 02:33:03,479
make parsers quickly the problem is

3830
02:33:00,880 --> 02:33:04,880
there isn't well there there isn't so

3831
02:33:03,479 --> 02:33:07,240
this is one thing that I wanted to say

3832
02:33:04,880 --> 02:33:09,200
before too because like you know our

3833
02:33:07,240 --> 02:33:11,479
parser right now is 6,000

3834
02:33:09,200 --> 02:33:12,760
lines I'm pretty sure if we use a parser

3835
02:33:11,479 --> 02:33:14,120
generator it would be longer

3836
02:33:12,760 --> 02:33:17,000
substantially right because you have to

3837
02:33:14,120 --> 02:33:19,439
do all this interfacing with the thing

3838
02:33:17,000 --> 02:33:21,840
um and then you have to do all this

3839
02:33:19,439 --> 02:33:23,560
making your own structure to cope that

3840
02:33:21,840 --> 02:33:26,399
the structure of the thing isn't what

3841
02:33:23,560 --> 02:33:29,240
you wanted and it just yeah I've done it

3842
02:33:26,399 --> 02:33:30,359
enough times to know but here's the

3843
02:33:29,240 --> 02:33:33,359
other

3844
02:33:30,359 --> 02:33:33,359
thing

3845
02:33:34,640 --> 02:33:38,960
um like we talked before about how error

3846
02:33:37,120 --> 02:33:41,920
messages are important

3847
02:33:38,960 --> 02:33:43,760
right doing syntax highlighting

3848
02:33:41,920 --> 02:33:46,200
correctly

3849
02:33:43,760 --> 02:33:49,200
is while somebody's in the middle of

3850
02:33:46,200 --> 02:33:51,319
typing stuff that is not complete right

3851
02:33:49,200 --> 02:33:52,920
is sort of equivalent to generating a

3852
02:33:51,319 --> 02:33:55,240
good error message like there's a way in

3853
02:33:52,920 --> 02:33:57,000
which those problems are very similar

3854
02:33:55,240 --> 02:33:59,600
where I don't want my highlighting to

3855
02:33:57,000 --> 02:34:01,680
get all freaking stupid just

3856
02:33:59,600 --> 02:34:03,680
because you know I don't know you you

3857
02:34:01,680 --> 02:34:05,439
like got a parthy somewhere or whatever

3858
02:34:03,680 --> 02:34:06,840
yes but that's the thing is if you use a

3859
02:34:05,439 --> 02:34:09,760
parser generator that is what you will

3860
02:34:06,840 --> 02:34:14,640
get out of it right and then you could

3861
02:34:09,760 --> 02:34:17,560
add some code when you see a conflict to

3862
02:34:14,640 --> 02:34:19,960
like try TR to do something but you

3863
02:34:17,560 --> 02:34:22,359
don't have because this is the thing

3864
02:34:19,960 --> 02:34:24,520
when you write the code yourself in

3865
02:34:22,359 --> 02:34:27,399
recursive descent form which I will say

3866
02:34:24,520 --> 02:34:29,160
once again is too complicated of a name

3867
02:34:27,399 --> 02:34:31,640
you're just calling functions that parse

3868
02:34:29,160 --> 02:34:34,479
the things they should call it calling

3869
02:34:31,640 --> 02:34:37,560
functions that parse the things

3870
02:34:34,479 --> 02:34:41,080
parser okay that is what it

3871
02:34:37,560 --> 02:34:42,399
is when you do that you know exactly

3872
02:34:41,080 --> 02:34:46,319
what you're doing you have all the

3873
02:34:42,399 --> 02:34:50,520
context right um it's just much easier

3874
02:34:46,319 --> 02:34:52,479
to to give high quality responses and I

3875
02:34:50,520 --> 02:34:54,560
mean I I have not made an editor that

3876
02:34:52,479 --> 02:34:58,600
does syntax highlighting but if I were

3877
02:34:54,560 --> 02:35:01,240
to I would absolutely um do the grammars

3878
02:34:58,600 --> 02:35:03,160
I mean if you like there's this whole

3879
02:35:01,240 --> 02:35:05,240
question okay what if what if you're

3880
02:35:03,160 --> 02:35:08,279
releasing the editor for everybody and

3881
02:35:05,240 --> 02:35:11,720
you want to provide a way for people to

3882
02:35:08,279 --> 02:35:14,439
contribute and stuff and even then is

3883
02:35:11,720 --> 02:35:16,800
the contribution

3884
02:35:14,439 --> 02:35:20,960
like just them being able to make some

3885
02:35:16,800 --> 02:35:23,680
code that simply parses the thing or do

3886
02:35:20,960 --> 02:35:27,160
they have to learn some weird ass you

3887
02:35:23,680 --> 02:35:29,960
know parser generator thing and what you

3888
02:35:27,160 --> 02:35:32,000
know I would also point out that like

3889
02:35:29,960 --> 02:35:34,120
it's it's worse I think even than you're

3890
02:35:32,000 --> 02:35:36,040
making it out to be John and you're

3891
02:35:34,120 --> 02:35:38,680
already making it out to be bad uh which

3892
02:35:36,040 --> 02:35:40,200
is that like in a lot of circumstances

3893
02:35:38,680 --> 02:35:42,160
that I can think of where you're trying

3894
02:35:40,200 --> 02:35:45,399
to ship something that uses multiple

3895
02:35:42,160 --> 02:35:46,520
parsers they are like you pointed out

3896
02:35:45,399 --> 02:35:48,479
working on something that's under

3897
02:35:46,520 --> 02:35:51,000
construction they're like you know some

3898
02:35:48,479 --> 02:35:53,960
kind of like checking tools or syntax

3899
02:35:51,000 --> 02:35:55,960
highlighting or things like this and uh

3900
02:35:53,960 --> 02:35:58,479
if you take the example of like syntax

3901
02:35:55,960 --> 02:36:00,399
highlighting you know there is no way to

3902
02:35:58,479 --> 02:36:02,600
parse a file for syntax highlighting

3903
02:36:00,399 --> 02:36:04,920
often times there's things like pound if

3904
02:36:02,600 --> 02:36:06,960
blocks in it oh yeah right yeah yeah and

3905
02:36:04,920 --> 02:36:10,200
and or like you know stuff like that and

3906
02:36:06,960 --> 02:36:11,760
it's like well technically there is a

3907
02:36:10,200 --> 02:36:13,840
particular way that you parse that which

3908
02:36:11,760 --> 02:36:15,399
is you find out what the pound defines

3909
02:36:13,840 --> 02:36:16,640
are and you actually evaluate the if

3910
02:36:15,399 --> 02:36:18,359
blocks and that's the parts of the file

3911
02:36:16,640 --> 02:36:20,319
that's what the compiler will use but

3912
02:36:18,359 --> 02:36:23,479
that's not the best thing to show The

3913
02:36:20,319 --> 02:36:25,760
View like the user would like to see as

3914
02:36:23,479 --> 02:36:29,920
close as possible as you can figure out

3915
02:36:25,760 --> 02:36:32,040
what a human would want highlighted for

3916
02:36:29,920 --> 02:36:35,319
every part of the if blocks even the

3917
02:36:32,040 --> 02:36:37,200
parts that aren't actually in involved

3918
02:36:35,319 --> 02:36:39,760
in that particular compiler in that

3919
02:36:37,200 --> 02:36:41,760
particular pass and so you know it's

3920
02:36:39,760 --> 02:36:43,240
like it's a different problem and

3921
02:36:41,760 --> 02:36:45,000
particularly ill suited to something

3922
02:36:43,240 --> 02:36:47,359
like a parer generator because you're

3923
02:36:45,000 --> 02:36:50,600
trying to do sort of of like intuitive

3924
02:36:47,359 --> 02:36:54,880
stuff it's more like chat GP than it is

3925
02:36:50,600 --> 02:36:57,200
like uh like Yak right and so you know

3926
02:36:54,880 --> 02:37:00,040
her istics are going to be involved no

3927
02:36:57,200 --> 02:37:03,040
matter what and you want to make it as

3928
02:37:00,040 --> 02:37:06,040
easy to do heris as you can actually

3929
02:37:03,040 --> 02:37:09,640
this is reminding me of the of all

3930
02:37:06,040 --> 02:37:12,240
things the uh gameplay code engine for

3931
02:37:09,640 --> 02:37:16,200
the sooon game actually okay because

3932
02:37:12,240 --> 02:37:18,680
it's like if you can do the strict core

3933
02:37:16,200 --> 02:37:21,279
rule set and it works and you're not

3934
02:37:18,680 --> 02:37:22,840
seeing any problems then absolutely do

3935
02:37:21,279 --> 02:37:25,240
that

3936
02:37:22,840 --> 02:37:27,000
and because you want to be correct right

3937
02:37:25,240 --> 02:37:29,240
you don't want to be engaging heris on

3938
02:37:27,000 --> 02:37:31,240
something that parses correctly right

3939
02:37:29,240 --> 02:37:33,279
but as soon as you hit something that

3940
02:37:31,240 --> 02:37:35,200
doesn't parse correctly it's like okay

3941
02:37:33,279 --> 02:37:38,920
you want theistic to kind of plug in and

3942
02:37:35,200 --> 02:37:41,399
take over and be like oh you know this

3943
02:37:38,920 --> 02:37:44,000
looks like we were maybe going to do

3944
02:37:41,399 --> 02:37:45,560
this construct but it didn't some piece

3945
02:37:44,000 --> 02:37:46,319
of punctuation is missing or something

3946
02:37:45,560 --> 02:37:50,240
right

3947
02:37:46,319 --> 02:37:52,960
yep and um obviously that the thing

3948
02:37:50,240 --> 02:37:54,319
about those her istics is they never end

3949
02:37:52,960 --> 02:37:56,080
like you can make a better and better

3950
02:37:54,319 --> 02:37:58,880
user experience by layering more and

3951
02:37:56,080 --> 02:38:00,880
more of them maybe at some point you go

3952
02:37:58,880 --> 02:38:03,000
way too far like Microsoft with trying

3953
02:38:00,880 --> 02:38:06,319
to type into visual studio and nobody

3954
02:38:03,000 --> 02:38:08,080
wants to use it anymore but um if you're

3955
02:38:06,319 --> 02:38:09,880
if you're act that's just making good

3956
02:38:08,080 --> 02:38:12,319
versus bad decisions right but that's

3957
02:38:09,880 --> 02:38:15,040
actually what the sooon game engine

3958
02:38:12,319 --> 02:38:17,279
works like is like look here's there's a

3959
02:38:15,040 --> 02:38:19,880
strict stuff that has to happen to

3960
02:38:17,279 --> 02:38:24,120
maintain the Integrity of the moves

3961
02:38:19,880 --> 02:38:26,680
but for better game feel we can plug in

3962
02:38:24,120 --> 02:38:30,560
little rule exceptions

3963
02:38:26,680 --> 02:38:34,240
that are allowed to like let things

3964
02:38:30,560 --> 02:38:35,600
happen and then clean up the the result

3965
02:38:34,240 --> 02:38:38,680
it's a little bit of a different thing

3966
02:38:35,600 --> 02:38:40,680
but it it reminds me of the same thing

3967
02:38:38,680 --> 02:38:43,359
and

3968
02:38:40,680 --> 02:38:45,240
but it's a little bit different because

3969
02:38:43,359 --> 02:38:46,640
in the soan case we have to be correct

3970
02:38:45,240 --> 02:38:49,520
in the end no matter what like there is

3971
02:38:46,640 --> 02:38:51,880
a correct answer whereas in the text

3972
02:38:49,520 --> 02:38:53,359
editing it's like yeah I don't know I

3973
02:38:51,880 --> 02:38:55,880
it's

3974
02:38:53,359 --> 02:38:57,880
yeah uh did this rewrite speed up

3975
02:38:55,880 --> 02:38:59,680
slightly the compiler um I haven't

3976
02:38:57,880 --> 02:39:02,399
noticed but probably not like again the

3977
02:38:59,680 --> 02:39:04,520
parser is pretty fast

3978
02:39:02,399 --> 02:39:07,640
um it's all the later parts of

3979
02:39:04,520 --> 02:39:09,880
compilation that are slow I did say 10%

3980
02:39:07,640 --> 02:39:11,359
was getting memory but we still need to

3981
02:39:09,880 --> 02:39:13,479
get the same amount of memory like we

3982
02:39:11,359 --> 02:39:15,359
haven't changed the tree representation

3983
02:39:13,479 --> 02:39:18,880
or whatever here right so the you know

3984
02:39:15,359 --> 02:39:21,920
the actual um the actual code that runs

3985
02:39:18,880 --> 02:39:23,279
in the compiler is very fast compared to

3986
02:39:21,920 --> 02:39:25,960
the stuff that type checks like type

3987
02:39:23,279 --> 02:39:29,880
checking is our entire bottleneck um

3988
02:39:25,960 --> 02:39:31,800
type checking is the hardest most R see

3989
02:39:29,880 --> 02:39:36,160
I can't even speak anymore it's no blood

3990
02:39:31,800 --> 02:39:40,479
to the brain most rats nesty part of the

3991
02:39:36,160 --> 02:39:43,960
compiler um so yeah anything any changes

3992
02:39:40,479 --> 02:39:46,439
the only way that I anticipate a speed

3993
02:39:43,960 --> 02:39:48,279
difference is if somebody puts really

3994
02:39:46,439 --> 02:39:50,720
dumb stuff into the parser and slows it

3995
02:39:48,279 --> 02:39:54,479
way down but you're not really going to

3996
02:39:50,720 --> 02:39:56,399
see speed UPS from that um do you

3997
02:39:54,479 --> 02:39:58,680
tokenize the whole thing all at once or

3998
02:39:56,399 --> 02:40:01,120
as the parser asked for tokens um I do

3999
02:39:58,680 --> 02:40:04,880
it as you ask for tokens which may or

4000
02:40:01,120 --> 02:40:08,040
may not be good um again it might be

4001
02:40:04,880 --> 02:40:11,760
faster so the thing is because your

4002
02:40:08,040 --> 02:40:14,359
tokens have a clear this is not true in

4003
02:40:11,760 --> 02:40:16,960
C you could probably make it true a

4004
02:40:14,359 --> 02:40:18,920
little bit in C we talked about this

4005
02:40:16,960 --> 02:40:21,640
last time about

4006
02:40:18,920 --> 02:40:23,560
how parsing doesn't have to be the final

4007
02:40:21,640 --> 02:40:26,200
word in what things are you could like

4008
02:40:23,560 --> 02:40:29,240
reinterpret them later by changing the

4009
02:40:26,200 --> 02:40:31,080
tree around um so in C the classic thing

4010
02:40:29,240 --> 02:40:33,000
is it does matter that something's a

4011
02:40:31,080 --> 02:40:35,640
name of a type that's not the same thing

4012
02:40:33,000 --> 02:40:37,720
as a variable name and there's stuff

4013
02:40:35,640 --> 02:40:38,920
that you wouldn't be able to parse if

4014
02:40:37,720 --> 02:40:41,680
you didn't know what all the names of

4015
02:40:38,920 --> 02:40:45,960
the types are and see

4016
02:40:41,680 --> 02:40:48,520
um so there you you can't strictly

4017
02:40:45,960 --> 02:40:49,920
generate tokens ahead of time without

4018
02:40:48,520 --> 02:40:53,240
parsing

4019
02:40:49,920 --> 02:40:55,600
if you have a token for name of a type

4020
02:40:53,240 --> 02:40:56,760
and a different token right for a

4021
02:40:55,600 --> 02:40:59,240
different thing but you could have a

4022
02:40:56,760 --> 02:41:01,240
token that just says this looks like an

4023
02:40:59,240 --> 02:41:03,439
identifier maybe it's a variable maybe

4024
02:41:01,240 --> 02:41:04,920
it's a type name I don't know and then

4025
02:41:03,439 --> 02:41:08,120
there's some if statements that run when

4026
02:41:04,920 --> 02:41:09,640
you see that right and and that's when

4027
02:41:08,120 --> 02:41:10,920
but but that could be generated by the

4028
02:41:09,640 --> 02:41:12,960
lexer ahead of time because it doesn't

4029
02:41:10,920 --> 02:41:15,200
need to know the types right the point

4030
02:41:12,960 --> 02:41:18,760
being you could have if you were in a

4031
02:41:15,200 --> 02:41:20,600
very parallelism mindset you could just

4032
02:41:18,760 --> 02:41:23,160
have one thread just blast through the

4033
02:41:20,600 --> 02:41:24,279
source file generate all the tokens for

4034
02:41:23,160 --> 02:41:26,040
the source file and those are just

4035
02:41:24,279 --> 02:41:28,640
sitting there linearly in memory right

4036
02:41:26,040 --> 02:41:30,800
you could use just you know virtual alic

4037
02:41:28,640 --> 02:41:32,359
or whatever to just put the tokens next

4038
02:41:30,800 --> 02:41:35,040
to each other and they're just like all

4039
02:41:32,359 --> 02:41:39,040
there that would be much bigger than the

4040
02:41:35,040 --> 02:41:41,160
source file um but source files don't

4041
02:41:39,040 --> 02:41:43,040
tend to be that big um and then you

4042
02:41:41,160 --> 02:41:47,680
could have the parser just read linearly

4043
02:41:43,040 --> 02:41:50,800
those tokens um I don't do that

4044
02:41:47,680 --> 02:41:54,200
because like I don't again it's not a

4045
02:41:50,800 --> 02:41:58,080
speed problem and it just someday if

4046
02:41:54,200 --> 02:42:01,880
that ever comes up as anywhere in the

4047
02:41:58,080 --> 02:42:04,120
top 500 issues with the compiler I could

4048
02:42:01,880 --> 02:42:08,000
think about it right that also doesn't

4049
02:42:04,120 --> 02:42:10,680
sound faster right it sounds slower what

4050
02:42:08,000 --> 02:42:13,240
you just described I mean it's sort of

4051
02:42:10,680 --> 02:42:16,120
like you are jumping around between

4052
02:42:13,240 --> 02:42:18,040
different code and maybe the has its own

4053
02:42:16,120 --> 02:42:20,120
data structures and maybe the parser

4054
02:42:18,040 --> 02:42:21,960
does so that you're touching different

4055
02:42:20,120 --> 02:42:24,080
pieces of memory but modern CPUs and

4056
02:42:21,960 --> 02:42:25,920
modern caches like it's not like parsing

4057
02:42:24,080 --> 02:42:29,080
is that complicated it's not like Lexing

4058
02:42:25,920 --> 02:42:32,160
is that complicated modern CPUs are

4059
02:42:29,080 --> 02:42:33,760
going to be able to hold all that easily

4060
02:42:32,160 --> 02:42:36,359
I would say I not having done the

4061
02:42:33,760 --> 02:42:39,680
performance analysis my guess is that

4062
02:42:36,359 --> 02:42:41,080
it's all fine and it doesn't matter um

4063
02:42:39,680 --> 02:42:42,520
and that's why I didn't really think

4064
02:42:41,080 --> 02:42:45,479
seriously about it's just fun to think

4065
02:42:42,520 --> 02:42:47,200
about though like oh yeah I could just I

4066
02:42:45,479 --> 02:42:51,120
could just really have a tight thing

4067
02:42:47,200 --> 02:42:54,120
that just cranks and in fact in fact I

4068
02:42:51,120 --> 02:42:56,200
could split the source file up at new

4069
02:42:54,120 --> 02:42:58,080
line boundaries into multiple and have

4070
02:42:56,200 --> 02:43:00,760
multiple threads generate this long

4071
02:42:58,080 --> 02:43:02,960
series of tokens in parallel and just

4072
02:43:00,760 --> 02:43:04,880
really up the token rate and you would

4073
02:43:02,960 --> 02:43:07,160
literally never notice this in the

4074
02:43:04,880 --> 02:43:08,880
resulting speed of the compiler because

4075
02:43:07,160 --> 02:43:11,479
well a is Casey said it may not actually

4076
02:43:08,880 --> 02:43:14,640
be faster I don't think it'll be faster

4077
02:43:11,479 --> 02:43:16,800
but B it's negligible in terms of the

4078
02:43:14,640 --> 02:43:18,640
time spent by the compiler

4079
02:43:16,800 --> 02:43:21,720
anyway don't make things more

4080
02:43:18,640 --> 02:43:24,279
complicated than they have to be

4081
02:43:21,720 --> 02:43:25,319
um someone's asking again is it faster

4082
02:43:24,279 --> 02:43:27,840
it doesn't

4083
02:43:25,319 --> 02:43:29,479
matter someone says I like grammar

4084
02:43:27,840 --> 02:43:31,520
specifications since you can then use a

4085
02:43:29,479 --> 02:43:35,359
parsel generator and you are good to go

4086
02:43:31,520 --> 02:43:35,359
cool story bro

4087
02:43:36,600 --> 02:43:41,600
um I think you have a definition of good

4088
02:43:39,640 --> 02:43:44,439
to go that is very different from my

4089
02:43:41,600 --> 02:43:45,880
definition of good to go maybe as long

4090
02:43:44,439 --> 02:43:47,920
as good to go means means you're good to

4091
02:43:45,880 --> 02:43:49,840
go rewrite it as something better you're

4092
02:43:47,920 --> 02:43:54,000
good to go get a job at

4093
02:43:49,840 --> 02:43:57,000
McDonald's oh God

4094
02:43:54,000 --> 02:43:57,000
okay

4095
02:43:57,240 --> 02:44:01,040
okay not that there's anything wrong

4096
02:43:59,279 --> 02:44:02,640
with having a job at McDonald's you're

4097
02:44:01,040 --> 02:44:07,200
good to go work somewhere else is I

4098
02:44:02,640 --> 02:44:08,880
guess what you're saying yes yeah um

4099
02:44:07,200 --> 02:44:11,720
you've shown your token structure in the

4100
02:44:08,880 --> 02:44:14,640
original parser's video what is the atom

4101
02:44:11,720 --> 02:44:17,040
star is that a string that's basically

4102
02:44:14,640 --> 02:44:20,279
um it was a way of interning the strings

4103
02:44:17,040 --> 02:44:21,840
on the lexer side so that you don't have

4104
02:44:20,279 --> 02:44:24,800
as many strings that you're allocating

4105
02:44:21,840 --> 02:44:27,800
and stuff um I don't have a separate

4106
02:44:24,800 --> 02:44:30,279
structure for that anymore um sometimes

4107
02:44:27,800 --> 02:44:31,880
I make decisions for clarity and then

4108
02:44:30,279 --> 02:44:34,439
later I'm like oh that actually wasn't

4109
02:44:31,880 --> 02:44:38,040
confusing right so you know we have a

4110
02:44:34,439 --> 02:44:40,279
car star for like what is the name of

4111
02:44:38,040 --> 02:44:44,760
this thing and that gets intered locally

4112
02:44:40,279 --> 02:44:46,520
to the lexer um now there can be

4113
02:44:44,760 --> 02:44:49,800
multiple threads parsing stuff because

4114
02:44:46,520 --> 02:44:53,399
we just load up a bunch of files and

4115
02:44:49,800 --> 02:44:55,960
parse them simultaneously and so in turn

4116
02:44:53,399 --> 02:44:57,200
for that Lex so the parser and the lexer

4117
02:44:55,960 --> 02:45:00,560
are like bundled although they're

4118
02:44:57,200 --> 02:45:04,399
essentially the same thing as far as

4119
02:45:00,560 --> 02:45:07,240
anyone should be concerned and so

4120
02:45:04,399 --> 02:45:08,560
um there's essentially a local cache of

4121
02:45:07,240 --> 02:45:10,120
what all the strings are for there but

4122
02:45:08,560 --> 02:45:12,720
you don't want to like synchronize that

4123
02:45:10,120 --> 02:45:16,800
with other threads because that just

4124
02:45:12,720 --> 02:45:18,560
seems like a lose uh so

4125
02:45:16,800 --> 02:45:21,120
so they're like kind of

4126
02:45:18,560 --> 02:45:23,479
intered

4127
02:45:21,120 --> 02:45:26,520
um

4128
02:45:23,479 --> 02:45:29,080
but and is that a good idea maybe not

4129
02:45:26,520 --> 02:45:31,279
anymore um like it used to be that

4130
02:45:29,080 --> 02:45:32,439
things were globally interned and what

4131
02:45:31,279 --> 02:45:34,840
that meant

4132
02:45:32,439 --> 02:45:36,120
was um you know like when you're

4133
02:45:34,840 --> 02:45:38,120
comparing

4134
02:45:36,120 --> 02:45:39,279
identifiers uh if you want to know that

4135
02:45:38,120 --> 02:45:40,720
this is the Declaration of this

4136
02:45:39,279 --> 02:45:42,960
identifier you just check if the string

4137
02:45:40,720 --> 02:45:44,840
pointer is the same right and that's

4138
02:45:42,960 --> 02:45:46,680
what that Adam struct was that like sort

4139
02:45:44,840 --> 02:45:49,560
of wrapped that to make it clear that

4140
02:45:46,680 --> 02:45:51,240
that's what was going on um but once I

4141
02:45:49,560 --> 02:45:54,840
went to a more parallel design for the

4142
02:45:51,240 --> 02:45:57,520
parsers it's like is that really worth

4143
02:45:54,840 --> 02:45:59,520
rescuing probably not because you don't

4144
02:45:57,520 --> 02:46:03,240
like do that many string

4145
02:45:59,520 --> 02:46:05,000
Compares and large name spaces are in a

4146
02:46:03,240 --> 02:46:06,760
hash table anyway and you have a hash

4147
02:46:05,000 --> 02:46:09,439
table for the identifier and you can

4148
02:46:06,760 --> 02:46:12,200
compare that to see if it's the same

4149
02:46:09,439 --> 02:46:13,840
so there's not really much like the

4150
02:46:12,200 --> 02:46:15,120
complexity you would lose in making

4151
02:46:13,840 --> 02:46:16,399
threads synchronize with each other

4152
02:46:15,120 --> 02:46:18,920
other to make sure they had the right

4153
02:46:16,399 --> 02:46:20,560
canonical version of an identifier is

4154
02:46:18,920 --> 02:46:24,200
like that's just way worse than whatever

4155
02:46:20,560 --> 02:46:26,399
the gain would be I think but again we

4156
02:46:24,200 --> 02:46:28,520
have never we have literally never been

4157
02:46:26,399 --> 02:46:30,560
hardcore about making this compiler go

4158
02:46:28,520 --> 02:46:33,399
fast it's like there have been a few

4159
02:46:30,560 --> 02:46:35,319
times a couple years apart each who I

4160
02:46:33,399 --> 02:46:38,840
spent a couple days doing some stuff to

4161
02:46:35,319 --> 02:46:41,600
make it faster and you

4162
02:46:38,840 --> 02:46:44,000
know you can compare the speed that you

4163
02:46:41,600 --> 02:46:45,720
see to something like GCC or clang and

4164
02:46:44,000 --> 02:46:49,000
decide

4165
02:46:45,720 --> 02:46:50,240
what you think of it um but but it's

4166
02:46:49,000 --> 02:46:51,800
just to say that we could have much

4167
02:46:50,240 --> 02:46:53,840
greater levels of speed if we actually

4168
02:46:51,800 --> 02:46:55,720
did that like we haven't designed for

4169
02:46:53,840 --> 02:46:58,200
Speed I don't even know it's been

4170
02:46:55,720 --> 02:47:00,160
complicated enough to to solve the

4171
02:46:58,200 --> 02:47:02,399
fundamental problem of just implementing

4172
02:47:00,160 --> 02:47:04,920
the semantics of this language that I

4173
02:47:02,399 --> 02:47:06,800
just I mean I know I'm designing for not

4174
02:47:04,920 --> 02:47:09,279
pathologically dumb and slow but we're

4175
02:47:06,800 --> 02:47:12,399
not designed for fast yet that I

4176
02:47:09,279 --> 02:47:13,920
hopefully will come later

4177
02:47:12,399 --> 02:47:16,560
um

4178
02:47:13,920 --> 02:47:20,600
someday someday not too long in the

4179
02:47:16,560 --> 02:47:22,439
future I'm going to believe I'm going to

4180
02:47:20,600 --> 02:47:24,160
believe uh could you give us your

4181
02:47:22,439 --> 02:47:25,720
thoughts about IR if it's a valid thing

4182
02:47:24,160 --> 02:47:29,600
and generate bite code yeah we generate

4183
02:47:25,720 --> 02:47:31,000
bite code um I think that's the main so

4184
02:47:29,600 --> 02:47:34,200
you have to kind of understand what is

4185
02:47:31,000 --> 02:47:36,439
the job of that right and it it'll make

4186
02:47:34,200 --> 02:47:38,439
sense if you understand what it's for so

4187
02:47:36,439 --> 02:47:43,920
if you want a compiler that lets you

4188
02:47:38,439 --> 02:47:46,600
compile your code for multiple CPUs or

4189
02:47:43,920 --> 02:47:48,880
even you know well let's just say

4190
02:47:46,600 --> 02:47:50,880
multiple CPUs keep it simple and the

4191
02:47:48,880 --> 02:47:53,040
CPUs are very different from each other

4192
02:47:50,880 --> 02:47:55,200
and they have different instructions

4193
02:47:53,040 --> 02:47:58,479
that don't necessarily have analoges of

4194
02:47:55,200 --> 02:48:01,399
each other sometimes

4195
02:47:58,479 --> 02:48:03,800
um and you also don't want to have to

4196
02:48:01,399 --> 02:48:06,279
completely rewrite your whole compiler

4197
02:48:03,800 --> 02:48:08,560
next time there's a new CPU there's not

4198
02:48:06,279 --> 02:48:12,399
been a lot of CPU Innovation lately it's

4199
02:48:08,560 --> 02:48:14,880
all incremental but maybe someday once

4200
02:48:12,399 --> 02:48:16,479
AIS are all designing CPUs instead of

4201
02:48:14,880 --> 02:48:19,760
people will actually make some progress

4202
02:48:16,479 --> 02:48:20,720
again right um except the AIS are all

4203
02:48:19,760 --> 02:48:23,880
example

4204
02:48:20,720 --> 02:48:26,520
based they'll just be re done versions

4205
02:48:23,880 --> 02:48:28,200
of the existing CPUs they'll make amd64

4206
02:48:26,520 --> 02:48:30,439
instruction set except there's three

4207
02:48:28,200 --> 02:48:35,720
more padding bites on the front that

4208
02:48:30,439 --> 02:48:35,720
like tell you different things yeah um

4209
02:48:36,040 --> 02:48:43,240
so uh so what the bite code is for is to

4210
02:48:40,520 --> 02:48:46,880
let you do instruction-based code

4211
02:48:43,240 --> 02:48:49,080
generation which is is very important

4212
02:48:46,880 --> 02:48:50,880
like you know your computer actually

4213
02:48:49,080 --> 02:48:52,720
runs

4214
02:48:50,880 --> 02:48:54,880
instructions that you could sort of

4215
02:48:52,720 --> 02:48:56,560
write them out one per line and they're

4216
02:48:54,880 --> 02:48:58,160
relatively simple compared to a higher

4217
02:48:56,560 --> 02:49:01,279
level program and like that's just the

4218
02:48:58,160 --> 02:49:03,520
way the CPU operates and so the job of

4219
02:49:01,279 --> 02:49:06,359
the compiler is in some sense to bridge

4220
02:49:03,520 --> 02:49:09,080
the gap between text that some dude

4221
02:49:06,359 --> 02:49:12,319
wrote right and then that list of

4222
02:49:09,080 --> 02:49:15,080
instructions that the CPU understands

4223
02:49:12,319 --> 02:49:18,000
and the step the steps that we've been

4224
02:49:15,080 --> 02:49:19,600
talking about so far are mostly about so

4225
02:49:18,000 --> 02:49:22,439
first of all Parson getting that tree

4226
02:49:19,600 --> 02:49:24,760
representation what is the tree the tree

4227
02:49:22,439 --> 02:49:26,920
is a representation of what has to

4228
02:49:24,760 --> 02:49:29,120
happen when but it's not not that linear

4229
02:49:26,920 --> 02:49:31,560
you have to like do a walk on it and you

4230
02:49:29,120 --> 02:49:33,200
probably have to do you know once you

4231
02:49:31,560 --> 02:49:35,319
look up the identifiers and figure out

4232
02:49:33,200 --> 02:49:37,920
what the function overloading are and

4233
02:49:35,319 --> 02:49:39,520
whatever happens you end up with a

4234
02:49:37,920 --> 02:49:42,239
result later that's like more like the

4235
02:49:39,520 --> 02:49:44,160
semantic version of the tree right the

4236
02:49:42,239 --> 02:49:46,279
semantic version of the tree has all

4237
02:49:44,160 --> 02:49:47,640
these blocks and stuff but not not the

4238
02:49:46,279 --> 02:49:49,840
basic blocks we were talking about but

4239
02:49:47,640 --> 02:49:51,680
like blocks of instructions um and then

4240
02:49:49,840 --> 02:49:53,800
you have to go somehow from here's an

4241
02:49:51,680 --> 02:49:57,200
array of instructions that are still

4242
02:49:53,800 --> 02:49:59,600
represented as tree nodes to

4243
02:49:57,200 --> 02:50:02,960
like something more like instructions

4244
02:49:59,600 --> 02:50:06,720
from a CPU and and then you could do

4245
02:50:02,960 --> 02:50:09,560
that separately per CPU you could say

4246
02:50:06,720 --> 02:50:13,760
okay here's my back end that walks the

4247
02:50:09,560 --> 02:50:15,520
tree and generates code for x86 here's

4248
02:50:13,760 --> 02:50:17,520
one that does it for arms and the

4249
02:50:15,520 --> 02:50:19,920
problem with that is that you will end

4250
02:50:17,520 --> 02:50:20,880
up with way way way way way too much of

4251
02:50:19,920 --> 02:50:24,560
the

4252
02:50:20,880 --> 02:50:29,319
compiler uh duplicated between all

4253
02:50:24,560 --> 02:50:29,319
those and it'll just be a huge mess

4254
02:50:30,000 --> 02:50:34,439
because it's just an interesting

4255
02:50:32,000 --> 02:50:36,439
situation where there are quite a few

4256
02:50:34,439 --> 02:50:39,399
optimizations that you want to do with a

4257
02:50:36,439 --> 02:50:41,120
particular CPU in mind but there are

4258
02:50:39,399 --> 02:50:43,760
really most optimizations that you want

4259
02:50:41,120 --> 02:50:45,520
to do are not even particular to a CPU

4260
02:50:43,760 --> 02:50:48,960
it's just like

4261
02:50:45,520 --> 02:50:52,000
hey I realized that inside this

4262
02:50:48,960 --> 02:50:54,680
scope I Define this variable once and

4263
02:50:52,000 --> 02:50:57,479
then nobody else can write to it and

4264
02:50:54,680 --> 02:50:59,399
that means a lot of things in terms of

4265
02:50:57,479 --> 02:51:01,600
you know what instructions we would

4266
02:50:59,399 --> 02:51:03,359
generate and that's invariant to

4267
02:51:01,600 --> 02:51:05,840
whatever the CPU is that's running the

4268
02:51:03,359 --> 02:51:08,200
code and so that kind of optimization

4269
02:51:05,840 --> 02:51:11,279
you want to happen you want to write

4270
02:51:08,200 --> 02:51:12,160
that once hopefully in as simple a way

4271
02:51:11,279 --> 02:51:14,000
as

4272
02:51:12,160 --> 02:51:16,239
possible because there's going to be

4273
02:51:14,000 --> 02:51:18,319
actually a large number of these right

4274
02:51:16,239 --> 02:51:20,960
and all the things we alluded to before

4275
02:51:18,319 --> 02:51:23,760
like a data flow graph or control flow

4276
02:51:20,960 --> 02:51:24,640
graph or whatever are used to figure out

4277
02:51:23,760 --> 02:51:28,319
these

4278
02:51:24,640 --> 02:51:31,120
things like what can we rely on that's

4279
02:51:28,319 --> 02:51:33,640
true so that we know so that we can be

4280
02:51:31,120 --> 02:51:36,120
smarter about generating code because

4281
02:51:33,640 --> 02:51:38,080
what makes code dumb and Bloated is like

4282
02:51:36,120 --> 02:51:41,080
if you can't be sure about something

4283
02:51:38,080 --> 02:51:42,040
right so the C keyword restrict is like

4284
02:51:41,080 --> 02:51:44,080
a

4285
02:51:42,040 --> 02:51:45,680
Band-Aid I I don't mean that too

4286
02:51:44,080 --> 02:51:47,120
pejorative because it's like I'm not

4287
02:51:45,680 --> 02:51:49,680
sure what else you would do in that

4288
02:51:47,120 --> 02:51:51,399
situation but it's a way of saying like

4289
02:51:49,680 --> 02:51:55,720
look you can assume certain things about

4290
02:51:51,399 --> 02:51:57,840
this pointer so um you know if you're

4291
02:51:55,720 --> 02:51:59,439
reading some other value you don't have

4292
02:51:57,840 --> 02:52:01,640
to assume for example that a right

4293
02:51:59,439 --> 02:52:04,279
through this pointer change this other

4294
02:52:01,640 --> 02:52:06,520
seemingly unrelated value if it seems to

4295
02:52:04,279 --> 02:52:07,840
be unrelated it really is unrelated so

4296
02:52:06,520 --> 02:52:10,600
you don't have to keep reloading it all

4297
02:52:07,840 --> 02:52:12,920
the time and whatever to make sure um

4298
02:52:10,600 --> 02:52:15,080
all that kind of stuff the CPU doesn't

4299
02:52:12,920 --> 02:52:16,920
matter right and so you want to

4300
02:52:15,080 --> 02:52:18,960
implement it and debug it and make it

4301
02:52:16,920 --> 02:52:20,560
work well right and then so that

4302
02:52:18,960 --> 02:52:22,680
shouldn't stop you from doing CPU

4303
02:52:20,560 --> 02:52:25,600
specific optimizations but those happen

4304
02:52:22,680 --> 02:52:30,239
in like the actual back end right but

4305
02:52:25,600 --> 02:52:32,960
the bite code instructions um get you a

4306
02:52:30,239 --> 02:52:36,239
substantial amount of the distance from

4307
02:52:32,960 --> 02:52:38,479
well you know from the semantic tree to

4308
02:52:36,239 --> 02:52:40,960
the actual instructions on the CPU right

4309
02:52:38,479 --> 02:52:43,399
and then it's much easier to say oh I

4310
02:52:40,960 --> 02:52:45,319
have I have like a Vite code for some

4311
02:52:43,399 --> 02:52:49,279
fictitious virtual machine machine of my

4312
02:52:45,319 --> 02:52:51,520
own that's a an array of

4313
02:52:49,279 --> 02:52:52,880
instructions with my own you know the

4314
02:52:51,520 --> 02:52:54,319
way it's implemented is there's a

4315
02:52:52,880 --> 02:52:55,040
program counter or whatever and it's

4316
02:52:54,319 --> 02:52:57,239
just

4317
02:52:55,040 --> 02:52:58,840
running you know in in a in an

4318
02:52:57,239 --> 02:53:02,000
interpreter

4319
02:52:58,840 --> 02:53:03,880
essentially mapping from that to

4320
02:53:02,000 --> 02:53:07,880
instructions on a CPU is a much much

4321
02:53:03,880 --> 02:53:10,840
closer mapping and and so then you can

4322
02:53:07,880 --> 02:53:14,040
get away with

4323
02:53:10,840 --> 02:53:16,359
uh having a lot less code than you would

4324
02:53:14,040 --> 02:53:16,359
otherwise

4325
02:53:17,239 --> 02:53:21,800
right um how do you organize identifiers

4326
02:53:20,279 --> 02:53:25,479
in the scope hierarchy it's really

4327
02:53:21,800 --> 02:53:26,800
stupid I I don't it's it's not good

4328
02:53:25,479 --> 02:53:29,920
we'll put it that

4329
02:53:26,800 --> 02:53:32,399
way um how to make a good optimizing

4330
02:53:29,920 --> 02:53:34,479
compiler I mean that's the hard part so

4331
02:53:32,399 --> 02:53:36,239
you know earlier we I kept saying

4332
02:53:34,479 --> 02:53:39,439
parsing is the easy part other things

4333
02:53:36,239 --> 02:53:42,120
are hard really the only hard thing in

4334
02:53:39,439 --> 02:53:45,239
compilers is optimization well and

4335
02:53:42,120 --> 02:53:47,479
proving your program is correct which is

4336
02:53:45,239 --> 02:53:50,000
basically impossible right now

4337
02:53:47,479 --> 02:53:52,319
um those are the things that are hard

4338
02:53:50,000 --> 02:53:54,520
like all the other stuff is easy um I

4339
02:53:52,319 --> 02:53:56,680
mean maybe maybe like design is an art

4340
02:53:54,520 --> 02:53:59,000
so you could say designing the right

4341
02:53:56,680 --> 02:54:02,439
thing is hard but in terms of actually

4342
02:53:59,000 --> 02:54:04,960
what you type

4343
02:54:02,439 --> 02:54:06,760
um actually it's sort of a lie the the

4344
02:54:04,960 --> 02:54:08,840
other thing that's hard is just if your

4345
02:54:06,760 --> 02:54:12,720
feature set is really ambitious as ours

4346
02:54:08,840 --> 02:54:14,399
is um you just end up with this kind of

4347
02:54:12,720 --> 02:54:15,960
car crash in the middle of the inter

4348
02:54:14,399 --> 02:54:19,760
section where all sorts of stuff is

4349
02:54:15,960 --> 02:54:21,279
happening all the time and like all like

4350
02:54:19,760 --> 02:54:23,920
part of the beauty of a programming

4351
02:54:21,279 --> 02:54:25,880
language is like all these things are

4352
02:54:23,920 --> 02:54:28,680
just Expressions right

4353
02:54:25,880 --> 02:54:30,640
and they interact with each other and

4354
02:54:28,680 --> 02:54:32,399
and you have these features that you can

4355
02:54:30,640 --> 02:54:35,600
use on the expressions in your language

4356
02:54:32,399 --> 02:54:37,680
or whatever and the more features that

4357
02:54:35,600 --> 02:54:39,760
you give people the more that they have

4358
02:54:37,680 --> 02:54:41,200
to work all the time in concert with

4359
02:54:39,760 --> 02:54:43,640
each other and that generates a kind of

4360
02:54:41,200 --> 02:54:45,000
an N squared explosion of potential

4361
02:54:43,640 --> 02:54:46,479
problems

4362
02:54:45,000 --> 02:54:48,800
that's actually the other hard thing

4363
02:54:46,479 --> 02:54:50,439
besides optimization is just but that's

4364
02:54:48,800 --> 02:54:51,880
the same thing as in other program

4365
02:54:50,439 --> 02:54:54,000
that's the same thing as in video games

4366
02:54:51,880 --> 02:54:55,640
right is it's just like at some point

4367
02:54:54,000 --> 02:54:58,279
what we're trying to do is really

4368
02:54:55,640 --> 02:55:00,560
complicated and it's becomes difficult

4369
02:54:58,279 --> 02:55:04,120
to understand even what we're doing and

4370
02:55:00,560 --> 02:55:07,800
how to do it well and that's always

4371
02:55:04,120 --> 02:55:09,560
especially these days why I'm very

4372
02:55:07,800 --> 02:55:11,319
concerned with simplifying things all

4373
02:55:09,560 --> 02:55:13,200
the time because I've just suffered

4374
02:55:11,319 --> 02:55:14,640
through too much of like oh all these

4375
02:55:13,200 --> 02:55:18,200
things are way more complicated at than

4376
02:55:14,640 --> 02:55:20,479
they need to be it's causing

4377
02:55:18,200 --> 02:55:22,080
problems but bad problems and then

4378
02:55:20,479 --> 02:55:24,920
really bad problems right so bad

4379
02:55:22,080 --> 02:55:27,520
problems are like oh it's taking 30% 50%

4380
02:55:24,920 --> 02:55:29,279
longer because of all this friction 90%

4381
02:55:27,520 --> 02:55:31,439
longer those are bad you might run out

4382
02:55:29,279 --> 02:55:33,319
of money or get depressed and never

4383
02:55:31,439 --> 02:55:34,399
finish your project but the worst

4384
02:55:33,319 --> 02:55:39,920
problem

4385
02:55:34,399 --> 02:55:41,800
is like I have in my brain some Maximum

4386
02:55:39,920 --> 02:55:44,880
ability to

4387
02:55:41,800 --> 02:55:47,880
visualize something that I could work on

4388
02:55:44,880 --> 02:55:47,880
right

4389
02:55:50,399 --> 02:55:56,640
and like if I could somehow go to the

4390
02:55:54,200 --> 02:55:58,160
gym and work that out and and make it

4391
02:55:56,640 --> 02:56:00,479
better which I think is what programming

4392
02:55:58,160 --> 02:56:02,560
does like I'm not claiming this is fixed

4393
02:56:00,479 --> 02:56:04,239
but it probably slowly grows over time

4394
02:56:02,560 --> 02:56:05,760
although someday maybe I'm getting old

4395
02:56:04,239 --> 02:56:09,680
and it'll shrink but I feel like it's

4396
02:56:05,760 --> 02:56:11,600
still growing um so what I can even

4397
02:56:09,680 --> 02:56:13,720
ignoring the friction component what I

4398
02:56:11,600 --> 02:56:18,399
could even ever accomplish is kind of

4399
02:56:13,720 --> 02:56:21,760
bound by my ability to harness a complex

4400
02:56:18,399 --> 02:56:26,120
situation and deal with it mentally

4401
02:56:21,760 --> 02:56:27,520
right um and so there's there's only a

4402
02:56:26,120 --> 02:56:29,200
certain amount of space in there and if

4403
02:56:27,520 --> 02:56:30,600
you take up a bunch of that space with

4404
02:56:29,200 --> 02:56:32,920
stupid stuff being a lot more

4405
02:56:30,600 --> 02:56:36,319
complicated than it needs to be there's

4406
02:56:32,920 --> 02:56:38,760
less space for other stuff and so

4407
02:56:36,319 --> 02:56:40,680
the the total functionality that you're

4408
02:56:38,760 --> 02:56:42,160
able to do is smaller right because you

4409
02:56:40,680 --> 02:56:45,000
just wasted a bunch of

4410
02:56:42,160 --> 02:56:48,359
it um and I don't think people take that

4411
02:56:45,000 --> 02:56:49,920
very seriously and I think because well

4412
02:56:48,359 --> 02:56:51,120
it's it's in a different guys right

4413
02:56:49,920 --> 02:56:53,600
because I've done a lot of stuff where

4414
02:56:51,120 --> 02:56:56,359
I'm the main programmer I see that very

4415
02:56:53,600 --> 02:57:00,239
directly right um when you have a

4416
02:56:56,359 --> 02:57:01,800
company like you know Google or someone

4417
02:57:00,239 --> 02:57:04,239
Twitter old Twitter

4418
02:57:01,800 --> 02:57:09,479
especially

4419
02:57:04,239 --> 02:57:11,000
bang it doesn't fail in the same way um

4420
02:57:09,479 --> 02:57:13,160
what happens is you actually hire more

4421
02:57:11,000 --> 02:57:14,680
and more people and then those people

4422
02:57:13,160 --> 02:57:16,399
know less

4423
02:57:14,680 --> 02:57:19,399
and the the quality of the product

4424
02:57:16,399 --> 02:57:20,760
starts just sliding downhill because

4425
02:57:19,399 --> 02:57:22,880
there's

4426
02:57:20,760 --> 02:57:25,880
no there's

4427
02:57:22,880 --> 02:57:28,439
like making complex software work well

4428
02:57:25,880 --> 02:57:30,640
is a coordination problem like there's

4429
02:57:28,439 --> 02:57:32,040
all these issues that need to be handled

4430
02:57:30,640 --> 02:57:33,880
and there need to be things that handle

4431
02:57:32,040 --> 02:57:36,439
them and those wires need to be like all

4432
02:57:33,880 --> 02:57:39,359
hooked up

4433
02:57:36,439 --> 02:57:42,080
and that can get very complicated and at

4434
02:57:39,359 --> 02:57:43,720
some point if there's a lot of people

4435
02:57:42,080 --> 02:57:46,080
with small enough responsibility those

4436
02:57:43,720 --> 02:57:48,640
people can't see this well enough and so

4437
02:57:46,080 --> 02:57:50,479
they just do their local area of it and

4438
02:57:48,640 --> 02:57:53,359
it screws up other

4439
02:57:50,479 --> 02:57:56,160
things and just

4440
02:57:53,359 --> 02:57:58,319
nobody nobody even like sees the

4441
02:57:56,160 --> 02:57:59,279
perspective that would have avoided that

4442
02:57:58,319 --> 02:58:02,000
and

4443
02:57:59,279 --> 02:58:04,520
so I don't know I I think that's the

4444
02:58:02,000 --> 02:58:07,399
number one problem in software actually

4445
02:58:04,520 --> 02:58:08,880
and llm someone's going to say llms llms

4446
02:58:07,399 --> 02:58:10,920
don't actually understand anything

4447
02:58:08,880 --> 02:58:14,000
currently so they can't help you with

4448
02:58:10,920 --> 02:58:17,920
that maybe someday we will solve Ai and

4449
02:58:14,000 --> 02:58:17,920
will help you but right now it

4450
02:58:18,239 --> 02:58:23,359
doesn't all right I feel like we've been

4451
02:58:21,080 --> 02:58:26,120
going a long time it's been two hour no

4452
02:58:23,359 --> 02:58:28,640
three hours three hours I think yeah

4453
02:58:26,120 --> 02:58:30,040
dude I'm we're cutting into my video

4454
02:58:28,640 --> 02:58:33,520
game playing

4455
02:58:30,040 --> 02:58:37,399
time uh here's the thing though John is

4456
02:58:33,520 --> 02:58:39,399
I have seen you uh your stream being

4457
02:58:37,399 --> 02:58:41,600
titled or saying that you are going to

4458
02:58:39,399 --> 02:58:43,239
escape from tarov and you clearly have

4459
02:58:41,600 --> 02:58:45,640
not escaped because if you're still

4460
02:58:43,239 --> 02:58:49,239
there if you're you're still playing I

4461
02:58:45,640 --> 02:58:50,760
mean what's the explanation well you see

4462
02:58:49,239 --> 02:58:52,920
you must be really lousy at this video

4463
02:58:50,760 --> 02:58:54,760
game if you can't escape after this many

4464
02:58:52,920 --> 02:58:56,840
hours you just have to the only thing

4465
02:58:54,760 --> 02:58:59,279
the game is called is escape from

4466
02:58:56,840 --> 02:59:01,279
darkov yeah well it's like it's like

4467
02:58:59,279 --> 02:59:03,239
slaying the complexity of compiler

4468
02:59:01,279 --> 02:59:05,560
design with ler parser generator and

4469
02:59:03,239 --> 02:59:08,080
syntax directed translation if it didn't

4470
02:59:05,560 --> 02:59:11,239
work the first time you just got to keep

4471
02:59:08,080 --> 02:59:14,800
swinging that ler parser generator sword

4472
02:59:11,239 --> 02:59:17,040
one of those times y it'll work

4473
02:59:14,800 --> 02:59:18,880
yep all right thank you everybody I do

4474
02:59:17,040 --> 02:59:22,160
have to say

4475
02:59:18,880 --> 02:59:25,960
um some of my answers were not that good

4476
02:59:22,160 --> 02:59:30,640
es especially in the latter half so um I

4477
02:59:25,960 --> 02:59:32,520
I regret this but um at the same time

4478
02:59:30,640 --> 02:59:34,640
this is just what we're able to do in

4479
02:59:32,520 --> 02:59:36,960
like this is not my job and I have all

4480
02:59:34,640 --> 02:59:39,120
this stuff I have to do and I do want to

4481
02:59:36,960 --> 02:59:41,000
someday write a compiler book because I

4482
02:59:39,120 --> 02:59:42,279
think I think it would be different from

4483
02:59:41,000 --> 02:59:45,080
everybody else's and I think it would be

4484
02:59:42,279 --> 02:59:46,479
a good contribution and that that will

4485
02:59:45,080 --> 02:59:48,920
be much more

4486
02:59:46,479 --> 02:59:51,960
premeditated um and the cover will be

4487
02:59:48,920 --> 02:59:53,920
awesome what we like the cover will be

4488
02:59:51,960 --> 02:59:56,120
amazing I don't know what it'll be but

4489
02:59:53,920 --> 02:59:59,000
it'll be amazing that's right yeah all

4490
02:59:56,120 --> 03:00:02,439
right but thanks for coming by and

4491
02:59:59,000 --> 03:00:05,840
so what I would like to end with an

4492
03:00:02,439 --> 03:00:08,600
exhortation oh of

4493
03:00:05,840 --> 03:00:10,080
please for this entire class of things

4494
03:00:08,600 --> 03:00:12,000
so again to review for people who

4495
03:00:10,080 --> 03:00:15,319
weren't

4496
03:00:12,000 --> 03:00:17,479
here the entire point of this was how

4497
03:00:15,319 --> 03:00:19,399
actually simple this parsing precedence

4498
03:00:17,479 --> 03:00:20,960
thing is that everybody's not everybody

4499
03:00:19,399 --> 03:00:23,279
but most people have made a big deal out

4500
03:00:20,960 --> 03:00:26,520
of and and how difficult it is to find

4501
03:00:23,279 --> 03:00:26,520
the right information and

4502
03:00:27,200 --> 03:00:31,120
culturally we need to recognize that

4503
03:00:29,359 --> 03:00:32,560
this is a problem like a lot of things

4504
03:00:31,120 --> 03:00:36,040
are actually pretty

4505
03:00:32,560 --> 03:00:38,279
simple and for some reason we're not

4506
03:00:36,040 --> 03:00:41,960
doing a good job of understanding those

4507
03:00:38,279 --> 03:00:45,040
things collectively as like everybody

4508
03:00:41,960 --> 03:00:46,359
and so one thing to do is when you find

4509
03:00:45,040 --> 03:00:48,160
something like this that's actually

4510
03:00:46,359 --> 03:00:49,920
simple now you don't want to be you

4511
03:00:48,160 --> 03:00:53,319
don't want to be a bozo and claim

4512
03:00:49,920 --> 03:00:55,520
something is really simple when it's not

4513
03:00:53,319 --> 03:00:57,479
because some things are complicated but

4514
03:00:55,520 --> 03:01:00,560
when things are really

4515
03:00:57,479 --> 03:01:02,080
simple just helping to signal boost the

4516
03:01:00,560 --> 03:01:05,640
fact that they're simple and they don't

4517
03:01:02,080 --> 03:01:07,800
require you to get a degree in you know

4518
03:01:05,640 --> 03:01:10,920
parsing science or whatever to know that

4519
03:01:07,800 --> 03:01:13,080
times goes before plus like that's just

4520
03:01:10,920 --> 03:01:15,120
it's just not how it is but you would

4521
03:01:13,080 --> 03:01:16,920
think it was and a lot of people who got

4522
03:01:15,120 --> 03:01:20,560
computer science degrees think it that's

4523
03:01:16,920 --> 03:01:23,840
how it is um but the point is there's

4524
03:01:20,560 --> 03:01:26,120
many things like this and if you could

4525
03:01:23,840 --> 03:01:27,279
pitch in and let people know when things

4526
03:01:26,120 --> 03:01:31,160
are

4527
03:01:27,279 --> 03:01:32,640
simple that's great and it's fun to do

4528
03:01:31,160 --> 03:01:34,520
that's the thing I mean Casey could

4529
03:01:32,640 --> 03:01:36,479
probably vouch for this because you do a

4530
03:01:34,520 --> 03:01:38,520
lot more of this now these days than me

4531
03:01:36,479 --> 03:01:41,560
of just like explaining stuff to people

4532
03:01:38,520 --> 03:01:44,560
it's like finding a good

4533
03:01:41,560 --> 03:01:46,600
explanation that's as simple as you

4534
03:01:44,560 --> 03:01:48,560
could make it and making sure you really

4535
03:01:46,600 --> 03:01:49,720
understand it and then presenting it

4536
03:01:48,560 --> 03:01:51,920
even though I mean again I went through

4537
03:01:49,720 --> 03:01:53,760
an emac file with like some trees as

4538
03:01:51,920 --> 03:01:56,200
like slashes so it's not like I wrote a

4539
03:01:53,760 --> 03:01:58,160
book again but like it's an enjoyable

4540
03:01:56,200 --> 03:02:00,399
process and you understand it better at

4541
03:01:58,160 --> 03:02:02,560
the end but then you feel good because

4542
03:02:00,399 --> 03:02:05,720
it's like look I gave people this thing

4543
03:02:02,560 --> 03:02:08,080
right and so we need more of that and

4544
03:02:05,720 --> 03:02:10,640
less of like I'm writing this thing to

4545
03:02:08,080 --> 03:02:14,319
show everybody I'm

4546
03:02:10,640 --> 03:02:17,600
smart that's what I would say all

4547
03:02:14,319 --> 03:02:21,680
yeah also I guess one problem that we

4548
03:02:17,600 --> 03:02:23,080
have as well uh so so I mean not to can

4549
03:02:21,680 --> 03:02:26,720
keep this discussion going any longer

4550
03:02:23,080 --> 03:02:30,439
since it's been too long already but

4551
03:02:26,720 --> 03:02:35,239
um I think it's harder than your exert

4552
03:02:30,439 --> 03:02:37,120
makes it out to be though because like I

4553
03:02:35,239 --> 03:02:38,720
mean we literally just had a thing on

4554
03:02:37,120 --> 03:02:40,239
Twitter where someone was like I figured

4555
03:02:38,720 --> 03:02:41,760
out how to check if a points in a

4556
03:02:40,239 --> 03:02:44,399
polygon and it was like the worst

4557
03:02:41,760 --> 03:02:46,560
algorithm I've literally ever seen that

4558
03:02:44,399 --> 03:02:49,359
but that guy was not really a programmer

4559
03:02:46,560 --> 03:02:52,960
whatever and it's just the problem is

4560
03:02:49,359 --> 03:02:56,439
that that knowing when something is

4561
03:02:52,960 --> 03:02:59,520
simple and easy to understand is itself

4562
03:02:56,439 --> 03:03:02,399
a very hard thing to do and most people

4563
03:02:59,520 --> 03:03:04,600
can't do it they think they have found a

4564
03:03:02,399 --> 03:03:06,000
good explanation and it's awful like I

4565
03:03:04,600 --> 03:03:07,600
don't think the people who wrote The

4566
03:03:06,000 --> 03:03:09,640
Dragon book think that their

4567
03:03:07,600 --> 03:03:12,640
explanations are awful but they are

4568
03:03:09,640 --> 03:03:15,439
right and so I don't know like the

4569
03:03:12,640 --> 03:03:17,760
problem is harder you're no I agree with

4570
03:03:15,439 --> 03:03:19,560
that out and I don't know what the

4571
03:03:17,760 --> 03:03:21,760
solution I don't know what if there is a

4572
03:03:19,560 --> 03:03:23,800
solution I think there is incremental

4573
03:03:21,760 --> 03:03:25,479
Improvement that can be made that causes

4574
03:03:23,800 --> 03:03:27,640
feedback that accelerates the

4575
03:03:25,479 --> 03:03:29,520
Improvement so the problem is really

4576
03:03:27,640 --> 03:03:31,560
that the culture is broken right and

4577
03:03:29,520 --> 03:03:34,640
it's broken for a lot of reasons this is

4578
03:03:31,560 --> 03:03:37,840
just merely one of the loes of

4579
03:03:34,640 --> 03:03:42,120
Brokenness of of what's happening right

4580
03:03:37,840 --> 03:03:47,120
um but it's a it's a major one really um

4581
03:03:42,120 --> 03:03:49,640
and like if we kind of had a no [ __ ]

4582
03:03:47,120 --> 03:03:52,960
culture in programming which there used

4583
03:03:49,640 --> 03:03:55,080
to be like I caught the tail end of that

4584
03:03:52,960 --> 03:03:58,040
in college right it was still kind of

4585
03:03:55,080 --> 03:04:00,560
gone by the time I was there but um you

4586
03:03:58,040 --> 03:04:02,640
know nowadays it's the opposite it's

4587
03:04:00,560 --> 03:04:04,640
like programming is like full [ __ ]

4588
03:04:02,640 --> 03:04:05,600
fire hose culture right it's like

4589
03:04:04,640 --> 03:04:09,760
somehow

4590
03:04:05,600 --> 03:04:12,399
inverted and you know I it doesn't have

4591
03:04:09,760 --> 03:04:14,960
to require being blunt or mean but just

4592
03:04:12,399 --> 03:04:18,279
like having a low

4593
03:04:14,960 --> 03:04:20,520
tolerance for nonsense or having a low

4594
03:04:18,279 --> 03:04:22,279
tolerance well here's the thing how does

4595
03:04:20,520 --> 03:04:24,760
something like the Dragon book propagate

4596
03:04:22,279 --> 03:04:24,760
it's like

4597
03:04:26,640 --> 03:04:32,520
well a lot of things have to go wrong

4598
03:04:29,640 --> 03:04:36,279
it's like first of all the better

4599
03:04:32,520 --> 03:04:39,120
explanations have to be ignored right

4600
03:04:36,279 --> 03:04:42,000
somehow and

4601
03:04:39,120 --> 03:04:43,680
then people have to think that this is

4602
03:04:42,000 --> 03:04:45,399
actually a good enough explanation that

4603
03:04:43,680 --> 03:04:49,920
doesn't requ improvement over the

4604
03:04:45,399 --> 03:04:51,439
decades that it's been used right um and

4605
03:04:49,920 --> 03:04:53,720
how do they think that do they read the

4606
03:04:51,439 --> 03:04:55,399
explanation and think they understand it

4607
03:04:53,720 --> 03:04:58,359
right I

4608
03:04:55,399 --> 03:04:59,840
mean I would claim like there are

4609
03:04:58,359 --> 03:05:01,560
different levels of understanding but I

4610
03:04:59,840 --> 03:05:03,080
would claim ultimately that the answer

4611
03:05:01,560 --> 03:05:04,920
has to be no

4612
03:05:03,080 --> 03:05:07,720
because if

4613
03:05:04,920 --> 03:05:09,359
you if you look at all this complexity

4614
03:05:07,720 --> 03:05:12,359
that you're building in order to do this

4615
03:05:09,359 --> 03:05:14,359
simple thing it's like but wait I know

4616
03:05:12,359 --> 03:05:16,600
what I can Pro that was the realization

4617
03:05:14,359 --> 03:05:18,680
I had in college after doing like five

4618
03:05:16,600 --> 03:05:20,680
languages or something was like wait I

4619
03:05:18,680 --> 03:05:23,279
know what I could program and I know

4620
03:05:20,680 --> 03:05:24,880
what this thing is producing and it's

4621
03:05:23,279 --> 03:05:26,600
worse than what I could program that's

4622
03:05:24,880 --> 03:05:30,040
some kind of synthesis that happens

4623
03:05:26,600 --> 03:05:32,279
right that synthesis is broken for

4624
03:05:30,040 --> 03:05:33,800
everything almost

4625
03:05:32,279 --> 03:05:38,720
um

4626
03:05:33,800 --> 03:05:38,720
so we need to get that back I don't know

4627
03:05:40,560 --> 03:05:49,160
like maybe this is too rambling but

4628
03:05:45,040 --> 03:05:49,160
there's just issues like maybe

4629
03:05:50,399 --> 03:05:54,920
maybe and again we've talked about this

4630
03:05:53,200 --> 03:05:57,000
before but maybe the fundamental

4631
03:05:54,920 --> 03:05:58,600
fundamental issue

4632
03:05:57,000 --> 03:06:01,359
is

4633
03:05:58,600 --> 03:06:03,640
um that the culture of programming needs

4634
03:06:01,359 --> 03:06:06,200
to be built

4635
03:06:03,640 --> 03:06:08,239
around acknowledgment of clearly

4636
03:06:06,200 --> 03:06:11,600
demonstrated

4637
03:06:08,239 --> 03:06:15,200
quality right because like if you had if

4638
03:06:11,600 --> 03:06:18,120
you had an MMA cage match between ler

4639
03:06:15,200 --> 03:06:19,479
parser generator and like hand coded

4640
03:06:18,120 --> 03:06:23,279
thing like the hand coded thing would

4641
03:06:19,479 --> 03:06:25,960
win on every metric actually right like

4642
03:06:23,279 --> 03:06:28,840
literally it would win on speed it would

4643
03:06:25,960 --> 03:06:33,680
win on um time to successfully create

4644
03:06:28,840 --> 03:06:35,279
the thing it would win on uh it ability

4645
03:06:33,680 --> 03:06:39,080
it would lose on one thing ability to

4646
03:06:35,279 --> 03:06:41,720
publish papers uh no it would lose on um

4647
03:06:39,080 --> 03:06:44,040
incremental so it's very hard actually

4648
03:06:41,720 --> 03:06:48,439
to write uh an incremental top down

4649
03:06:44,040 --> 03:06:51,520
parser that can stop at any point it's

4650
03:06:48,439 --> 03:06:53,520
harder yeah just already does it's like

4651
03:06:51,520 --> 03:06:55,560
it or it is that by Design like you just

4652
03:06:53,520 --> 03:06:57,399
get that for free yeah so that's the one

4653
03:06:55,560 --> 03:06:59,200
thing I could think of that's like top

4654
03:06:57,399 --> 03:07:01,520
down it's much harder to write a top

4655
03:06:59,200 --> 03:07:03,840
down re uh stop anywhere parser that can

4656
03:07:01,520 --> 03:07:06,880
just like take a new token arbitrarily

4657
03:07:03,840 --> 03:07:08,800
as like an input generally without

4658
03:07:06,880 --> 03:07:10,439
having to because because it uses the

4659
03:07:08,800 --> 03:07:13,319
program stack I mean that's just kind of

4660
03:07:10,439 --> 03:07:15,120
how that is yeah I see the point um I

4661
03:07:13,319 --> 03:07:16,680
will just say that because I haven't

4662
03:07:15,120 --> 03:07:18,840
thought about the

4663
03:07:16,680 --> 03:07:22,680
problem um I'm not sure that it's

4664
03:07:18,840 --> 03:07:25,720
actually all that hard simply because

4665
03:07:22,680 --> 03:07:27,040
like that's easier than the freaking uh

4666
03:07:25,720 --> 03:07:30,960
typee checking stuff that we do which

4667
03:07:27,040 --> 03:07:33,080
has to stop anywhere so you know um I'm

4668
03:07:30,960 --> 03:07:34,560
just saying it's not it's easier in LR

4669
03:07:33,080 --> 03:07:36,040
because it already works that way well

4670
03:07:34,560 --> 03:07:38,040
let's put it this way it has a state

4671
03:07:36,040 --> 03:07:39,880
table so it's done doesn't have to do

4672
03:07:38,040 --> 03:07:41,560
anything you you would have to add like

4673
03:07:39,880 --> 03:07:43,640
the code that we showed today would not

4674
03:07:41,560 --> 03:07:45,399
do that would not work yeah you have to

4675
03:07:43,640 --> 03:07:48,439
add stuff to it is my only point but

4676
03:07:45,399 --> 03:07:50,279
anyway keep going um but it may not even

4677
03:07:48,439 --> 03:07:51,880
be that much but the point being like

4678
03:07:50,279 --> 03:07:55,160
that's that's just not the culture

4679
03:07:51,880 --> 03:07:56,920
somehow and the culture is just you make

4680
03:07:55,160 --> 03:07:59,880
claims and then people believe the

4681
03:07:56,920 --> 03:08:03,520
claims and the claims act as propaganda

4682
03:07:59,880 --> 03:08:07,279
and that's how everything gets popular

4683
03:08:03,520 --> 03:08:08,720
and I it's just really harmful and I

4684
03:08:07,279 --> 03:08:11,359
don't know at this point it's nothing I

4685
03:08:08,720 --> 03:08:14,520
haven't said before

4686
03:08:11,359 --> 03:08:17,279
but the end

4687
03:08:14,520 --> 03:08:18,640
all right all right thanks Casey for

4688
03:08:17,279 --> 03:08:21,680
coming by and talking about this for

4689
03:08:18,640 --> 03:08:24,200
several hours oh no problem thanks for I

4690
03:08:21,680 --> 03:08:26,080
think they were good no but I I like the

4691
03:08:24,200 --> 03:08:28,399
like as someone who does not work on

4692
03:08:26,080 --> 03:08:30,600
parsers I appreciate new explanations of

4693
03:08:28,399 --> 03:08:33,840
them because you know if I ever actually

4694
03:08:30,600 --> 03:08:35,880
do decide to go write a parser this I I

4695
03:08:33,840 --> 03:08:37,760
am almost certainly in a much better

4696
03:08:35,880 --> 03:08:39,319
position well I could recommend you a

4697
03:08:37,760 --> 03:08:41,840
book right

4698
03:08:39,319 --> 03:08:44,239
here it's got excellent computer

4699
03:08:41,840 --> 03:08:46,040
Graphics yes

4700
03:08:44,239 --> 03:08:47,359
yes yeah all right thanks everybody for

4701
03:08:46,040 --> 03:08:49,479
coming by we'll post this on YouTube

4702
03:08:47,359 --> 03:08:52,760
later because you surely missed a lot of

4703
03:08:49,479 --> 03:08:55,960
it because it's three hours yep thanks

4704
03:08:52,760 --> 03:08:55,960
take it easy everyone yeah

